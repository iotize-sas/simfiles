[Description]
Name = STR711FR0
[Memory]
CodeStart =1073741824
CodeSize =81920
RAMStart =536870912
RAMSize =16384
[ARMType]
Manufacturer=ST
ARMCore=7
ARMCoreType=1
CoreName=ARM7
[Plugin]
pgmpluginhexfilename=plugin_STR7_pgm.hex
FixedPluginAddressesOffset=00
[map_mem]
FLASH_BaseAddr=40000000
FLASH_SIZE=C4000
RAM_BaseAddr=20000000
RAM_SIZE=10000
addrBCON1=6C000004
OffsetBank1=C0000
[power]
VCCmin=25
VCCmax=40
[flash]
NbBank=2
IsSectors=1
Flash_Protected=0
Flash_Protection_Registers=10DFB0
IsFlashCheckSum=0
ADDR_B0F0=00000
ADDR_B0F1=02000
ADDR_B0F2=04000
ADDR_B0F3=06000
ADDR_B0F4=08000
ADDR_B0F5=10000
ADDR_B0F6=20000
ADDR_B0F7=30000
SIZE_B0F0=02000
SIZE_B0F1=02000
SIZE_B0F2=02000
SIZE_B0F3=02000
SIZE_B0F4=08000
SIZE_B0F5=10000
SIZE_B0F6=10000
SIZE_B0F7=10000
ADDR_B1F0=C0000
ADDR_B1F1=C2000
SIZE_B1F0=02000
SIZE_B1F1=02000
[JTAG]
IRLen=4
IdCode=3F0F0F0F
MaskID=0FFFFFFF
fNeedTRSTforReset=1
IntIRLenBefore[1]=0
IntDRLenBefore=0
IntIRLenAfter[1]=0
IntDRLenAfter=0
IsDBGRQ=1
IsSMBM=0
BusLength=28
[ThumbMode]
DELTA=E7FAE7FA
[BOOT_MODE]
BootModeReg=A0000050
NbUserMode=2
[initatreset]
init_number=1
init_1_address=FFFFF800
init_1_value=0
[PDKGenPeriph]
PeriphsNumber = 24
Periph_1_Name = Power/Clock/Reset
Periph_2_Name = RTC
Periph_3_Name = Watchdog
Periph_4_Name = Timer0
Periph_5_Name = Timer1
Periph_6_Name = Timer2
Periph_7_Name = Timer3
Periph_8_Name = BSPI0
Periph_9_Name = BSPI1
Periph_10_Name = FLASH_CTRL
Periph_11_Name = I2C0
Periph_12_Name = I2C1
Periph_13_Name = USB
Periph_14_Name = ADC
Periph_15_Name = EIC
Periph_16_Name = XTI
Periph_17_Name = HDLC
Periph_18_Name = SC
Periph_19_Name = UART0
Periph_20_Name = UART1
Periph_21_Name = UART2
Periph_22_Name = UART3
Periph_23_Name = APB0
Periph_24_Name = APB1
[Power/Clock/Reset]
SegmentsNumber = 1
Segment_1 = PRCCU_SEG, 32, 0xA0000000, 0x58
SymbsNumber = 11
Symb_1 = PRCCU_CCR, 0, 0xA0000000
Symb_2 = PRCCU_CFR, 0, 0xA0000008
Symb_3 = PRCCU_PLL1CR, 0, 0xA0000018
Symb_4 = PRCCU_PER, 0, 0xA000001C
Symb_5 = PRCCU_SMR, 0, 0xA0000020
Symb_6 = PRCCU_MDIVR, 0, 0xA0000040
Symb_7 = PRCCU_PDIVR, 0, 0xA0000044
Symb_8 = PRCCU_RSTR, 0, 0xA0000048
Symb_9 = PRCCU_PLL2CR, 0, 0xA000004C
Symb_10 = PRCCU_BOOTCR, 0, 0xA0000050
Symb_11 = PRCCU_PWRCR, 0, 0xA0000054
ResetCode = {SetDWordValue(0,0xA0000000,0);SetDWordValue(0,0xA0000008,0x00008008);SetDWordValue(0,0xA0000018,0x00000007);SetDWordValue(0,0xA000001C,0x0001FFFF);SetWordValue(0,0xA0000020,0x0001);SetWordValue(0,0xA0000040,0x0000);SetWordValue(0,0xA0000044,0x0000);SetWordValue(0,0xA000004C,0x0033);SetWordValue(0,0xA0000050,0x01C0);SetWordValue(0,0xA0000054,0x0);}
GroupsNumber = 11
Group_1_Name = Clock Ctrl Register(CCR)
Group_1_ItemsNumber = 10
Group_1_Item_1_Name = PRCCU_CCR
Group_1_Item_1_Comment = "Clock Control Register (RCCU_ CCR).\n•Base address: 0xA000 0000h.\n•Address offset: 0x00h.\n•Reset value:0x0000 0000h.\n•Bit 32-12 = Reserved, always read as 0."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xA0000000).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xA0000000,parseInt(GetString()));
Group_1_Item_2_Name = LPOWFI
Group_1_Item_2_Comment = "Bit 0 = LPOWFI: Low Power mode during Wait For Interrupt.\n•0: Low Power mode during WFI disabled. When WFI is executed, MCLK is unchanged.\n•1: The device enters Low Power mode when the WFI instruction is executed. The clock during this state depends on WFI_CKSEL."
Group_1_Item_2_Type = 1, disabled, enabled
Group_1_Item_2_CodingProc = SetInt((GetWordValue(0,0xA0000000)&1)?1:0);
Group_1_Item_2_DecodingProc = SetWordValue(0,0xA0000000,(GetInt()?1:0)|(GetWordValue(0,0xA0000000)&~1));
Group_1_Item_3_Name = WFI_CKSEL
Group_1_Item_3_Comment = "Bit 1 = WFI_CKSEL: WFI Clock Select.\nThis bit selects the clock used in Low power WFI mode if LPOWFI = 1.\n•0: MCLK during Low Power WFI is CLK2/16.\n•1: MCLK during Low Power WFI is CK_AF, providing it is present. In effect this bit sets CKAF_SEL in WFI mode."
Group_1_Item_3_Type = 1, CLK2/16, CK_AF
Group_1_Item_3_CodingProc = SetInt((GetWordValue(0,0xA0000000)&2)?1:0);
Group_1_Item_3_DecodingProc = SetWordValue(0,0xA0000000,(GetInt()?2:0)|(GetWordValue(0,0xA0000000)&~2));
Group_1_Item_4_Name = CKAF_SEL
Group_1_Item_4_Comment = "Bit 2 = CKAF_SEL: Alternate Function Clock Select.\n•0: Deselect CK_AF clock.\n•1: Select CK_AF clock."
Group_1_Item_4_Type = 1, deselected, selected
Group_1_Item_4_CodingProc = SetInt((GetWordValue(0,0xA0000000)&4)?1:0);
Group_1_Item_4_DecodingProc = SetWordValue(0,0xA0000000,(GetInt()?4:0)|(GetWordValue(0,0xA0000000)&~4));
Group_1_Item_5_Name = SRESEN
Group_1_Item_5_Comment = "Bit 3 = SRESEN: Software Reset Enable.\n•0: No Software Reset.\n•1: Software Reset when software sets the HALT bit in the RCCU_SMR register and if EN_HALT=1."
Group_1_Item_5_Type = 1, no soft reset, software reset
Group_1_Item_5_CodingProc = SetInt((GetWordValue(0,0xA0000000)&8)?1:0);
Group_1_Item_5_DecodingProc = SetWordValue(0,0xA0000000,(GetInt()?8:0)|(GetWordValue(0,0xA0000000)&~8));
Group_1_Item_6_Name = EN_LOCK
Group_1_Item_6_Comment = "Bit 7 = EN_LOCK: Lock Interrupt Masking bit.\n•0: LOCK switching interrupt request disabled.\n•1: LOCK switching interrupt request enabled."
Group_1_Item_6_Type = 1, disabled, enabled
Group_1_Item_6_CodingProc = SetInt((GetWordValue(0,0xA0000000)&0x80)?1:0);
Group_1_Item_6_DecodingProc = SetWordValue(0,0xA0000000,(GetInt()?0x80:0)|(GetWordValue(0,0xA0000000)&~0x80));
Group_1_Item_7_Name = EN_CKAF
Group_1_Item_7_Comment = "Bit 8 = EN_CKAF: CKAF Interrupt Masking bit.\n•0: CKAF switching interrupt request disabled.\n•1: CKAF switching interrupt request enabled."
Group_1_Item_7_Type = 1, disabled, enabled
Group_1_Item_7_CodingProc = SetInt((GetWordValue(0,0xA0000000)&0x100)?1:0);
Group_1_Item_7_DecodingProc = SetWordValue(0,0xA0000000,(GetInt()?0x100:0)|(GetWordValue(0,0xA0000000)&~0x100));
Group_1_Item_8_Name = EN_CK2_16
Group_1_Item_8_Comment = "Bit 9 = EN_CK2_16: CK2_16 Interrupt Masking bit.\n•0: CK2_16 switching interrupt disabled.\n•1: CK2_16 switching interrupt enabled."
Group_1_Item_8_Type = 1, disabled, enabled
Group_1_Item_8_CodingProc = SetInt((GetWordValue(0,0xA0000000)&0x200)?1:0);
Group_1_Item_8_DecodingProc = SetWordValue(0,0xA0000000,(GetInt()?0x200:0)|(GetWordValue(0,0xA0000000)&~0x200));
Group_1_Item_9_Name = EN_STOP
Group_1_Item_9_Comment = "Bit 10 = EN_STOP: Stop Interrupt Masking bit.\n•0: Stop interrupt request disabled.\n•1: Stop interrupt request enabled."
Group_1_Item_9_Type = 1, disabled, enabled
Group_1_Item_9_CodingProc = SetInt((GetWordValue(0,0xA0000000)&0x400)?1:0);
Group_1_Item_9_DecodingProc = SetWordValue(0,0xA0000000,(GetInt()?0x400:0)|(GetWordValue(0,0xA0000000)&~0x400));
Group_1_Item_10_Name = EN_HALT
Group_1_Item_10_Comment = "Bit 11 = EN_HALT: Enable Halt bit.\n•0: No Software Reset.\n•1: Software Reset when software sets the HALT bit in the RCCU_SMR register and if SRESEN=1."
Group_1_Item_10_Type = 1, disabled, enabled
Group_1_Item_10_CodingProc = SetInt((GetWordValue(0,0xA0000000)&0x800)?1:0);
Group_1_Item_10_DecodingProc = SetWordValue(0,0xA0000000,(GetInt()?0x800:0)|(GetWordValue(0,0xA0000000)&~0x800));
Group_2_Name = Clock Flag Register(CFR)
Group_2_ItemsNumber = 14
Group_2_CodingProc = SetString("0x"+GetWordValue(0,0xA0000008).toString(16));
Group_2_DecodingProc = SetWordValue(0,0xA0000008,parseInt(GetString()));
Group_2_Item_1_Name = CSU_CKSEL
Group_2_Item_1_Comment = "Bit 0 = CSU_CKSEL: CSU Clock Select.\nThis bit is set and cleared by software. It is kept reset by hardware when:\n- bits DX[2:0] (RCCU_PLL1CR) are set to 111;\n- the quartz is stopped (by hardware or software);\n- the CK2_16 bit (RCCU_CFR) is forced to ’0’.\n•0: CLK2 provides the system clock.\n•1: The PLL Multiplier provides the system clock if LOCK and VROK bits are ‘1’.\nIf the FREEN bit is set, this bit selects this clock independently of the LOCK and VROK bits.\n•Note: Setting the CKAF_SEL bit overrides any other clock selection. The clearing the CK2_16 bit overrides the CSU_CKSEL selection."
Group_2_Item_1_Type = 1, disabled, enabled
Group_2_Item_1_CodingProc = SetInt((GetWordValue(0,0xA0000008)&1)?1:0);
Group_2_Item_1_DecodingProc = SetWordValue(0,0xA0000008,(GetInt()?1:0)|(GetWordValue(0,0xA0000008)&~1));
Group_2_Item_2_Name = LOCK
Group_2_Item_2_Comment = "Bit 1 = LOCK: PLL locked-in.\nThis bit is read only.\n•0: The PLL is turned off or not locked and cannot be selected as RCLK source.\n•1: The PLL is locked."
Group_2_Item_2_Type = 1, CLK2/16, CK_AF
Group_2_Item_2_CodingProc = SetInt((GetWordValue(0,0xA0000008)&2)?1:0);
Group_2_Item_3_Name = CKAF_ST
Group_2_Item_3_Comment = "Bit 2 = CKAF_ST: CK _AF Status.\nThis bit is read only.\n•0: The PLL clock, CLK2 or CLK2/16 is the RCLK source (depending on CSU_CKSEL and CK2_16 bits).\n•1: CK_AF is the RCLK source."
Group_2_Item_3_Type = 1, deselected, selected
Group_2_Item_3_CodingProc = SetInt((GetWordValue(0,0xA0000008)&4)?1:0);
Group_2_Item_4_Name = CK2_16
Group_2_Item_4_Comment = "Bit 3 = CK2_16: CLK2/16 Selection.\n•0: CLK2/16 is selected as RCLK source and the PLL is off.\n•1: The RCLK source is CLK2 (or the PLL output depending on the value of CSU_CKSEL)."
Group_2_Item_4_Type = 1, deselected, selected
Group_2_Item_4_CodingProc = SetInt((GetWordValue(0,0xA0000008)&8)?1:0);
Group_2_Item_4_DecodingProc = SetWordValue(0,0xA0000008,(GetInt()?8:0)|(GetWordValue(0,0xA0000008)&~8));
Group_2_Item_5_Name = SOFTRES
Group_2_Item_5_Comment = "Bit 5 = SOFTRES: Software Reset Flag.\nThis bit is read only.\n•0: No software reset occurred.\n•1: Software reset occurred."
Group_2_Item_5_Type = 1, no soft reset, software reset
Group_2_Item_5_CodingProc = SetInt((GetWordValue(0,0xA0000008)&0x20)?1:0);
Group_2_Item_6_Name = WDG_RES
Group_2_Item_6_Comment = "Bit 6 = WDG_RES: Watchdog reset flag.\nThis bit is read only.\n•0: No Watchdog reset occurred.\n•1: Watchdog reset occurred."
Group_2_Item_6_Type = 1, no WDG reset occured, RESET BY WDG
Group_2_Item_6_CodingProc = SetInt((GetWordValue(0,0xA0000008)&0x40)?1:0);
Group_2_Item_7_Name = RTC_ALARM
Group_2_Item_7_Comment = "Bit 7 = RTC_ALARM: Real-Time-Clock alarm reset flag.\nThis bit is read only.\n•0: No RTC alarm event occurred.\n•1: Reset was generated by RTC alarm during Standby mode."
Group_2_Item_7_Type = 1, no RTC reset occured, RESET BY RTC
Group_2_Item_7_CodingProc = SetInt((GetWordValue(0,0xA0000008)&0x80)?1:0);
Group_2_Item_8_Name = LVD_RES
Group_2_Item_8_Comment = "Bit 9 = LVD_RES: Main Voltage Regulator LVD reset flag.\nThis bit is read only.\n•0: No Main voltage regulator LVD reset occurred.\n•1: Main voltage regulator LVD reset occurred."
Group_2_Item_8_Type = 1, no LVD reset occured, RESET BY LVD
Group_2_Item_8_CodingProc = SetInt((GetWordValue(0,0xA0000008)&0x200)?1:0);
Group_2_Item_9_Name = WKP_RES
Group_2_Item_9_Comment = "Bit 10 = WKP_RES: External WakeUP flag.\nThis bit is read only.\n•0: No WakeUp reset occurred.\n•1: Reset was generated by an External WakeUp event in Standby mode."
Group_2_Item_9_Type = 1, no WakeUp reset occured, RESET BY WakeUp
Group_2_Item_9_CodingProc = SetInt((GetWordValue(0,0xA0000008)&0x400)?1:0);
Group_2_Item_10_Name = LOCK_I
Group_2_Item_10_Comment = "Bit 11 = LOCK_I: Lock Interrupt pending bit.\nThis bit is clear only.\n•0: No Lock Interrupt request pending.\n•1: Lock Interrupt request pending."
Group_2_Item_10_Type = 1, no Lock IRQ pending, Lock IRQ pending
Group_2_Item_10_CodingProc = SetInt((GetWordValue(0,0xA0000008)&0x800)?1:0);
Group_2_Item_10_DecodingProc = SetWordValue(0,0xA0000008,(GetInt()?0x800:0)|(GetWordValue(0,0xA0000008)&~0x800));
Group_2_Item_11_Name = CKAF_I
Group_2_Item_11_Comment = "Bit 12 = CKAF_I: CK_AF switching Interrupt pending bit.\nThis bit is clear only.\n•0: No CK_AF switching Interrupt request pending.\n•1: CK_AF switching Interrupt request pending."
Group_2_Item_11_Type = 1, no CK_AF IRQ pending, CK_AF IRQ pending
Group_2_Item_11_CodingProc = SetInt((GetWordValue(0,0xA0000008)&0x1000)?1:0);
Group_2_Item_11_DecodingProc = SetWordValue(0,0xA0000008,(GetInt()?0x1000:0)|(GetWordValue(0,0xA0000008)&~0x1000));
Group_2_Item_12_Name = CK2_16_I
Group_2_Item_12_Comment = "Bit 13 = CK2_16_I: CK2_16 switching Interrupt pending bit.\nThis bit is clear only.\n•0: No CK2_16 Interrupt request pending.\n•1: CK2_16 Interrupt request pending."
Group_2_Item_12_Type = 1, no CK2_16 IRQ pending, CK2_16 IRQ pending
Group_2_Item_12_CodingProc = SetInt((GetWordValue(0,0xA0000008)&0x2000)?1:0);
Group_2_Item_12_DecodingProc = SetWordValue(0,0xA0000008,(GetInt()?0x2000:0)|(GetWordValue(0,0xA0000008)&~0x2000));
Group_2_Item_13_Name = STOP_I
Group_2_Item_13_Comment = "Bit 14 = STOP_I: Stop Interrupt pending bit.\nThis bit is clear only.\n•0: No Stop interrupt request pending.\n•1: Stop Interrupt request is pending."
Group_2_Item_13_Type = 1, no Stop IRQ pending (0), Stop IRQ pending (1)
Group_2_Item_13_CodingProc = SetInt((GetWordValue(0,0xA0000008)&0x4000)?1:0);
Group_2_Item_13_DecodingProc = SetWordValue(0,0xA0000008,(GetInt()?0x4000:0)|(GetWordValue(0,0xA0000008)&~0x4000));
Group_2_Item_14_Name = DIV2
Group_2_Item_14_Comment = "Bit 15 = DIV2: OSCIN Divided by 2.\nThis bit controls the divide-by-2 circuit which operates on the CLK signal.\n•0: No division of CLK frequency.\n•1: CLK is divided by 2."
Group_2_Item_14_Type = 1, no division of CLK, CLK divided by 2
Group_2_Item_14_CodingProc = SetInt((GetWordValue(0,0xA0000008)&0x8000)?1:0);
Group_2_Item_14_DecodingProc = SetWordValue(0,0xA0000008,(GetInt()?0x8000:0)|(GetWordValue(0,0xA0000008)&~0x8000));
Group_3_Name = PLL Conf (PLL1CR)
Group_3_Comment = "PLL Configuration Register (RCCU_PLL1CR)"
Group_3_ItemsNumber = 5
Group_3_Item_1_Name = PRCCU_PLL1CR
Group_3_Item_1_Comment = "PRCCU_PLL1CR\n•Base address: 0xA000 0000h.\n•Address offset: 0x18h.\n•Reset value: 0000 0007h."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xA0000018).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xA0000018,parseInt(GetString()));
Group_3_Item_2_Name = DX
Group_3_Item_2_Comment = "Bit 2:0 = DX[2:0]: PLL output clock division factor.\n•0=>PLLCK / 1.\n•1=>PLLCK / 2.\n•2=>PLLCK / 3.\n•3=>PLLCK / 4.\n•4=>PLLCK / 5.\n•5=>PLLCK / 6.\n•6=>PLLCK / 7.\n•7 and FREEN= 0: CLK2 (PLL OFF, Reset State).\n•7 and FREEN=1: PLL in Free Running mode."
Group_3_Item_2_Type = 1, PLLCK/1, PLLCK/2, PLLCK/3, PLLCK/4, PLLCK/5, PLLCK/6, PLLCK/7, CLK2 (PLL OFF)
Group_3_Item_2_CodingProc = SetInt(GetWordValue(0,0xA0000018)&7);
Group_3_Item_2_DecodingProc = SetWordValue(0,0xA0000018,GetInt()|(GetWordValue(0,0xA0000018)&~7));
Group_3_Item_3_Name = MX
Group_3_Item_3_Comment = "Bit 5:4 = MX[1:0]: PLL Multiplication Factor.\n•Note: It is recommended to deselect and switch-off the PLL before changing MX values."
Group_3_Item_3_Type = 1, CLK2*20,CLK2*12,CLK2*28,CLK2*16
Group_3_Item_3_CodingProc = SetInt( (GetWordValue(0,0xA0000018)&0x30)>>4 );
Group_3_Item_3_DecodingProc = SetWordValue(0,0xA0000018,(GetInt()<<4)|(GetWordValue(0,0xA0000018)&~0x30));
Group_3_Item_4_Name = FREF_RANGE
Group_3_Item_4_Comment = "Bit 6 = FREF_RANGE: Reference Frequency Range selector bit.\n•0: Configure PLL for input frequency (CLK2) of 1.5-3MHz.\n•1: Configure PLL for input frequency (CLK2) of greater than 3MHz."
Group_3_Item_4_Type = 1, configured for 1.5-3MHz, configured for > 3MHz
Group_3_Item_4_CodingProc = SetInt((GetWordValue(0,0xA0000018)&0x40)?1:0);
Group_3_Item_4_DecodingProc = SetWordValue(0,0xA0000018,(GetInt()?0x40:0)|(GetWordValue(0,0xA0000018)&~0x40));
Group_3_Item_5_Name = FREEN
Group_3_Item_5_Comment = "Bit 7 = FREEN: PLL Free Running Mode Enable.\n•0: Free Running mode disabled.\nIn this case, the PLL operation depends only on the MX[1:0] and DX[2:0] bits.\n•1: Free Running mode enabled.\nIn this mode, when all three DX[2:0] bits are set, the PLL is not stopped but provides a slow frequency back-up clock, selected by the CSU_CKSEL bit; Operation in this mode not require the LOCK and VROK bits to be set, and is independent of the MX[1:0] bit settings."
Group_3_Item_5_Type = 1, disabled, Free running enabled
Group_3_Item_5_CodingProc = SetInt((GetWordValue(0,0xA0000018)&0x80)?1:0);
Group_3_Item_5_DecodingProc = SetWordValue(0,0xA0000018,(GetInt()?0x80:0)|(GetWordValue(0,0xA0000018)&~0x80));
Group_4_Name = Peripheral Enable (PER)
Group_4_ItemsNumber = 3
Group_4_Item_1_Name = PRCCU_PER
Group_4_Item_1_Comment = "Peripheral Enable Register (RCCU_PER).\n•Base address: A000 0000h.\n•Address offset: 1Ch.\n•Reset value: 0001 FFFFh."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0xA000001C).toString(16));
Group_4_Item_1_DecodingProc = SetDWordValue(0,0xA0000018,parseInt(GetString()));
Group_4_Item_2_Name = EMI clk-en
Group_4_Item_2_Comment = "PH_CK[2] = 0 means EMI stopped."
Group_4_Item_2_Type = 1, disabled, enabled
Group_4_Item_2_CodingProc = SetInt((GetWordValue(0,0xA000001C)&0x04)?1:0);
Group_4_Item_2_DecodingProc = SetWordValue(0,0xA000001C,(GetInt()?0x04:0)|(GetWordValue(0,0xA000001C)&~0x04));
Group_4_Item_3_Name = USB KERNEL
Group_4_Item_3_Comment = "PH_CK[4] = 0 means USB KERNEL stopped."
Group_4_Item_3_Type = 1, disabled, enabled
Group_4_Item_3_CodingProc = SetInt((GetWordValue(0,0xA000001C)&0x10)?1:0);
Group_4_Item_3_DecodingProc = SetWordValue(0,0xA000001C,(GetInt()?0x10:0)|(GetWordValue(0,0xA000001C)&~0x10));
Group_5_Name = System Mode (SMR)
Group_5_Comment = "System Mode Register (RCCU_SMR)"
Group_5_ItemsNumber = 3
Group_5_Item_1_Name = PRCCU_SMR
Group_5_Item_1_Comment = "PRCCU_SMR.\n•Base address: A000 0000h.\n•Address offset: 20h.\n•Reset value: 0000 0001h."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xA0000020).toString(16));
Group_5_Item_1_DecodingProc = SetWordValue(0,0xA0000020,parseInt(GetString()));
Group_5_Item_2_Name = WFI
Group_5_Item_2_Comment = "Bit 0 = WFI: Wait For Interrupt mode.\n•0: Enter WFI (Wait For Interrupt) mode. In this mode the CPU remains in idle state until an interrupt request is acknowledged by the EIC. When this occurs, the bit is set to ‘1’ again. This means that this bit, once reset, can only be set to ‘1’ by hardware.\n•1: No effect\n•Caution: If all EIC interrupt channels are masked, clearing this bit will stop program execution indefinitely unless the device is reset. Hence you must ensure that at least one interrupt channel is enabled before clearing the WFI bit."
Group_5_Item_2_Type = 1, enter WFI, no effect
Group_5_Item_2_CodingProc = SetInt((GetWordValue(0,0xA0000020)&0x01)?1:0);
Group_5_Item_2_DecodingProc = SetWordValue(0,0xA0000020,(GetInt()?0x01:0)|(GetWordValue(0,0xA0000020)&~0x01));
Group_5_Item_3_Name = HALT
Group_5_Item_3_Comment = "Bit 1 = HALT: Halt.\n•0: No effect.\n•1: Generate a Software reset if the SRESEN bit and the ENHALT bit in the RCCU_CCR register is set."
Group_5_Item_3_Type = 1, no effect, generate a soft RST
Group_5_Item_3_CodingProc = SetInt((GetWordValue(0,0xA0000020)&0x02)?1:0);
Group_5_Item_3_DecodingProc = SetWordValue(0,0xA0000020,(GetInt()?0x02:0)|(GetWordValue(0,0xA0000020)&~0x02));
Group_6_Name = MCLK Divider (MDIVR)
Group_6_Comment = "This register sets the prescaling factor for the Main System Clock MCLK.It may be written by software at any time, to dynamically adjust the operation frequency."
Group_6_ItemsNumber = 2
Group_6_Item_1_Name = PRCCU_MDIVR
Group_6_Item_1_Comment = "MCLK Divider Control (PCU_MDIVR).\n•Address offset: 40h.\n•Reset value: 0000h."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xA0000040).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xA0000040,parseInt(GetString()));
Group_6_Item_2_Name = FACT
Group_6_Item_2_Comment = "Bit 1:0 = FACT[1:0]: Division factor.\n•00 =>ratio=1 - Default, no prescaling, MCLK = RCLK.\n•01 =>ratio=2 - MCLK = RCLK / 2.\n•10 =>ratio=4 - MCLK = RCLK / 4.\n•11 =>ratio=8 - MCLK = RCLK / 8."
Group_6_Item_2_Type = 1, 1-MCLK=RCLK,2-MCLK=RCLK/2,4-MCLK=RCLK/4,8-MCLK=RCLK/8
Group_6_Item_2_CodingProc = SetInt(GetWordValue(0,0xA0000040)&0x03);
Group_6_Item_2_DecodingProc = SetWordValue(0,0xA0000040,(GetInt()&3)|(GetWordValue(0,0xA0000040)&~0x03));
Group_7_Name = Peri. Clock Div.(PDIVR)
Group_7_Comment = "This register sets the prescaling factor for the two APB Clocks PCLK1, for peripherals belonging to the APB1 group, and PCLK2, for peripherals belonging to the APB2 group; prescaling values are listed in Table 15 on page 57. It may be written by software at any time. FACT1 and FACT2 may be chosen independently."
Group_7_Comment = "Peripheral Clock Divider Control Register (PCU_PDIVR)"
Group_7_ItemsNumber = 3
Group_7_Item_1_Name = PRCCU_PDIVR
Group_7_Item_1_Comment = "Peripheral Clock Divider Control Register (PCU_PDIVR).\n•Address offset: 44h.\n•Reset value: 0000h."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xA0000044).toString(16));
Group_7_Item_1_DecodingProc = SetWordValue(0,0xA0000044,parseInt(GetString()));
Group_7_Item_2_Name = FACT1
Group_7_Item_2_Comment = "Bit 1:0 = FACT1[1:0]: Division factor for APB1 peripherals."
Group_7_Item_2_Type = 1, 1-PCLK1=RCLK,2-PCLK1=RCLK/2,4-PCLK1=RCLK/4,8-PCLK1=RCLK/8
Group_7_Item_2_CodingProc = SetInt(GetWordValue(0,0xA0000044)&0x03);
Group_7_Item_2_DecodingProc = SetWordValue(0,0xA0000044,(GetInt()&3)|(GetWordValue(0,0xA0000044)&~0x03));
Group_7_Item_3_Name = FACT2
Group_7_Item_3_Comment = "Bit 9:8 = FACT2[1:0]: Division factor for APB2 peripherals."
Group_7_Item_3_Type = 1, 1-PCLK2=RCLK,2-PCLK2=RCLK/2,4-PCLK2=RCLK/4,8-PCLK2=RCLK/8
Group_7_Item_3_CodingProc = SetInt((GetWordValue(0,0xA0000044)>>8)&0x03);
Group_7_Item_3_DecodingProc = SetWordValue(0,0xA0000044,((GetInt()&3)<<8)|(GetWordValue(0,0xA0000044)&~0x0300));
Group_8_Name = Peri. Reset (PRSTR)
Group_8_Comment = "This register allows to force a Reset activation individually to most system blocks. Not all system blocks may be reset by software, to guarantee consistent behaviour of the device."
Group_8_ItemsNumber = 2
Group_8_Item_1_Name = PRCCU_PRSTR
Group_8_Item_1_Comment = "Peripheral Reset Control Register (PCU_PRSTR).\n•Address offset: 48h.\n•Read/Write\n•Reset value: 0000h."
Group_8_Item_1_Type = 0
Group_8_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xA0000048).toString(16));
Group_8_Item_1_DecodingProc = SetWordValue(0,0xA0000048,parseInt(GetString()));
Group_8_Item_2_Name = EMIRST
Group_8_Item_2_Comment = "•If this bit is set to logical one, the External Memory interface peripheral will be forced to Reset state. Reset activation/ deactivation is synchronous with system clock MCLK.\n•If this bit is set to logical zero, the EMI operate normally."
Group_8_Item_2_Type = 1, disabled, enabled
Group_8_Item_2_CodingProc = SetInt((GetWordValue(0,0xA0000048)&0x04)?1:0);
Group_8_Item_2_DecodingProc = SetWordValue(0,0xA0000048,(GetInt()?4:0)|(GetWordValue(0,0xA0000048)&~0x04));
Group_9_Name = PLL2 Control (PLL2CR)
Group_9_Comment = "This register controls operation of the PLL2, dedicated to HDLC or USB blocks."
Group_9_ItemsNumber = 9
Group_9_Item_1_Name = PRCCU_PLL2CR
Group_9_Item_1_Comment = "PLL2 Control Register (PCU_PLL2CR).\n•Address offset: 4Ch.\n•Reset value: 0033h."
Group_9_Item_1_Type = 0
Group_9_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xA000004C).toString(16));
Group_9_Item_1_DecodingProc = SetWordValue(0,0xA000004C,parseInt(GetString()));
Group_9_Item_2_Name = DX
Group_9_Item_2_Comment = "Bit 2:0 = DX[2:0]: PLL output clock divider factor."
Group_9_Item_2_Type = 1, PLL Clock/1,PLL Clock/2,PLL Clock/3,PLL Clock/4,PLL Clock/5,PLL Clock/6,PLL Clock/7,PLL OFF
Group_9_Item_2_CodingProc = SetInt(GetWordValue(0,0xA000004C)&0x07);
Group_9_Item_2_DecodingProc = SetWordValue(0,0xA000004C,GetInt()|(GetWordValue(0,0xA000004C)&~0x07));
Group_9_Item_3_Name = MX
Group_9_Item_3_Comment = "Bit 5:4 = MX[1:0]: PLL Multiplication Factor."
Group_9_Item_3_Type = 1, PLL*20,PLL*12,PLL*28,PLL*16
Group_9_Item_3_CodingProc = SetInt( (GetWordValue(0,0xA000004C)&0x30)>>4 );
Group_9_Item_3_DecodingProc = SetWordValue(0,0xA000004C,(GetInt()<<4)|(GetWordValue(0,0xA000004C)&~0x30));
Group_9_Item_4_Name = FRQRNG
Group_9_Item_4_Comment = "Bit 6 = FRQRNG: PLL2 frequency range selection.\n•This bit has to be set by software when the PLL input frequency (HCLK pin) is in the range 3-5 MHz;\n•This bit has to be cleared by software when the PLL input frequency (HCLK pin) is in the range 1.5-3 MHz."
Group_9_Item_4_Type = 1, configured for 1.5-3MHz, configured for > 3MHz
Group_9_Item_4_CodingProc = SetInt((GetWordValue(0,0xA000004C)&0x40)?1:0);
Group_9_Item_4_DecodingProc = SetWordValue(0,0xA000004C,(GetInt()?0x40:0)|(GetWordValue(0,0xA000004C)&~0x40));
Group_9_Item_5_Name = PLLEN
Group_9_Item_5_Comment = "Bit 7 = PLLEN: Select PLL.\n•When this bit is reset (default) the PLL is bypassed, but not switched off, and HCLK drives the internal logic directly (HDLC, or USB if selected setting bit 8, USBEN.\n•When PLLEN is set the PLL output is selected as source clock for the logic. It is forbidden to set this bit if the bit 15, LOCK, is reset.\nIf the PLL unlocks for any reason, this bit is reset by Hardware."
Group_9_Item_5_Type = 1, disabled, enabled
Group_9_Item_5_CodingProc = SetInt((GetWordValue(0,0xA000004C)&0x80)?1:0);
Group_9_Item_5_DecodingProc = SetWordValue(0,0xA000004C,(GetInt()?0x80:0)|(GetWordValue(0,0xA000004C)&~0x80));
Group_9_Item_6_Name = USBEN
Group_9_Item_6_Comment = "Bit 8 = USBEN: Enable PLL clock to USB.\n•When this bit is reset (default) the 48 MHz reference clock for USB is connected to USBCLK pin;\n•When it is set the reference clock for USB is provided by HCLK pin, through PLL2.\nInput frequency, Multiplication and Division factors must be appropriately chosen to guarantee the precision required by USB standard."
Group_9_Item_6_Type = 1, disabled, enabled
Group_9_Item_6_CodingProc = SetInt((GetWordValue(0,0xA000004C)&0x100)?1:0);
Group_9_Item_6_DecodingProc = SetWordValue(0,0xA000004C,(GetInt()?0x100:0)|(GetWordValue(0,0xA000004C)&~0x100));
Group_9_Item_7_Name = IRQMASK
Group_9_Item_7_Comment = "Bit 9 = IRQ MASK: Enable Interrupt Request to CPU on LOCK transition.\n•When this bit is reset (default) no interrupt is generated by PLL2;\n•When it is set any change in LOCK status will generate an Interrupt request.\nThe pending request is cleared by reading this register."
Group_9_Item_7_Type = 1, disabled, enabled
Group_9_Item_7_CodingProc = SetInt((GetWordValue(0,0xA000004C)&0x200)?1:0);
Group_9_Item_7_DecodingProc = SetWordValue(0,0xA000004C,(GetInt()?0x200:0)|(GetWordValue(0,0xA000004C)&~0x200));
Group_9_Item_8_Name = IRQPEND
Group_9_Item_8_Comment = "Bit 10 = IRQ PEND: Interrupt Request to CPU on LOCK transition Pending.Set by hardware, Clear Only by software.\n•When this bit is set a Lock Status Change Interrupt request is pending.\nThis interrupt request is mapped on the PRCCU Interrupt vector. The pending request is removed by WRITING this bit TO ONE."
Group_9_Item_8_Type = 1, disabled, enabled
Group_9_Item_8_CodingProc = SetInt((GetWordValue(0,0xA000004C)&0x400)?1:0);
Group_9_Item_8_DecodingProc = SetWordValue(0,0xA000004C,(GetInt()?0x400:0)|(GetWordValue(0,0xA000004C)&~0x400));
Group_9_Item_9_Name = LOCK
Group_9_Item_9_Comment = "Bit 15 = LOCK: PLL2 Locked. Read Only.\nThis bit is set by HW when the PLL2 is locked on the input reference clock and provides a stable frequency. Any change of this bit may generate an interrupt request, if enabled by setting bit 9, IRQ MASK."
Group_9_Item_9_Type = 1, locked, unlocked
Group_9_Item_9_CodingProc = SetInt((GetWordValue(0,0xA000004C)&0x8000)?1:0);
Group_10_Name = Boot Config (BOOTCR)
Group_10_Comment = "This register includes Boot options and other global configuration controls."
Group_10_ItemsNumber = 9
Group_10_Item_1_Name = PRCCU_BOOTCR
Group_10_Item_1_Comment = "Boot Configuration Register (PCU_BOOTCR).\n•Address offset: 50h.\n•Reset value: 0000 00p1 1100 00bb."
Group_10_Item_1_Type = 0
Group_10_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xA0000050).toString(16));
Group_10_Item_1_DecodingProc = SetWordValue(0,0xA0000050,parseInt(GetString()));
Group_10_Item_2_Name = Boot Mode
Group_10_Item_2_Comment = "Bit 1:0 = BOOT[1:0]: Boot Mode.\nThese bits report the Boot configuration as selected by the user on Boot[1:0] pins or through JTAG programming, encoded as:\n•0=>FASH\n•1=>BOOT\n•2=>RAM\n•3=>EXTERNAL."
Group_10_Item_2_Type = 1, FLASH, BOOT, RAM, EXTERNAL
Group_10_Item_2_CodingProc = SetInt(GetWordValue(0,0xA0000050)&0x03);
Group_10_Item_2_DecodingProc = SetWordValue(0,0xA0000050,GetInt()|(GetWordValue(0,0xA0000050)&~0x03));
Group_10_Item_3_Name = SPI0EN
Group_10_Item_3_Comment = "Bit 2 = SPI0 EN: Enable SPI0. Read/Write.\n•When this bit is cleared (Reset value), the SPI0 interface controller is disabled, and pins P0.0 to P0.3 can be used by UART3 and I2C1.\n•When this bit is set, the SPI0 interface controller is enabled, and will access pins P0.0 to P0.3. (if they are programmed as Alternate Function). In this state UART3 and I2C1 are not available to the application."
Group_10_Item_3_Type = 1, disabled, enabled
Group_10_Item_3_CodingProc = SetInt((GetWordValue(0,0xA0000050)&0x04)?1:0);
Group_10_Item_3_DecodingProc = SetWordValue(0,0xA0000050,(GetInt()?0x04:0)|(GetWordValue(0,0xA0000050)&~0x04));
Group_10_Item_4_Name = USBFILTEN
Group_10_Item_4_Comment = "Bit 3 = USBFILT EN: Enable USB Standby Filter. Read/Write.\nThe USB Transceiver features a low-pass filter to improve noise immunity while the bus is in STANDBY mode.\n•When this bit is cleared (Reset value), the filter is disabled.\n•When this bit is set, the filter is enabled (subject to STANDBY condition of USB bus)."
Group_10_Item_4_Type = 1, disabled, enabled
Group_10_Item_4_CodingProc = SetInt((GetWordValue(0,0xA0000050)&0x08)?1:0);
Group_10_Item_4_DecodingProc = SetWordValue(0,0xA0000050,(GetInt()?0x08:0)|(GetWordValue(0,0xA0000050)&~0x08));
Group_10_Item_5_Name = LPOWDBGEN
Group_10_Item_5_Comment = "Bit 4 = LPOWDBGEN: Enable Reserved Debug features for STOP mode. Read/Write.\n•When the device is in STOP mode, all internal clocks are frozen, including MCLK to ARM7, which cannot answer to a Debug Request from the Emulator (DBGRQS pin, or command through JTAG interface).\n•When this bit is setasserting the Debug Request input forces immediate exit from STOP mode, enabling internal clocks, so allowing the emulator to take control of the system.\n•When this bit is cleared (Reset value), this feature is disabled, and a Debug Request while in STOP mode is ignored."
Group_10_Item_5_Type = 1, disabled, enabled
Group_10_Item_5_CodingProc = SetInt((GetWordValue(0,0xA0000050)&0x10)?1:0);
Group_10_Item_5_DecodingProc = SetWordValue(0,0xA0000050,(GetInt()?0x10:0)|(GetWordValue(0,0xA0000050)&~0x10));
Group_10_Item_6_Name = ADCEN
Group_10_Item_6_Comment = "Bit 5 = ADC EN: Enable ADC. Read/Write.\n•When this bit is cleared (Reset value), the Analog part of the Analog-to-digital converter is disabled (Power Down), minimizing static power consumption.\n•When this bit is set, the Analog part of the ADC is enabled, and can be used by the application. After setting this bit, a start-up time of 1 ms (TBC) is required before the first valid conversion. This bit should be reset by software to switch off the ADC in any low-power mode (WFI, STOP)."
Group_10_Item_6_Type = 1, disabled, enabled
Group_10_Item_6_CodingProc = SetInt((GetWordValue(0,0xA0000050)&0x20)?1:0);
Group_10_Item_6_DecodingProc = SetWordValue(0,0xA0000050,(GetInt()?0x20:0)|(GetWordValue(0,0xA0000050)&~0x20));
Group_10_Item_7_Name = CAN
Group_10_Item_7_Comment = "Bit 6 = CAN: CAN Active. HW Configuration. Read only.\n•When this bit is cleared, the CAN interface controller is disabled.\n•When this bit is set, the CAN interface controller is enabled."
Group_10_Item_7_Type = 1, disabled, enabled
Group_10_Item_7_CodingProc = SetInt((GetWordValue(0,0xA0000050)&0x40)?1:0);
Group_10_Item_8_Name = HDLC
Group_10_Item_8_Comment = "Bit 7 = HDLC: HDLC Active. HW Configuration. Read only.\n•When this bit is cleared, the HDLC interface controller is disabled.\n•When this bit is set, the HDLC interface controller is enabled."
Group_10_Item_8_Type = 1, disabled, enabled
Group_10_Item_8_CodingProc = SetInt((GetWordValue(0,0xA0000050)&0x80)?1:0);
Group_10_Item_9_Name = PKG64
Group_10_Item_9_Comment = "Bit 9 = PKG64: Die is hosted in 64-pin package. HW Configuration. Read only.\n•When this bit is cleared, the chip is mounted on a 144-pin package.\n•When this bit is set, the chip is mounted on a 64-pin package, and all non-bonded pins are forced to idle mode (input and output disabled), irrespective of the values in IOPort control registers."
Group_10_Item_9_Type = 1, 144-pin, 64-pin
Group_10_Item_9_CodingProc = SetInt((GetWordValue(0,0xA0000050)&0x200)?1:0);
Group_11_Name = Power Control (PWRCR)
Group_11_ItemsNumber = 12
Group_11_Item_1_Name = PRCCU_PWRCR
Group_11_Item_1_Comment = "Power Control Register (PCU_PWRCR).\n•Address offset: 54h.\n•Reset value: 0000h."
Group_11_Item_1_Type = 0
Group_11_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xA0000054).toString(16));
Group_11_Item_1_DecodingProc = SetWordValue(0,0xA0000054,parseInt(GetString()));
Group_11_Item_2_Name = VRBYP
Group_11_Item_2_Comment = "Bit 3 = VRBYP: Main Regulator Bypass.\nThis bit may be written only when bit 15, WREN, is set.\n•When VRBYP = ‘0’ (default), the Main Voltage Regulator is active, supplying the device.\n•When VRBYP = ‘1’, the Main Voltage Regulator is switched off (bypassed), and the kernel of the device is supplied by an external source at 1.8V through the V18 pin.\n•NOTE: if this bit is set without a proper external supply connection, unexpected operation may result, including permanent damage to the device."
Group_11_Item_2_Type = 1, active, switched off
Group_11_Item_2_CodingProc = SetInt((GetWordValue(0,0xA0000054)&0x08)?1:0);
Group_11_Item_2_DecodingProc = SetWordValue(0,0xA0000054,(GetInt()?0x08:0)|(GetWordValue(0,0xA0000054)&~0x08));
Group_11_Item_3_Name = LPVRWFI
Group_11_Item_3_Comment = "Bit 4 = LPVRWFI: Low Power Regulator in Wait-For-Interrupt mode.\nThis bit may be written only when bit 15, WREN, is set.\n•When LPVRWFI = ‘0’ (default), the main Voltage Regulator is always active, except in Powerdown mode.\n•When LPVRWFI = ‘1’, the main Voltage Regulator is switched off (bypassed) in Low-Power modes STOP, LP_WFI, in which the Backup (Low-Power) Voltage Regulator supplies the device."
Group_11_Item_3_Type = 1, active, switched off
Group_11_Item_3_CodingProc = SetInt((GetWordValue(0,0xA0000054)&0x10)?1:0);
Group_11_Item_3_DecodingProc = SetWordValue(0,0xA0000054,(GetInt()?0x10:0)|(GetWordValue(0,0xA0000054)&~0x10));
Group_11_Item_4_Name = LPVRBYP
Group_11_Item_4_Comment = "Bit 5 = LPVRBYP: Low Power Regulator Bypass.\nThis bit may be written only when bit 15, WREN, is set.\n•When LPVRBYP = ‘0’ (default), the Backup (Low-Power) Voltage Regulator is active, ready to take over in low-power modes.\n•When LPVRBYP = ‘1’, the Backup (Low-Power) Voltage Regulator is switched off (bypassed), and the Backup logic is supplied by an external source at 1.8V through the V18bkp pin."
Group_11_Item_4_Type = 1, active, switched off
Group_11_Item_4_CodingProc = SetInt((GetWordValue(0,0xA0000054)&0x20)?1:0);
Group_11_Item_4_DecodingProc = SetWordValue(0,0xA0000054,(GetInt()?0x20:0)|(GetWordValue(0,0xA0000054)&~0x20));
Group_11_Item_5_Name = PWRDWN
Group_11_Item_5_Comment = "Bit 6 = PWRDWN: Activate Powerdown Mode.\nThis bit may be written only when bit 15, WREN, is set.\n•When PWRDWN = ‘0’ (default), the chip is working in normal mode.\n•When PWRDWN = ‘1’, the chip enters powerdown mode.\nThe Main Voltage Regulator is switched off, and the power supply to the kernel of the device is disconnected. The Backup (Low-Power) Voltage Regulator is still active, supplying the Backup section: Real Time Clock and wake-up logic."
Group_11_Item_5_Type = 1, normal mode, powerdown mode
Group_11_Item_5_CodingProc = SetInt((GetWordValue(0,0xA0000054)&0x40)?1:0);
Group_11_Item_5_DecodingProc = SetWordValue(0,0xA0000054,(GetInt()?0x40:0)|(GetWordValue(0,0xA0000054)&~0x40));
Group_11_Item_6_Name = OSC BYP
Group_11_Item_6_Comment = "Bit 7 = OSC BYP: 32-KHz Oscillator Bypass Enable.\nThis bit may be written only when bit 15, WREN, is set.\n•When this bit is cleared (Default Value), the 32-KHz oscillator is enabled, providing a clock source for the Real Time Clock, and a Backup clock source to the whole system.\n•When this bit is set, the 32-KHz oscillator is stopped and bypassed, featuring zero power consumption and allowing an external reference clock to feed the Real Time Clock, or a Backup clock source to the whole system."
Group_11_Item_6_Type = 1, enabled, stopped
Group_11_Item_6_CodingProc = SetInt((GetWordValue(0,0xA0000054)&0x80)?1:0);
Group_11_Item_6_DecodingProc = SetWordValue(0,0xA0000054,(GetInt()?0x80:0)|(GetWordValue(0,0xA0000054)&~0x80));
Group_11_Item_7_Name = LVD DIS
Group_11_Item_7_Comment = "Bit 8 = LVD DIS: Low-Voltage Detector Disable.\nThis bit may be written only when bit 15, WREN, is set. Sticky bit: once set, it cannot be reset by software anymore - only a Reset will clear it.\n•When this bit is cleared (Default Value), the Low-Voltage Detector is enabled, monitoring the V18 supply, and generating a Reset to the device whenever V18 is less than the threshold value (see electrical specs)."
Group_11_Item_7_Type = 1, enabled, disabled
Group_11_Item_7_CodingProc = SetInt((GetWordValue(0,0xA0000054)&0x100)?1:0);
Group_11_Item_7_DecodingProc = SetWordValue(0,0xA0000054,(GetInt()?0x100:0)|(GetWordValue(0,0xA0000054)&~0x100));
Group_11_Item_8_Name = FLASH LP
Group_11_Item_8_Comment = "Bit 9 = FLASH LP: Flash low-power (low-speed) mode select.\nThis bit may be written only when bit 15, WREN, is set with the same write instruction.\n•When this bit is cleared (Default Value), the Flash works in FAST mode, using BURST mode for sequential accesses, to allow zero wait state operation up to the maximum device frequency, and generating a WAIT cycle on non-sequential memory accesses. \n•When this bit is set, the Flash enters Low-Power mode, and BURST is disabled. WAIT states are never generated. LP mode may be used for operation frequency (MCLK) up to 33 MHz."
Group_11_Item_8_Type = 1, FAST mode, Low Power mode
Group_11_Item_8_CodingProc = SetInt((GetWordValue(0,0xA0000054)&0x200)?1:0);
Group_11_Item_8_DecodingProc = SetWordValue(0,0xA0000054,(GetInt()?0x200:0)|(GetWordValue(0,0xA0000054)&~0x200));
Group_11_Item_9_Name = VROK
Group_11_Item_9_Comment = "Bit 12 = VROK: Main Regulator OK. Read Only.\n•When VROK = ‘0’, the Main Voltage Regulator is not stable, and the supply to the device is not guaranteed to be in specification range.\n•When VROK = ‘1’, the Main Voltage Regulator is stable, in the specification range Note: The software should check this bit before and after any change of configuration which impacts clock and power status of the device."
Group_11_Item_9_Type = 1, not stable, stable
Group_11_Item_9_CodingProc = SetInt((GetWordValue(0,0xA0000054)&0x1000)?1:0);
Group_11_Item_10_Name = WKUP-ALRM
Group_11_Item_10_Comment = "Bit 13 = WKUP-ALRM: WakeUp or Alarm active. Read only.\nThis bit is set to logical one by the HW when external WAKEUP pin, or when an internal wake-up source is active. In this case a powerdown command has no effect.\n•When WKUP-ALRM = ‘0’ (default), it is possible to start the power down sequence."
Group_11_Item_10_Type = 1, no wake up, Alarm Active
Group_11_Item_10_CodingProc = SetInt((GetWordValue(0,0xA0000054)&0x2000)?1:0);
Group_11_Item_11_Name = BUSY
Group_11_Item_11_Comment = "Bit 14 = BUSY: Backup logic Busy - programming ongoing. Read only.\nThe Backup Logic is asynchronous, and this bits flags the handshake status between the register and the related logic.\n•When BUSY = ‘0’ (default), it is possible to program the Backup Logic by writing into the register.\n•When BUSY = ‘1’, a previous write operation is not yet completed, and it is forbidden to write to the register."
Group_11_Item_11_Type = 1, not busy, programming ongoing
Group_11_Item_11_CodingProc = SetInt((GetWordValue(0,0xA0000054)&0x4000)?1:0);
Group_11_Item_12_Name = WREN
Group_11_Item_12_Comment = "Bit 15 = WREN: Register Write Enable.\nThis bit acts as a security mechanism to avoid spurious writes into this register.\n•When WREN = ‘0’ (default), all bits in the register are write protected, and cannot be changed. This bit can only be set by software, not cleared.\n•When WREN = ‘1’, bits listed as RW become writable. A timeout is activated, allowing write operations to the register for 64 MCLK cycles. After this interval, the bit is reset by HW. This bits does not affect read operations."
Group_11_Item_12_Type = 1, read only, read-write
Group_11_Item_12_CodingProc = SetInt((GetWordValue(0,0xA0000054)&0x8000)?1:0);
Group_11_Item_12_DecodingProc = SetWordValue(0,0xA0000054,(GetInt()?0x8000:0)|(GetWordValue(0,0xA0000054)&~0x8000));
[RTC]
SegmentsNumber = 1
Segment_1 = RTC_SEG, 32, 0xE000D000, 0x28
SymbsNumber = 10
Symb_1 = RTC_CRH, 0, 0xE000D000
Symb_2 = RTC_CRL, 0, 0xE000D004
Symb_3 = RTC_PRLH, 0, 0xE000D008
Symb_4 = RTC_PRLL, 0, 0xE000D00C
Symb_5 = RTC_DIVH, 0, 0xE000D010
Symb_6 = RTC_DIVL, 0, 0xE000D014
Symb_7 = RTC_CNTH, 0, 0xE000D018
Symb_8 = RTC_CNTL, 0, 0xE000D01C
Symb_9 = RTC_ALRH, 0, 0xE000D020
Symb_10 = RTC_ALRL, 0, 0xE000D024
ResetCode = {SetWordValue(0,0xE000D000,0x00);SetWordValue(0,0xE000D004,0x20);SetWordValue(0,0xE000D008,0x0);SetWordValue(0,0xE000D00C,0x8000);SetWordValue(0,0xE000D010,0x0);SetWordValue(0,0xE000D014,0x8000);SetWordValue(0,0xE000D018,0x0);SetWordValue(0,0xE000D01C,0x0);SetWordValue(0,0xE000D020,0xffff);SetWordValue(0,0xE000D024,0xffff);}
GroupsNumber = 6
Group_1_Name = Ctrl Reg HIGH (CRH)
Group_1_Comment = "These bits are used to mask interrupt requests. Note that at reset all interrupts are disabled, so it is possible to write to the RTC registers to ensure that no interrupt requests are pending after initialization. It is not possible to write RTC_CRH register when the peripheral is completing a previous write operation (flagged by RTOFF=0)."
Group_1_ItemsNumber = 5
Group_1_Item_1_Name = RTC_CRH
Group_1_Item_1_Comment = "RTC Control Register High (RTC_CRH).\n•Address Offset: 00h.\n•Reset value: 0000h."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000D000).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xE000D000,parseInt(GetString()));
Group_1_Item_2_Name = SEN
Group_1_Item_2_Comment = "Bit 0 = SEN: Second interrupt Enable.\n•0: Second interrupt is masked.\n•1: Second interrupt is enabled."
Group_1_Item_2_Type = 1, masked, enabled
Group_1_Item_2_CodingProc = SetInt((GetWordValue(0,0xE000D000)&1)?1:0);
Group_1_Item_2_DecodingProc = SetWordValue(0,0xE000D000,(GetInt()?1:0)|(GetWordValue(0,0xE000D000)&~1));
Group_1_Item_3_Name = AEN
Group_1_Item_3_Comment = "Bit 1 = AEN: Alarm interrupt Enable.\n•0: Alarm interrupt is masked.\n•1: Alarm interrupt is enabled."
Group_1_Item_3_Type = 1, masked, enabled
Group_1_Item_3_CodingProc = SetInt((GetWordValue(0,0xE000D000)&2)?1:0);
Group_1_Item_3_DecodingProc = SetWordValue(0,0xE000D000,(GetInt()?2:0)|(GetWordValue(0,0xE000D000)&~2));
Group_1_Item_4_Name = OWEN
Group_1_Item_4_Comment = "Bit 2 = OWEN: Overflow interrupt Enable.\n•0: Overflow interrupt is masked.\n•1: Overflow interrupt is enabled."
Group_1_Item_4_Type = 1, masked, enabled
Group_1_Item_4_CodingProc = SetInt((GetWordValue(0,0xE000D000)&4)?1:0);
Group_1_Item_4_DecodingProc = SetWordValue(0,0xE000D000,(GetInt()?4:0)|(GetWordValue(0,0xE000D000)&~4));
Group_1_Item_5_Name = GEN
Group_1_Item_5_Comment = "Bit 3 = GEN: Global interrupt Enable.\n•0: Global interrupt is masked.\n•1: Global interrupt is enabled."
Group_1_Item_5_Type = 1, masked, enabled
Group_1_Item_5_CodingProc = SetInt((GetWordValue(0,0xE000D000)&8)?1:0);
Group_1_Item_5_DecodingProc = SetWordValue(0,0xE000D000,(GetInt()?8:0)|(GetWordValue(0,0xE000D000)&~8));
Group_2_Name = Ctrl Reg LOW (CRL)
Group_2_Comment = "The functions of the RTC are controlled by this control register. It is not possible to write RTC_CR register when the peripheral is completing a previous write operation (flagged by RTOFF=0)."
Group_2_ItemsNumber = 7
Group_2_Item_1_Name = RTC_CRL
Group_2_Item_1_Comment = "RTC Control Register Low (RTC_CRL).\n•Address Offset: 04h.\n•Reset value: 0020h."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000D004).toString(16));
Group_2_Item_1_DecodingProc = SetWordValue(0,0xE000D004,parseInt(GetString()));
Group_2_Item_2_Name = SIR
Group_2_Item_2_Comment = "Bit 0 = SIR: Second Interrupt Request.\nThis bit contains the status of second interrupt request signal (RTC_SecIt) generated by the overflow of the 20-bit programmable prescaler which increments the RTC counter. Hence this Interrupt provides a periodic signal with a period corresponding to the resolution programmed for the RTC counter (usually one second). When this bit is at ‘1’, the corresponding interrupt will be generated only if SEN bit is set to ‘1’. SIR bit can be set at ‘1’ only by hardware and can be cleared only by software, while writing ‘1’ will left it unchanged.\n•0: ‘Second’ interrupt condition not met.\n•1: ‘Second’ interrupt request pending."
Group_2_Item_2_Type = 1, condition not met, request pending
Group_2_Item_2_CodingProc = SetInt((GetWordValue(0,0xE000D004)&1)?1:0);
Group_2_Item_2_DecodingProc = SetWordValue(0,0xE000D004,(GetInt()?1:0)|(GetWordValue(0,0xE000D004)&~1));
Group_2_Item_3_Name = AIR
Group_2_Item_3_Comment = "Bit 1 = AIR: Alarm Interrupt Request.\nThis bit contains the status of periodic interrupt request signal (RTC_AlarmIt) generated by the 32 bit programmable counter when the threshold set in RTC_ALR register is reached. When this bit is at ‘1’, the corresponding interrupt will be generated only if AEN bit is set to ‘1’. AIR bit can be set at ‘1’ only by hardware and can be cleared only by software, while writing ‘1’ will left it unchanged.\n•0: Alarm interrupt condition not met.\n•1: Alarm interrupt request pending."
Group_2_Item_3_Type = 1, condition not met, request pending
Group_2_Item_3_CodingProc = SetInt((GetWordValue(0,0xE000D004)&2)?1:0);
Group_2_Item_3_DecodingProc = SetWordValue(0,0xE000D004,(GetInt()?2:0)|(GetWordValue(0,0xE000D004)&~2));
Group_2_Item_4_Name = OWIR
Group_2_Item_4_Comment = "Bit 2 = OWIR: Overflow Interrupt Request.\nThis bit stores the status of periodic interrupt request signal (RTC_OwIT) generated by the overflow of the 32-bit programmable counter. This interrupt may be used to wake-up the system from a long lasting Standby condition, if the system time has to be kept up-to-date. When this bit is at ‘1’, the corresponding interrupt will be generated only if OWEN bit is set to ‘1’. OWEN bit can be set at ‘1’ only by hardware and can be cleared only by software, while writing ‘1’ will left it unchanged.\n•0: Overflow interrupt condition not met.\n•1: Overflow interrupt request pending."
Group_2_Item_4_Type = 1, condition not met, request pending
Group_2_Item_4_CodingProc = SetInt((GetWordValue(0,0xE000D004)&4)?1:0);
Group_2_Item_4_DecodingProc = SetWordValue(0,0xE000D004,(GetInt()?4:0)|(GetWordValue(0,0xE000D004)&~4));
Group_2_Item_5_Name = GIR
Group_2_Item_5_Comment = "Bit 3 = GIR: Global Interrupt Request.\nThis bit contains the status of global interrupt request signal, which is goes high when at least one of the other interrupt lines is active. When this bit is set, the corresponding interrupt will be generated only if GEN bit is set. The GIR bit can be set only by hardware and can be cleared only by software, while writing ‘1’ will left it unchanged.\n•0: GloInt interrupt condition not met.\n•1: GloInt interrupt request pending."
Group_2_Item_5_Type = 1, condition not met, request pending
Group_2_Item_5_CodingProc = SetInt((GetWordValue(0,0xE000D004)&8)?1:0);
Group_2_Item_5_DecodingProc = SetWordValue(0,0xE000D004,(GetInt()?8:0)|(GetWordValue(0,0xE000D004)&~8));
Group_2_Item_6_Name = CNF
Group_2_Item_6_Comment = "Bit 4 = CNF: Configuration Flag.\nThis bit must be set by software to enter configuration mode so as to allow new values to be written in the RTC_CNT, RTC_ALR or RTC_PRL registers. The write operation is only executed when , the CNF bit is reset by software after has been set.\n•0: Exit configuration mode (start update of RTC registers).\n•1: Enter configuration mode."
Group_2_Item_6_Type = 1, Exit configuration mode, Enter configuration mode
Group_2_Item_6_CodingProc = SetInt((GetWordValue(0,0xE000D004)&0x80)?1:0);
Group_2_Item_6_DecodingProc = SetWordValue(0,0xE000D004,(GetInt()?0x80:0)|(GetWordValue(0,0xE000D004)&~0x80));
Group_2_Item_7_Name = RTOFF- Last write
Group_2_Item_7_Comment = "Bit 5 = RTOFF: RTC operation OFF.\nWith this bit the RTC reports the status of the last write operation performed on its registers, indicating if it has been completed or not. If its value is ‘0’ then it is not possible to write to any of the RTC registers. This bit is read only.\n•0: Last write operation on RTC registers is still ongoing.\n•1: Last write operation on RTC registers terminated."
Group_2_Item_7_Type = 1, ongoing, terminated
Group_2_Item_7_CodingProc = SetInt((GetWordValue(0,0xE000D004)&0x200)?1:0);
Group_3_Name = Prescaler Load (PRL)
Group_3_Comment = "The Prescaler Load registers keep the period counting value of the RTC prescaler. They are write protected by the RTOFF bit in the RTC_CR register, write operation is allowed if RTOFF value is 1."
Group_3_ItemsNumber = 2
Group_3_Item_1_Name = RTC_PRLH
Group_3_Item_1_Comment = "RTC Prescaler Load Register High (RTC_PRLH).\nWrite only.\n•Address Offset: 08h\n•Reset value: 0000h.\n•Bit 3:0 = PRSL[19:16]: RTC Prescaler reLoad value high.\n•Bit 15:4 = Reserved, always read as 0."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000D008).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xE000D008,parseInt(GetString()));
Group_3_Item_2_Name = RTC_PRLL
Group_3_Item_2_Comment = "RTC Prescaler Load Register Low (RTC_PRLL).\nWrite only.\n•Address Offset: 0Ch.\n•Reset value: 8000h.\n•Bit 15:0 = PRSL[15:0]: RTC Prescaler Reload value low.\n•Note: The reset value sets the TR_CLK signal period to 1 sec for a 32-kHz oscillator."
Group_3_Item_2_Type = 0
Group_3_Item_2_CodingProc = SetString("0x"+GetWordValue(0,0xE000D00C).toString(16));
Group_3_Item_2_DecodingProc = SetWordValue(0,0xE000D00C,parseInt(GetString()));
Group_4_Name = Prescaler Divider (DIV)
Group_4_Comment = "Every period of TR_CLK the counter inside RTC prescaler is reloaded with the value stored in the RTC_PRL register. To get an accurate time measurement it is possible to read the current value of the prescaler counter, stored into the RTC_DIV register, without stopping it. This register is read only and it is reloaded by hardware after any change in RTC_PRL or RTC_CNT registers."
Group_4_ItemsNumber = 2
Group_4_Item_1_Name = RTC_DIVH
Group_4_Item_1_Comment = "RTC Prescaler Divider Register High (RTC_DIVH).\n•Address Offset: 10h.\n•Reset value: 0000h.\n•Bit 3:0 = RTCDIV[19:16]: RTC Clock Divider High.\n•Bit 15:4 = Reserved, always read as 0."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0xE000D010).toString(16));
Group_4_Item_2_Name = RTC_DIVL
Group_4_Item_2_Comment = "RTC Prescaler Divider Register Low (RTC_DIVL).\n•Address Offset: 14h.\n•Reset value: 8000h.\n•Bit 15:0 = PRSL[15:0]: RTC Prescaler Reload value low\n•Note: The reset value sets the TR_CLK signal period to 1 sec for a 32-kHz oscillator."
Group_4_Item_2_Type = 0
Group_4_Item_2_CodingProc = SetString("0x"+GetWordValue(0,0xE000D014).toString(16));
Group_5_Name = Counter Register (CNT)
Group_5_Comment = "The RTC core has one 32-bit programmable counter, accessed through 2 16-bit registers; the count rate is based on the TR_Clock time reference, generated by the prescaler. RTC_CNT registers keep the counting value of this counter. They are write protected by bit RTOFF in the RTC_CR register, write operation is allowed if RTOFF value is ‘1’. A write operation on the upper (RTC_CNTH) or lower (RTC_CNTL) registers directly loads the corresponding programmable counter and reloads the RTC Prescaler. When reading, the current value in the counter (system date) is returned. The counters keep on running while the external clock oscillator is working even if the main system is powered down (Standby mode)."
Group_5_ItemsNumber = 2
Group_5_Item_1_Name = RTC_CNTH
Group_5_Item_1_Comment = "RTC Counter Register High (RTC_CNTH).\n•Address Offset: 18h.\n•Reset value: 0000h.\n•Bit 15:0 = RTC_CNT[31:16]: RTC Counter High\nReading RTC_CNTH register, the current value of the high part of RTC Counter register is returned. To write this register it is required to enter configuration mode using the RTOFF bit in the RTC_CR register."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000D018).toString(16));
Group_5_Item_1_DecodingProc = SetWordValue(0,0xE000D018,parseInt(GetString()));
Group_5_Item_2_Name = RTC_CNTL
Group_5_Item_2_Comment = "RTC Counter Register Low (RTC_CNTL).\n•Address Offset: 1Ch.\n•Reset value: 0000h.\n•Bit 15:0 = RTC_CNT[15:0]: RTC Counter Low\nReading RTC_CNTL register, the current value of the lower part of RTC Counter register is returned. To write this register it is required to enter configuration mode using the RTOFF bit in the RTC_CR register."
Group_5_Item_2_Type = 0
Group_5_Item_2_CodingProc = SetString("0x"+GetWordValue(0,0xE000D01C).toString(16));
Group_5_Item_2_DecodingProc = SetWordValue(0,0xE000D01C,parseInt(GetString()));
Group_6_Name = Alarm Register (ALR)
Group_6_Comment = "When the programmable counter reaches the 32-bit value stored in the RTC_ALR register, an alarm is triggered and the RTC_alarmIT interrupt request is generated. This register is write protected by the RTOFF bit in the RTC_CR register, write operation is allowed if the RTOFF value is ‘1’."
Group_6_ItemsNumber = 2
Group_6_Item_1_Name = RTC_ALRH
Group_6_Item_1_Comment = "RTC Alarm Register High (RTC_ALRH).\nWrite only.\n•Address Offset: 20h.\n•Reset value: FFFFh.\n•Bit 15:0 = RTC_ALR[31:16]: RTC Alarm High\nThe high part of alarm time is written by software in this register. To write this register it is required to enter configuration mode using the RTOFF bit in the RTC_CR register."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000D020).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xE000D020,parseInt(GetString()));
Group_6_Item_2_Name = RTC_ALRL
Group_6_Item_2_Comment = "RTC Alarm Register Low (RTC_ALRL).\nWrite only.\n•Address Offset: 24h.\n•Reset value: FFFFh.\n•Bit 15:0 = RTC_ALR[15:0]: RTC Alarm Low\nThe low part of alarm time is written by software in this register. To write this register it is required to enter configuration mode using the RTOFF bit in the RTC_CR register."
Group_6_Item_2_Type = 0
Group_6_Item_2_CodingProc = SetString("0x"+GetWordValue(0,0xE000D024).toString(16));
Group_6_Item_2_DecodingProc = SetWordValue(0,0xE000D024,parseInt(GetString()));
[Watchdog]
SegmentsNumber = 1
Segment_1 = WDG_SEG, 32, 0xE000E000, 0x1C
SymbsNumber = 7
Symb_1 = WDG_CR, 0, 0xE000E000
Symb_2 = WDG_PR, 0, 0xE000E004
Symb_3 = WDG_VR, 0, 0xE000E008
Symb_4 = WDG_CNT,0, 0xE000E00C
Symb_5 = WDG_SR, 0, 0xE000E010
Symb_6 = WDG_MR, 0, 0xE000E014
Symb_7 = WDG_KR, 0, 0xE000E018
ResetCode = {SetWordValue(0,0xE000E000,0x00);SetWordValue(0,0xE000E004,0xFF);SetWordValue(0,0xE000E008,0xFFFF);SetWordValue(0,0xE000E00C,0xFFFF);SetWordValue(0,0xE000E010,0x0);SetWordValue(0,0xE000E014,0x0);SetWordValue(0,0xE000E018,0x0);}
GroupsNumber = 7
Group_1_Name = Ctrl Reg (CR)
Group_1_Comment = "Control Register.\n•Address Offset: 00h.\n•Reset value: 0000h."
Group_1_ItemsNumber = 3
Group_1_Item_1_Name = WDG_CR
Group_1_Item_1_Comment = "WDG Control Register(WDG_CR).\n•Bit 15:2 = Reserved, must be kept cleared."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000E000).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xE000E000,parseInt(GetString()));
Group_1_Item_2_Name = WE
Group_1_Item_2_Comment = "Bit 0 = WE: Watchdog Enable bit.\n•1: Watchdog Mode is enabled.\n•0: Timer Mode is enabled.This bit can’t be reset by software."
Group_1_Item_2_Type = 1, Timer mode, Watchdog mode
Group_1_Item_2_CodingProc = SetInt((GetWordValue(0,0xE000E000)&1)?1:0);
Group_1_Item_2_DecodingProc = SetWordValue(0,0xE000E000,(GetInt()?1:0)|(GetWordValue(0,0xE000E000)&~1));
Group_1_Item_3_Name = SC
Group_1_Item_3_Comment = "Bit 1 = SC: Start Counting bit.\n•1: The counter loads the Timer pre-load value and starts counting.\n•0: The counter is stopped.These functions are permitted only in Timer Mode (WE bit = 0)."
Group_1_Item_3_Type = 1, stopped, counting
Group_1_Item_3_CodingProc = SetInt((GetWordValue(0,0xE000E000)&2)?1:0);
Group_1_Item_3_DecodingProc = SetWordValue(0,0xE000E000,(GetInt()?2:0)|(GetWordValue(0,0xE000E000)&~2));
Group_2_Name = Prescaler Register (PR)
Group_2_Comment = "Prescaler Register.\n•Address Offset: 04h.\n•Reset value: 00FFh."
Group_2_ItemsNumber = 1
Group_2_Item_1_Name = WDG_PR
Group_2_Item_1_Comment = "WDG Prescaler Register (WDG_PR).\n•Bit 7:0 = PR[7:0]: Prescaler value.\nThe clock to Timer Counter is divided by PR[7:0]+1.This value takes effect when Watchdog mode is enabled (WE bit is put to ‘1’) or the re-load sequence occurs or the Counter starts (SC) bit is put to ‘1’ in Timer mode.\n•Bit 15:8 = Reserved."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000E004).toString(16));
Group_2_Item_1_DecodingProc = SetWordValue(0,0xE000E004,parseInt(GetString()));
Group_3_Name = Preload Value (VR)
Group_3_Comment = "WDG Preload Value Register (WDG_VR).\n•Address Offset: 08h.\n•Reset value: FFFFh."
Group_3_ItemsNumber = 1
Group_3_Item_1_Name = WDG_TVR
Group_3_Item_1_Comment= "Bit 15:0 = TV[15:0]: Timer Pre-load Value.\nThis value is loaded in the Timer Counter when it starts counting or a re-load sequence occurs or an End of Count is reached. The time (ìs) need to reach the end of count is given by:\n(PR[7:0]+1)*(TV[15:0]+1)*tPCLK2/1000 (ìs)\nwhere tPCLK2 is the Clock period measured in ns."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000E008).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xE000E008,parseInt(GetString()));
Group_4_Name = Counter Register (CNT)
Group_4_Comment = "Counter Register\n•Address Offset: 0Ch.\n•Reset value: FFFFh."
Group_4_ItemsNumber = 1
Group_4_Item_1_Name = WDG_CNT
Group_4_Item_1_Comment= "WDG Counter Register (WDG_CNT).\n•Bit 15:0 = CNT[15:0]: Timer Counter Value.\nThe current counting value of the 16-bit Counter is available reading this register."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0xE000E00C).toString(16));
Group_5_Name = Status Register (SR)
Group_5_Comment ="Status Register.\nIn Watchdog Mode (WE = 1) this bit has no effect.This bit can be set only by hardware and must be reset by software."
Group_5_ItemsNumber = 2
Group_5_Item_1_Name = WDG_SR
Group_5_Item_1_comment = "WDG Status Register\n•Address Offset: 10h.\n•Reset value: 0000h.\n•Bit 15:1 = Reserved."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000E010).toString(16));
Group_5_Item_1_DecodingProc = SetWordValue(0,0xE000E010,parseInt(GetString()));
Group_5_Item_2_Name = EC
Group_5_Item_2_Comment ="Bit 0 = EC: End of Count pending bit.\n•1: the End of Count has occurred.\n•0: no End of Count has occurred."
Group_5_Item_2_Type = 1, End of Count, no end of count
Group_5_Item_2_CodingProc = SetInt((GetWordValue(0,0xE000E010)&1)?1:0);
Group_5_Item_2_DecodingProc = SetWordValue(0,0xE000E010,(GetInt()?1:0)|(GetWordValue(0,0xE000E010)&~1));
Group_6_Name = Mask Register (MR)
Group_6_Comment = "Mask Register.\n•Address Offset: 14h.\n•Reset value: 0000h."
Group_6_ItemsNumber = 2
Group_6_Item_1_Name = WDG_MR
Group_6_Item_1_Comment = "WDG Mask Register(WDG_MR).\n•Bit15:1 = Reserved."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000E014).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xE000E014,parseInt(GetString()));
Group_6_Item_2_Name = ECM
Group_6_Item_2_Comment = "Bit 0 = ECM: End of Count Mask bit.\n•1: End of Count interrupt request is enabled.\n•0: End of Count interrupt request is disabled."
Group_6_Item_2_Type = 1, disabled, enabled
Group_6_Item_2_CodingProc = SetInt((GetWordValue(0,0xE000E014)&1)?1:0);
Group_6_Item_2_DecodingProc = SetWordValue(0,0xE000E014,(GetInt()?1:0)|(GetWordValue(0,0xE000E014)&~1));
Group_7_Name = Key Register (KR)
Group_7_Comment = "WDG Key Register (WDG_KR).\n•Address Offset: 18h.\n•Reset value: 0000h."
Group_7_ItemsNumber = 1
Group_7_Item_1_Name = WDG_KR
Group_7_Item_1_Comment = "Bit 15:0 = K[15:0]: Key Value.\n•When Watchdog Mode is enabled, writing in this register two consecutive values (refer to device specification) the Counter is initialized to TV[15:0] value and the Prescaler value in WTDPR register take effect. Any number of instructions can be executed between the two writes.\n•If Watchdog Mode is disabled (WE = 0) a writing in this register has no effect.The reading value of this register is 0000h."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000E020).toString(16));
Group_7_Item_1_DecodingProc = SetWordValue(0,0xE000E020,parseInt(GetString()));
[Timer0]
SegmentsNumber = 1
Segment_1 = TIM0_SEG, 32, 0xE0009000, 0x20
SymbsNumber = 8
Symb_1 = TIM0_ICAR, 0, 0xE0009000 +0x00
Symb_2 = TIM0_ICBR, 0, 0xE0009000 +0x04
Symb_3 = TIM0_OCAR, 0, 0xE0009000 +0x08
Symb_4 = TIM0_OCBR, 0, 0xE0009000 +0x0C
Symb_5 = TIM0_CNTR, 0, 0xE0009000 +0x10
Symb_6 = TIM0_CR1, 0, 0xE0009000 +0x14
Symb_7 = TIM0_CR2, 0, 0xE0009000 +0x18
Symb_8 = TIM0_SR, 0, 0xE0009000 +0x1C
ResetCode = {SetWordValue(0,0xE0009000 +0x00,0x00);SetWordValue(0,0xE0009000 +0x04,0x00);SetWordValue(0,0xE0009000 +0x08,0x8000);SetWordValue(0,0xE0009000 +0x0C,0x8000);SetWordValue(0,0xE0009000 +0x10,0xFFFC);SetWordValue(0,0xE0009000 +0x14,0x0);SetWordValue(0,0xE0009000 +0x18,0x0);SetWordValue(0,0xE0009000 +0x1C,0x0);}
GroupsNumber = 8
Group_1_Name = Input Capt A (ICAR)
Group_1_comment = "This is a 16-bit read only register that contains the counter value transferred by the Input Capture A event."
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = ICAR
Group_1_Item_1_comment = "Input Capture A Register (TIMn_ICAR).\n•Address Offset: 00h.\n•Reset value: xxxxh."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0009000 +0x00).toString(16));
Group_2_Name = Input Capt B (ICBR)
Group_2_Comment= "This is a 16-bit read only register that contains the counter value transferred by the Input Capture B event."
Group_2_ItemsNumber = 1
Group_2_Item_1_Name = TIM0_ICBR
Group_2_Item_1_Comment= "Input Capture B Register (TIMn_ICBR).\n•Address Offset: 04h.\n•Reset value: xxxxh."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0009000 +0x04).toString(16));
Group_3_Name = Output Comp A (OCAR)
Group_3_Comment = "This is a 16-bit register that contains the value to be compared to the CNTR register and signalled on OCMPA output."
Group_3_ItemsNumber = 1
Group_3_Item_1_Name = TIM0_OCAR
Group_3_Item_1_Comment = "Output Compare A Register (TIMn_OCAR).\n•Address Offset: 08h.\n•Reset value: 8000h."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0009000 +0x08).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xE0009000 +0x08,parseInt(GetString()));
Group_4_Name = Output Comp B (OCBR)
Group_4_Comment = "This is a 16-bit register that contains the value to be compared to the CNTR register and signalled on OCMPB output."
Group_4_ItemsNumber = 1
Group_4_Item_1_Name = TIM0_OCBR
Group_4_Item_1_Comment = "Output Compare B Register (TIMn_OCBR).\n•Address Offset: 0Ch.\n•Reset value: 8000h."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0xE0009000 +0x0C).toString(16));
Group_4_Item_1_DecodingProc = SetWordValue(0,0xE0009000 +0x0C,parseInt(GetString()));
Group_5_Name = Counter Reg (CNTR)
Group_5_Comment= "This is a 16-bit register that contains the counter value. By writing in this register the counter is reset to the FFFCh value."
Group_5_ItemsNumber = 1
Group_5_Item_1_Name = TIM0_CNTR
Group_5_Item_1_Comment= "Counter Register (TIMn_CNTR).\n•Address Offset: 10h.\n•Reset value: FFFCh."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0009000 +0x10).toString(16));
Group_6_Name = Ctrl 1 Reg (CR1)
Group_6_Comment = "Control Register 1 (TIMn_CR1).\n•Address Offset: 14h.\n•Reset value: 0000h."
Group_6_ItemsNumber = 16
Group_6_Item_1_Name = CR1
Group_6_Item_1_Comment = "Ctrl 1 Reg (CR1).\n•Bit 13:12 = Reserved. These bits must be always written to 0."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0009000 +0x14).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xE0009000 +0x14,parseInt(GetString()));
Group_6_Item_2_Name = ECKEN
Group_6_Item_2_comment = "Bit 0 = ECKEN: External Clock Enable.\n•0: Internal clock, divided by prescaler division factor, is used to feed timer clock.\n•1: External source is used for timer clock."
Group_6_Item_2_Type = 1, internal, external
Group_6_Item_2_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&1)?1:0);
Group_6_Item_2_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?1:0)|(GetWordValue(0,0xE0009000 +0x14)&~1));
Group_6_Item_3_Name = EXEDG
Group_6_Item_3_Comment = "Bit 1 = EXEDG: External Clock Edge.\nThis bit determines which type of level transition on the external clock pin (or internal signal)EXTCLK will trigger the counter.\n•0: A falling edge triggers the counter.\n•1: A rising edge triggers the counter."
Group_6_Item_3_Type = 1, falling, rising
Group_6_Item_3_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x02)?1:0);
Group_6_Item_3_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x02:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x02));
Group_6_Item_4_Name = IEDGA
Group_6_Item_4_Comment= "Bit 2 = IEDGA: Input Edge A.\nThis bit determines which type of level transition on the ICAPA pin will trigger the capture.\n•0: A falling edge triggers the capture.\n•1: A rising edge triggers the capture."
Group_6_Item_4_Type = 1, falling, rising
Group_6_Item_4_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x04)?1:0);
Group_6_Item_4_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x04:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x04));
Group_6_Item_5_Name = IEDGB
Group_6_Item_5_Comment= "Bit 3 = IEDGB: Input Edge B.\nThis bit determines which type of level transition on the ICAPB pin will trigger the capture.\n•0: A falling edge triggers the capture.\n•1: A rising edge triggers the capture."
Group_6_Item_5_Type = 1, falling, rising
Group_6_Item_5_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x8)?1:0);
Group_6_Item_5_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x8:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x8));
Group_6_Item_6_Name = PWM
Group_6_Item_6_Comment = "Bit 4 = PWM: Pulse Width Modulation.\n•0: PWM mode is not active.\n•1: PWM mode is active, the OCMPA pin outputs a programmable cyclic signal; the length of the pulse depends on the value of OCAR register; the period depends on the value of OCBR register."
Group_6_Item_6_Type = 1, disabled, active
Group_6_Item_6_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x10)?1:0);
Group_6_Item_6_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x10:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x10));
Group_6_Item_7_Name = OPM
Group_6_Item_7_Comment= "Bit 5 = OPM: One Pulse Mode.\n•0: One Pulse Mode is not active.\n•1: One Pulse Mode is active, the ICAPA pin can be used to trigger one pulse on the OCMPA pin; the active transition is given by the IEDGA bit. The length of the generated pulse depends on the contents of the OCAR register."
Group_6_Item_7_Type = 1, disabled, active
Group_6_Item_7_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x20)?1:0);
Group_6_Item_7_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x20:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x20));
Group_6_Item_8_Name = OCAE
Group_6_Item_8_Comment= "Bit 6= OCAE: Output Compare A Enable.\n•0: Output Compare A function is enabled, but the OCMPA pin is a general I/O.\n•1: Output Compare A function is enabled, the OCMPA pin is dedicated to the Output Compare A capability of the timer."
Group_6_Item_8_Type = 1, general IO, dedicated pin
Group_6_Item_8_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x40)?1:0);
Group_6_Item_8_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x40:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x40));
Group_6_Item_9_Name = OCBE
Group_6_Item_9_Comment= "Bit 7= OCBE: Output Compare B Enable.\n•0: Output Compare B function is enabled, but the OCMPB pin is a general I/O.\n•1: Output Compare B function is enabled, the OCMPB pin is dedicated to the Output Compare B capability of the timer."
Group_6_Item_9_Type = 1, general IO, dedicated pin
Group_6_Item_9_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x80)?1:0);
Group_6_Item_9_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x80:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x80));
Group_6_Item_10_Name = OLVLA
Group_6_Item_10_Comment = "Bit 8= OLVLA: Output Level A. The OLVLA bit is copied to the OCMPA pin whenever a successful comparison occurs with the OCAR register and the OCAE bit is set in the CR2 register."
Group_6_Item_10_Type = 1, 0, 1
Group_6_Item_10_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x100)?1:0);
Group_6_Item_10_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x100:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x100));
Group_6_Item_11_Name = OLVLB
Group_6_Item_11_Comment = "Bit 9 = OLVLB: Output Level B.This bit is copied to the OCMPB pin whenever a successful comparison occurs with the OCBR register and OCBE is set in the CR2 register. This value is copied to the OCMPA pin in One Pulse Mode and Pulse Width Modulation mode."
Group_6_Item_11_Type = 1, 0, 1
Group_6_Item_11_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x200)?1:0);
Group_6_Item_11_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x200:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x200));
Group_6_Item_12_Name = FOLVA
Group_6_Item_12_Comment = "Bit 10 = FOLVA: Forced Output Compare A.\n•0: No effect.\n•1: Forces OLVLA to be copied to the OCMPA pin."
Group_6_Item_12_Type = 1, no effect, copy OLVA
Group_6_Item_12_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x400)?1:0);
Group_6_Item_12_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x400:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x400));
Group_6_Item_13_Name = FOLVB
Group_6_Item_13_Comment = "Bit 11 = FOLVB: Forced Output Compare B.\n•0: No effect.\n•1: Forces OLVLB to be copied to the OCMPB pin."
Group_6_Item_13_Type = 1, no effect, copy OLVB
Group_6_Item_13_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x800)?1:0);
Group_6_Item_13_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x800:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x800));
Group_6_Item_14_Name = PWMI
Group_6_Item_14_Comment = "Bit 14 = PWMI: Pulse Width Modulation Input.\n•0: PWM Input is not active.\n•1: PWM Input is active."
Group_6_Item_14_Type = 1, disabled, active
Group_6_Item_14_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x4000)?1:0);
Group_6_Item_14_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x4000:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x4000));
Group_6_Item_15_Name = EN
Group_6_Item_15_Comment = "Bit 15 = EN: Timer Count Enable.\n•0: Timer counter is stopped.\n•1: Timer counter is enabled."
Group_6_Item_15_Type = 1, stopped, enabled
Group_6_Item_15_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x14)&0x8000)?1:0);
Group_6_Item_15_DecodingProc = SetWordValue(0,0xE0009000 +0x14,(GetInt()?0x8000:0)|(GetWordValue(0,0xE0009000 +0x14)&~0x8000));
Group_7_Name = Ctrl 2 Reg (CR2)
Group_7_Comment= "Control Register 2 (TIMn_CR2).\n•Address Offset: 18h.\n•Reset value: 0000h."
Group_7_ItemsNumber = 8
Group_7_Item_1_Name = CR2
Group_7_Item_1_Comment= "Ctrl 2 Reg (CR2).\n•Bit 10:8 = Reserved. These bits must be always written to 0."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0009000 +0x18).toString(16));
Group_7_Item_1_DecodingProc = SetWordValue(0,0xE0009000 +0x18,parseInt(GetString()));
Group_7_Item_2_Name = CC
Group_7_Item_2_Comment= "Bit 7:0 = CC7-CC0: Prescaler division factor.\nThis 8-bit string is the factor used by the prescaler to divide the internal clock. Timer clock will be equal to fPCLK2 / (CC7÷CC0 +1)."
Group_7_Item_2_Type = 0
Group_7_Item_2_CodingProc = SetString("0x"+(GetWordValue(0,0xE0009000 +0x18)&0x00FF).toString(16));
Group_7_Item_2_DecodingProc = SetWordValue(0,0xE0009000 +0x18,(parseInt(GetString()))&~0x00FF);
Group_7_Item_3_Name = OCBIE
Group_7_Item_3_Comment = "Bit 11 = OCBIE: Output Compare B Interrupt Enable.\n•0: No interrupt on OCFB set.\n•1: Generate interrupt if OCFB flag is set."
Group_7_Item_3_Type = 1, disabled, enabled
Group_7_Item_3_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x18)&0x800)?1:0);
Group_7_Item_3_DecodingProc = SetWordValue(0,0xE0009000 +0x18,(GetInt()?0x800:0)|(GetWordValue(0,0xE0009000 +0x18)&~0x800));
Group_7_Item_4_Name = ICBIE
Group_7_Item_4_Comment= "Bit 12= ICBIE: Input Capture B Interrupt Enable.\n•0: No interrupt on input capture B.\n•1: Generate interrupt if ICFB flag is set."
Group_7_Item_4_Type = 1, disabled, enabled
Group_7_Item_4_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x18)&0x1000)?1:0);
Group_7_Item_4_DecodingProc = SetWordValue(0,0xE0009000 +0x18,(GetInt()?0x1000:0)|(GetWordValue(0,0xE0009000 +0x18)&~0x1000));
Group_7_Item_5_Name = TOIE
Group_7_Item_5_Comment= "Bit 13 = TOIE: Timer Overflow Interrupt Enable.\n•0: Interrupt is inhibited.\n•1: A timer interrupt is enabled whenever the TOF bit of the SR register is set."
Group_7_Item_5_Type = 1, disabled, enabled
Group_7_Item_5_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x18)&0x2000)?1:0);
Group_7_Item_5_DecodingProc = SetWordValue(0,0xE0009000 +0x18,(GetInt()?0x2000:0)|(GetWordValue(0,0xE0009000 +0x18)&~0x2000));
Group_7_Item_6_Name = OCAIE
Group_7_Item_6_Comment = "Bit 14 = OCAIE: Output Compare A Interrupt Enable.\n•0: No interrupt on OCFA set.\n•1: Generate interrupt if OCFA flag is set."
Group_7_Item_6_Type = 1, disabled, enabled
Group_7_Item_6_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x18)&0x4000)?1:0);
Group_7_Item_6_DecodingProc = SetWordValue(0,0xE0009000 +0x18,(GetInt()?0x4000:0)|(GetWordValue(0,0xE0009000 +0x18)&~0x4000));
Group_7_Item_7_Name = ICAIE
Group_7_Item_7_Comment= "Bit 15 = ICAIE: Input Capture A Interrupt Enable.\n•0: No interrupt on input capture A.\n•1: Generate interrupt if ICFA flag is set."
Group_7_Item_7_Type = 1, disabled, enabled
Group_7_Item_7_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x18)&0x8000)?1:0);
Group_7_Item_7_DecodingProc = SetWordValue(0,0xE0009000 +0x18,(GetInt()?0x8000:0)|(GetWordValue(0,0xE0009000 +0x18)&~0x8000));
Group_8_Name = Status Reg (SR)
Group_8_Comment ="Status Register.\n•Address Offset: 1Ch.\n•Reset value: 0000h."
Group_8_ItemsNumber = 6
Group_8_Item_1_Name = TIM0_SR
Group_8_Item_1_Comment = "Status Register (TIMn_SR).\n•Bit 10:0 = Reserved."
Group_8_Item_1_Type = 0
Group_8_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0009000 +0x1C).toString(16));
Group_8_Item_1_DecodingProc = SetWordValue(0,0xE0009000 +0x1C,parseInt(GetString()));
Group_8_Item_2_Name = OCFB
Group_8_Item_2_Comment= "Bit 11= OCFB: Output Compare Flag B.\n•0: No match (reset value).\n•1: The content of the counter has matched the content of the OCBR register.It is set in PWM mode too. To clear this bit, write the SR register, with a ‘0’ in bit 11 (and ‘1’ in all the other bits,just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_2_Type = 1,no match, a match occured
Group_8_Item_2_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x1C)&0x800)?1:0);
Group_8_Item_2_DecodingProc = SetWordValue(0,0xE0009000 +0x1C,(GetInt()?0x800:0)|(GetWordValue(0,0xE0009000 +0x1C)&~0x800));
Group_8_Item_3_Name = ICFB
Group_8_Item_3_Comment= "Bit 12= ICFB: Input Capture Flag B.\n•0: No input capture (reset value).\n•1: An input capture has occurred.To clear this bit, write the SR register, with a ‘0’ in bit 12 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_3_Type = 1, no capture, capture occured
Group_8_Item_3_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x1C)&0x1000)?1:0);
Group_8_Item_3_DecodingProc = SetWordValue(0,0xE0009000 +0x1C,(GetInt()?0x1000:0)|(GetWordValue(0,0xE0009000 +0x1C)&~0x1000));
Group_8_Item_4_Name = TOF
Group_8_Item_4_Comment= "Bit 13= TOF: Timer Overflow.\n•0: No timer overflow (reset value).\n•1:The counter rolled over from FFFFh to 0000h. To clear this bit, write the SR register, with a ‘0’ in bit 13 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_4_Type = 1, no overflow, overflow occured
Group_8_Item_4_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x1C)&0x2000)?1:0);
Group_8_Item_4_DecodingProc = SetWordValue(0,0xE0009000 +0x1C,(GetInt()?0x2000:0)|(GetWordValue(0,0xE0009000 +0x1C)&~0x2000));
Group_8_Item_5_Name = OCFA
Group_8_Item_5_Comment= "Bit 14= OCFA: Output Compare Flag A.\n•0: No match (reset value).\n•1: The content of the counter has matched the content of the OCAR register. This bit is not set in the PWM mode even if counter matches OCAR. To clear this bit, write the SR register, with a ‘0’ in bit 14 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_5_Type = 1, no match, match occured
Group_8_Item_5_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x1C)&0x4000)?1:0);
Group_8_Item_5_DecodingProc = SetWordValue(0,0xE0009000 +0x1C,(GetInt()?0x4000:0)|(GetWordValue(0,0xE0009000 +0x1C)&~0x4000));
Group_8_Item_6_Name = ICFA
Group_8_Item_6_Comment= "Bit 15= ICFA: Input Capture Flag A.\n•0: No input capture (reset value).\n•1: An input capture has occurred. To clear this bit, write the SR register, with a ‘0’ in bit 15 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_6_Type = 1, no capture, capture occured
Group_8_Item_6_CodingProc = SetInt((GetWordValue(0,0xE0009000 +0x1C)&0x8000)?1:0);
Group_8_Item_6_DecodingProc = SetWordValue(0,0xE0009000 +0x1C,(GetInt()?0x8000:0)|(GetWordValue(0,0xE0009000 +0x1C)&~0x8000));
[Timer1]
SegmentsNumber = 1
Segment_1 = TIM1_SEG, 32, 0xE000A000, 0x20
SymbsNumber = 8
Symb_1 = TIM1_ICAR, 0, 0xE000A000 +0x00
Symb_2 = TIM1_ICBR, 0, 0xE000A000 +0x04
Symb_3 = TIM1_OCAR, 0, 0xE000A000 +0x08
Symb_4 = TIM1_OCBR, 0, 0xE000A000 +0x0C
Symb_5 = TIM1_CNTR, 0, 0xE000A000 +0x10
Symb_6 = TIM1_CR1, 0, 0xE000A000 +0x14
Symb_7 = TIM1_CR2, 0, 0xE000A000 +0x18
Symb_8 = TIM1_SR, 0, 0xE000A000 +0x1C
ResetCode = {SetWordValue(0,0xE000A000 +0x00,0x00);SetWordValue(0,0xE000A000 +0x04,0x00);SetWordValue(0,0xE000A000 +0x08,0x8000);SetWordValue(0,0xE000A000 +0x0C,0x8000);SetWordValue(0,0xE000A000 +0x10,0xFFFC);SetWordValue(0,0xE000A000 +0x14,0x0);SetWordValue(0,0xE000A000 +0x18,0x0);SetWordValue(0,0xE000A000 +0x1C,0x0);}
GroupsNumber = 8
Group_1_Name = Input Capt A (ICAR)
Group_1_comment = "This is a 16-bit read only register that contains the counter value transferred by the Input Capture A event."
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = ICAR
Group_1_Item_1_comment = "Input Capture A Register (TIMn_ICAR).\n•Address Offset: 00h.\n•Reset value: xxxxh."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000A000 +0x00).toString(16));
Group_2_Name = Input Capt B (ICBR)
Group_2_Comment= "This is a 16-bit read only register that contains the counter value transferred by the Input Capture B event."
Group_2_ItemsNumber = 1
Group_2_Item_1_Name = TIM1_ICBR
Group_2_Item_1_Comment= "Input Capture B Register (TIMn_ICBR).\n•Address Offset: 04h.\n•Reset value: xxxxh."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000A000 +0x04).toString(16));
Group_3_Name = Output Comp A (OCAR)
Group_3_Comment = "This is a 16-bit register that contains the value to be compared to the CNTR register and signalled on OCMPA output."
Group_3_ItemsNumber = 1
Group_3_Item_1_Name = TIM1_OCAR
Group_3_Item_1_Comment = "Output Compare A Register (TIMn_OCAR).\n•Address Offset: 08h.\n•Reset value: 8000h."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000A000 +0x08).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xE000A000 +0x08,parseInt(GetString()));
Group_4_Name = Output Comp B (OCBR)
Group_4_Comment = "This is a 16-bit register that contains the value to be compared to the CNTR register and signalled on OCMPB output."
Group_4_ItemsNumber = 1
Group_4_Item_1_Name = TIM1_OCBR
Group_4_Item_1_Comment = "Output Compare B Register (TIMn_OCBR).\n•Address Offset: 0Ch.\n•Reset value: 8000h."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0xE000A000 +0x0C).toString(16));
Group_4_Item_1_DecodingProc = SetWordValue(0,0xE000A000 +0x0C,parseInt(GetString()));
Group_5_Name = Counter Reg (CNTR)
Group_5_Comment= "This is a 16-bit register that contains the counter value. By writing in this register the counter is reset to the FFFCh value."
Group_5_ItemsNumber = 1
Group_5_Item_1_Name = TIM1_CNTR
Group_5_Item_1_Comment= "Counter Register (TIMn_CNTR).\n•Address Offset: 10h.\n•Reset value: FFFCh."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000A000 +0x10).toString(16));
Group_6_Name = Ctrl 1 Reg (CR1)
Group_6_Comment = "Control Register 1 (TIMn_CR1).\n•Address Offset: 14h.\n•Reset value: 0000h."
Group_6_ItemsNumber = 16
Group_6_Item_1_Name = CR1
Group_6_Item_1_Comment = "Ctrl 1 Reg (CR1).\n•Bit 13:12 = Reserved. These bits must be always written to 0."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000A000 +0x14).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xE000A000 +0x14,parseInt(GetString()));
Group_6_Item_2_Name = ECKEN
Group_6_Item_2_comment = "Bit 0 = ECKEN: External Clock Enable.\n•0: Internal clock, divided by prescaler division factor, is used to feed timer clock.\n•1: External source is used for timer clock."
Group_6_Item_2_Type = 1, internal, external
Group_6_Item_2_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&1)?1:0);
Group_6_Item_2_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?1:0)|(GetWordValue(0,0xE000A000 +0x14)&~1));
Group_6_Item_3_Name = EXEDG
Group_6_Item_3_Comment = "Bit 1 = EXEDG: External Clock Edge.\nThis bit determines which type of level transition on the external clock pin (or internal signal)EXTCLK will trigger the counter.\n•0: A falling edge triggers the counter.\n•1: A rising edge triggers the counter."
Group_6_Item_3_Type = 1, falling, rising
Group_6_Item_3_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x02)?1:0);
Group_6_Item_3_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x02:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x02));
Group_6_Item_4_Name = IEDGA
Group_6_Item_4_Comment= "Bit 2 = IEDGA: Input Edge A.\nThis bit determines which type of level transition on the ICAPA pin will trigger the capture.\n•0: A falling edge triggers the capture.\n•1: A rising edge triggers the capture."
Group_6_Item_4_Type = 1, falling, rising
Group_6_Item_4_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x04)?1:0);
Group_6_Item_4_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x04:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x04));
Group_6_Item_5_Name = IEDGB
Group_6_Item_5_Comment= "Bit 3 = IEDGB: Input Edge B.\nThis bit determines which type of level transition on the ICAPB pin will trigger the capture.\n•0: A falling edge triggers the capture.\n•1: A rising edge triggers the capture."
Group_6_Item_5_Type = 1, falling, rising
Group_6_Item_5_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x8)?1:0);
Group_6_Item_5_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x8:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x8));
Group_6_Item_6_Name = PWM
Group_6_Item_6_Comment = "Bit 4 = PWM: Pulse Width Modulation.\n•0: PWM mode is not active.\n•1: PWM mode is active, the OCMPA pin outputs a programmable cyclic signal; the length of the pulse depends on the value of OCAR register; the period depends on the value of OCBR register."
Group_6_Item_6_Type = 1, disabled, active
Group_6_Item_6_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x10)?1:0);
Group_6_Item_6_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x10:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x10));
Group_6_Item_7_Name = OPM
Group_6_Item_7_Comment= "Bit 5 = OPM: One Pulse Mode.\n•0: One Pulse Mode is not active.\n•1: One Pulse Mode is active, the ICAPA pin can be used to trigger one pulse on the OCMPA pin; the active transition is given by the IEDGA bit. The length of the generated pulse depends on the contents of the OCAR register."
Group_6_Item_7_Type = 1, disabled, active
Group_6_Item_7_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x20)?1:0);
Group_6_Item_7_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x20:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x20));
Group_6_Item_8_Name = OCAE
Group_6_Item_8_Comment= "Bit 6= OCAE: Output Compare A Enable.\n•0: Output Compare A function is enabled, but the OCMPA pin is a general I/O.\n•1: Output Compare A function is enabled, the OCMPA pin is dedicated to the Output Compare A capability of the timer."
Group_6_Item_8_Type = 1, general IO, dedicated pin
Group_6_Item_8_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x40)?1:0);
Group_6_Item_8_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x40:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x40));
Group_6_Item_9_Name = OCBE
Group_6_Item_9_Comment= "Bit 7= OCBE: Output Compare B Enable.\n•0: Output Compare B function is enabled, but the OCMPB pin is a general I/O.\n•1: Output Compare B function is enabled, the OCMPB pin is dedicated to the Output Compare B capability of the timer."
Group_6_Item_9_Type = 1, general IO, dedicated pin
Group_6_Item_9_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x80)?1:0);
Group_6_Item_9_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x80:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x80));
Group_6_Item_10_Name = OLVLA
Group_6_Item_10_Comment = "Bit 8= OLVLA: Output Level A. The OLVLA bit is copied to the OCMPA pin whenever a successful comparison occurs with the OCAR register and the OCAE bit is set in the CR2 register."
Group_6_Item_10_Type = 1, 0, 1
Group_6_Item_10_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x100)?1:0);
Group_6_Item_10_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x100:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x100));
Group_6_Item_11_Name = OLVLB
Group_6_Item_11_Comment = "Bit 9 = OLVLB: Output Level B.This bit is copied to the OCMPB pin whenever a successful comparison occurs with the OCBR register and OCBE is set in the CR2 register. This value is copied to the OCMPA pin in One Pulse Mode and Pulse Width Modulation mode."
Group_6_Item_11_Type = 1, 0, 1
Group_6_Item_11_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x200)?1:0);
Group_6_Item_11_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x200:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x200));
Group_6_Item_12_Name = FOLVA
Group_6_Item_12_Comment = "Bit 10 = FOLVA: Forced Output Compare A.\n•0: No effect.\n•1: Forces OLVLA to be copied to the OCMPA pin."
Group_6_Item_12_Type = 1, no effect, copy OLVA
Group_6_Item_12_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x400)?1:0);
Group_6_Item_12_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x400:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x400));
Group_6_Item_13_Name = FOLVB
Group_6_Item_13_Comment = "Bit 11 = FOLVB: Forced Output Compare B.\n•0: No effect.\n•1: Forces OLVLB to be copied to the OCMPB pin."
Group_6_Item_13_Type = 1, no effect, copy OLVB
Group_6_Item_13_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x800)?1:0);
Group_6_Item_13_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x800:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x800));
Group_6_Item_14_Name = PWMI
Group_6_Item_14_Comment = "Bit 14 = PWMI: Pulse Width Modulation Input.\n•0: PWM Input is not active.\n•1: PWM Input is active."
Group_6_Item_14_Type = 1, disabled, active
Group_6_Item_14_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x4000)?1:0);
Group_6_Item_14_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x4000:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x4000));
Group_6_Item_15_Name = EN
Group_6_Item_15_Comment = "Bit 15 = EN: Timer Count Enable.\n•0: Timer counter is stopped.\n•1: Timer counter is enabled."
Group_6_Item_15_Type = 1, stopped, enabled
Group_6_Item_15_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x14)&0x8000)?1:0);
Group_6_Item_15_DecodingProc = SetWordValue(0,0xE000A000 +0x14,(GetInt()?0x8000:0)|(GetWordValue(0,0xE000A000 +0x14)&~0x8000));
Group_7_Name = Ctrl 2 Reg (CR2)
Group_7_Comment= "Control Register 2 (TIMn_CR2).\n•Address Offset: 18h.\n•Reset value: 0000h."
Group_7_ItemsNumber = 8
Group_7_Item_1_Name = CR2
Group_7_Item_1_Comment= "Ctrl 2 Reg (CR2).\n•Bit 10:8 = Reserved. These bits must be always written to 0."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000A000 +0x18).toString(16));
Group_7_Item_1_DecodingProc = SetWordValue(0,0xE000A000 +0x18,parseInt(GetString()));
Group_7_Item_2_Name = CC
Group_7_Item_2_Comment= "Bit 7:0 = CC7-CC0: Prescaler division factor.\nThis 8-bit string is the factor used by the prescaler to divide the internal clock. Timer clock will be equal to fPCLK2 / (CC7÷CC0 +1)."
Group_7_Item_2_Type = 0
Group_7_Item_2_CodingProc = SetString("0x"+(GetWordValue(0,0xE000A000 +0x18)&0x00FF).toString(16));
Group_7_Item_2_DecodingProc = SetWordValue(0,0xE000A000 +0x18,(parseInt(GetString()))&~0x00FF);
Group_7_Item_3_Name = OCBIE
Group_7_Item_3_Comment = "Bit 11 = OCBIE: Output Compare B Interrupt Enable.\n•0: No interrupt on OCFB set.\n•1: Generate interrupt if OCFB flag is set."
Group_7_Item_3_Type = 1, disabled, enabled
Group_7_Item_3_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x18)&0x800)?1:0);
Group_7_Item_3_DecodingProc = SetWordValue(0,0xE000A000 +0x18,(GetInt()?0x800:0)|(GetWordValue(0,0xE000A000 +0x18)&~0x800));
Group_7_Item_4_Name = ICBIE
Group_7_Item_4_Comment= "Bit 12= ICBIE: Input Capture B Interrupt Enable.\n•0: No interrupt on input capture B.\n•1: Generate interrupt if ICFB flag is set."
Group_7_Item_4_Type = 1, disabled, enabled
Group_7_Item_4_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x18)&0x1000)?1:0);
Group_7_Item_4_DecodingProc = SetWordValue(0,0xE000A000 +0x18,(GetInt()?0x1000:0)|(GetWordValue(0,0xE000A000 +0x18)&~0x1000));
Group_7_Item_5_Name = TOIE
Group_7_Item_5_Comment= "Bit 13 = TOIE: Timer Overflow Interrupt Enable.\n•0: Interrupt is inhibited.\n•1: A timer interrupt is enabled whenever the TOF bit of the SR register is set."
Group_7_Item_5_Type = 1, disabled, enabled
Group_7_Item_5_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x18)&0x2000)?1:0);
Group_7_Item_5_DecodingProc = SetWordValue(0,0xE000A000 +0x18,(GetInt()?0x2000:0)|(GetWordValue(0,0xE000A000 +0x18)&~0x2000));
Group_7_Item_6_Name = OCAIE
Group_7_Item_6_Comment = "Bit 14 = OCAIE: Output Compare A Interrupt Enable.\n•0: No interrupt on OCFA set.\n•1: Generate interrupt if OCFA flag is set."
Group_7_Item_6_Type = 1, disabled, enabled
Group_7_Item_6_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x18)&0x4000)?1:0);
Group_7_Item_6_DecodingProc = SetWordValue(0,0xE000A000 +0x18,(GetInt()?0x4000:0)|(GetWordValue(0,0xE000A000 +0x18)&~0x4000));
Group_7_Item_7_Name = ICAIE
Group_7_Item_7_Comment= "Bit 15 = ICAIE: Input Capture A Interrupt Enable.\n•0: No interrupt on input capture A.\n•1: Generate interrupt if ICFA flag is set."
Group_7_Item_7_Type = 1, disabled, enabled
Group_7_Item_7_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x18)&0x8000)?1:0);
Group_7_Item_7_DecodingProc = SetWordValue(0,0xE000A000 +0x18,(GetInt()?0x8000:0)|(GetWordValue(0,0xE000A000 +0x18)&~0x8000));
Group_8_Name = Status Reg (SR)
Group_8_Comment ="Status Register.\n•Address Offset: 1Ch.\n•Reset value: 0000h."
Group_8_ItemsNumber = 6
Group_8_Item_1_Name = TIM1_SR
Group_8_Item_1_Comment = "Status Register (TIMn_SR).\n•Bit 10:0 = Reserved."
Group_8_Item_1_Type = 0
Group_8_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000A000 +0x1C).toString(16));
Group_8_Item_1_DecodingProc = SetWordValue(0,0xE000A000 +0x1C,parseInt(GetString()));
Group_8_Item_2_Name = OCFB
Group_8_Item_2_Comment= "Bit 11= OCFB: Output Compare Flag B.\n•0: No match (reset value).\n•1: The content of the counter has matched the content of the OCBR register.It is set in PWM mode too. To clear this bit, write the SR register, with a ‘0’ in bit 11 (and ‘1’ in all the other bits,just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_2_Type = 1,no match, a match occured
Group_8_Item_2_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x1C)&0x800)?1:0);
Group_8_Item_2_DecodingProc = SetWordValue(0,0xE000A000 +0x1C,(GetInt()?0x800:0)|(GetWordValue(0,0xE000A000 +0x1C)&~0x800));
Group_8_Item_3_Name = ICFB
Group_8_Item_3_Comment= "Bit 12= ICFB: Input Capture Flag B.\n•0: No input capture (reset value).\n•1: An input capture has occurred.To clear this bit, write the SR register, with a ‘0’ in bit 12 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_3_Type = 1, no capture, capture occured
Group_8_Item_3_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x1C)&0x1000)?1:0);
Group_8_Item_3_DecodingProc = SetWordValue(0,0xE000A000 +0x1C,(GetInt()?0x1000:0)|(GetWordValue(0,0xE000A000 +0x1C)&~0x1000));
Group_8_Item_4_Name = TOF
Group_8_Item_4_Comment= "Bit 13= TOF: Timer Overflow.\n•0: No timer overflow (reset value).\n•1:The counter rolled over from FFFFh to 0000h. To clear this bit, write the SR register, with a ‘0’ in bit 13 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_4_Type = 1, no overflow, overflow occured
Group_8_Item_4_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x1C)&0x2000)?1:0);
Group_8_Item_4_DecodingProc = SetWordValue(0,0xE000A000 +0x1C,(GetInt()?0x2000:0)|(GetWordValue(0,0xE000A000 +0x1C)&~0x2000));
Group_8_Item_5_Name = OCFA
Group_8_Item_5_Comment= "Bit 14= OCFA: Output Compare Flag A.\n•0: No match (reset value).\n•1: The content of the counter has matched the content of the OCAR register. This bit is not set in the PWM mode even if counter matches OCAR. To clear this bit, write the SR register, with a ‘0’ in bit 14 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_5_Type = 1, no match, match occured
Group_8_Item_5_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x1C)&0x4000)?1:0);
Group_8_Item_5_DecodingProc = SetWordValue(0,0xE000A000 +0x1C,(GetInt()?0x4000:0)|(GetWordValue(0,0xE000A000 +0x1C)&~0x4000));
Group_8_Item_6_Name = ICFA
Group_8_Item_6_Comment= "Bit 15= ICFA: Input Capture Flag A.\n•0: No input capture (reset value).\n•1: An input capture has occurred. To clear this bit, write the SR register, with a ‘0’ in bit 15 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_6_Type = 1, no capture, capture occured
Group_8_Item_6_CodingProc = SetInt((GetWordValue(0,0xE000A000 +0x1C)&0x8000)?1:0);
Group_8_Item_6_DecodingProc = SetWordValue(0,0xE000A000 +0x1C,(GetInt()?0x8000:0)|(GetWordValue(0,0xE000A000 +0x1C)&~0x8000));
[Timer2]
SegmentsNumber = 1
Segment_1 = TIM2_SEG, 32, 0xE000B000, 0x20
SymbsNumber = 8
Symb_1 = TIM2_ICAR, 0, 0xE000B000 +0x00
Symb_2 = TIM2_ICBR, 0, 0xE000B000 +0x04
Symb_3 = TIM2_OCAR, 0, 0xE000B000 +0x08
Symb_4 = TIM2_OCBR, 0, 0xE000B000 +0x0C
Symb_5 = TIM2_CNTR, 0, 0xE000B000 +0x10
Symb_6 = TIM2_CR1, 0, 0xE000B000 +0x14
Symb_7 = TIM2_CR2, 0, 0xE000B000 +0x18
Symb_8 = TIM2_SR, 0, 0xE000B000 +0x1C
ResetCode = {SetWordValue(0,0xE000B000 +0x00,0x00);SetWordValue(0,0xE000B000 +0x04,0x00);SetWordValue(0,0xE000B000 +0x08,0x8000);SetWordValue(0,0xE000B000 +0x0C,0x8000);SetWordValue(0,0xE000B000 +0x10,0xFFFC);SetWordValue(0,0xE000B000 +0x14,0x0);SetWordValue(0,0xE000B000 +0x18,0x0);SetWordValue(0,0xE000B000 +0x1C,0x0);}
GroupsNumber = 8
Group_1_Name = Input Capt A (ICAR)
Group_1_comment = "This is a 16-bit read only register that contains the counter value transferred by the Input Capture A event."
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = ICAR
Group_1_Item_1_comment = "Input Capture A Register (TIMn_ICAR).\n•Address Offset: 00h.\n•Reset value: xxxxh."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000B000 +0x00).toString(16));
Group_2_Name = Input Capt B (ICBR)
Group_2_Comment= "This is a 16-bit read only register that contains the counter value transferred by the Input Capture B event."
Group_2_ItemsNumber = 1
Group_2_Item_1_Name = TIM2_ICBR
Group_2_Item_1_Comment= "Input Capture B Register (TIMn_ICBR).\n•Address Offset: 04h.\n•Reset value: xxxxh."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000B000 +0x04).toString(16));
Group_3_Name = Output Comp A (OCAR)
Group_3_Comment = "This is a 16-bit register that contains the value to be compared to the CNTR register and signalled on OCMPA output."
Group_3_ItemsNumber = 1
Group_3_Item_1_Name = TIM2_OCAR
Group_3_Item_1_Comment = "Output Compare A Register (TIMn_OCAR).\n•Address Offset: 08h.\n•Reset value: 8000h."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000B000 +0x08).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xE000B000 +0x08,parseInt(GetString()));
Group_4_Name = Output Comp B (OCBR)
Group_4_Comment = "This is a 16-bit register that contains the value to be compared to the CNTR register and signalled on OCMPB output."
Group_4_ItemsNumber = 1
Group_4_Item_1_Name = TIM2_OCBR
Group_4_Item_1_Comment = "Output Compare B Register (TIMn_OCBR).\n•Address Offset: 0Ch.\n•Reset value: 8000h."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0xE000B000 +0x0C).toString(16));
Group_4_Item_1_DecodingProc = SetWordValue(0,0xE000B000 +0x0C,parseInt(GetString()));
Group_5_Name = Counter Reg (CNTR)
Group_5_Comment= "This is a 16-bit register that contains the counter value. By writing in this register the counter is reset to the FFFCh value."
Group_5_ItemsNumber = 1
Group_5_Item_1_Name = TIM2_CNTR
Group_5_Item_1_Comment= "Counter Register (TIMn_CNTR).\n•Address Offset: 10h.\n•Reset value: FFFCh."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000B000 +0x10).toString(16));
Group_6_Name = Ctrl 1 Reg (CR1)
Group_6_Comment = "Control Register 1 (TIMn_CR1).\n•Address Offset: 14h.\n•Reset value: 0000h."
Group_6_ItemsNumber = 16
Group_6_Item_1_Name = CR1
Group_6_Item_1_Comment = "Ctrl 1 Reg (CR1).\n•Bit 13:12 = Reserved. These bits must be always written to 0."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000B000 +0x14).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xE000B000 +0x14,parseInt(GetString()));
Group_6_Item_2_Name = ECKEN
Group_6_Item_2_comment = "Bit 0 = ECKEN: External Clock Enable.\n•0: Internal clock, divided by prescaler division factor, is used to feed timer clock.\n•1: External source is used for timer clock."
Group_6_Item_2_Type = 1, internal, external
Group_6_Item_2_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&1)?1:0);
Group_6_Item_2_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?1:0)|(GetWordValue(0,0xE000B000 +0x14)&~1));
Group_6_Item_3_Name = EXEDG
Group_6_Item_3_Comment = "Bit 1 = EXEDG: External Clock Edge.\nThis bit determines which type of level transition on the external clock pin (or internal signal)EXTCLK will trigger the counter.\n•0: A falling edge triggers the counter.\n•1: A rising edge triggers the counter."
Group_6_Item_3_Type = 1, falling, rising
Group_6_Item_3_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x02)?1:0);
Group_6_Item_3_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x02:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x02));
Group_6_Item_4_Name = IEDGA
Group_6_Item_4_Comment= "Bit 2 = IEDGA: Input Edge A.\nThis bit determines which type of level transition on the ICAPA pin will trigger the capture.\n•0: A falling edge triggers the capture.\n•1: A rising edge triggers the capture."
Group_6_Item_4_Type = 1, falling, rising
Group_6_Item_4_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x04)?1:0);
Group_6_Item_4_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x04:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x04));
Group_6_Item_5_Name = IEDGB
Group_6_Item_5_Comment= "Bit 3 = IEDGB: Input Edge B.\nThis bit determines which type of level transition on the ICAPB pin will trigger the capture.\n•0: A falling edge triggers the capture.\n•1: A rising edge triggers the capture."
Group_6_Item_5_Type = 1, falling, rising
Group_6_Item_5_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x8)?1:0);
Group_6_Item_5_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x8:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x8));
Group_6_Item_6_Name = PWM
Group_6_Item_6_Comment = "Bit 4 = PWM: Pulse Width Modulation.\n•0: PWM mode is not active.\n•1: PWM mode is active, the OCMPA pin outputs a programmable cyclic signal; the length of the pulse depends on the value of OCAR register; the period depends on the value of OCBR register."
Group_6_Item_6_Type = 1, disabled, active
Group_6_Item_6_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x10)?1:0);
Group_6_Item_6_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x10:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x10));
Group_6_Item_7_Name = OPM
Group_6_Item_7_Comment= "Bit 5 = OPM: One Pulse Mode.\n•0: One Pulse Mode is not active.\n•1: One Pulse Mode is active, the ICAPA pin can be used to trigger one pulse on the OCMPA pin; the active transition is given by the IEDGA bit. The length of the generated pulse depends on the contents of the OCAR register."
Group_6_Item_7_Type = 1, disabled, active
Group_6_Item_7_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x20)?1:0);
Group_6_Item_7_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x20:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x20));
Group_6_Item_8_Name = OCAE
Group_6_Item_8_Comment= "Bit 6= OCAE: Output Compare A Enable.\n•0: Output Compare A function is enabled, but the OCMPA pin is a general I/O.\n•1: Output Compare A function is enabled, the OCMPA pin is dedicated to the Output Compare A capability of the timer."
Group_6_Item_8_Type = 1, general IO, dedicated pin
Group_6_Item_8_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x40)?1:0);
Group_6_Item_8_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x40:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x40));
Group_6_Item_9_Name = OCBE
Group_6_Item_9_Comment= "Bit 7= OCBE: Output Compare B Enable.\n•0: Output Compare B function is enabled, but the OCMPB pin is a general I/O.\n•1: Output Compare B function is enabled, the OCMPB pin is dedicated to the Output Compare B capability of the timer."
Group_6_Item_9_Type = 1, general IO, dedicated pin
Group_6_Item_9_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x80)?1:0);
Group_6_Item_9_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x80:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x80));
Group_6_Item_10_Name = OLVLA
Group_6_Item_10_Comment = "Bit 8= OLVLA: Output Level A. The OLVLA bit is copied to the OCMPA pin whenever a successful comparison occurs with the OCAR register and the OCAE bit is set in the CR2 register."
Group_6_Item_10_Type = 1, 0, 1
Group_6_Item_10_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x100)?1:0);
Group_6_Item_10_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x100:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x100));
Group_6_Item_11_Name = OLVLB
Group_6_Item_11_Comment = "Bit 9 = OLVLB: Output Level B.This bit is copied to the OCMPB pin whenever a successful comparison occurs with the OCBR register and OCBE is set in the CR2 register. This value is copied to the OCMPA pin in One Pulse Mode and Pulse Width Modulation mode."
Group_6_Item_11_Type = 1, 0, 1
Group_6_Item_11_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x200)?1:0);
Group_6_Item_11_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x200:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x200));
Group_6_Item_12_Name = FOLVA
Group_6_Item_12_Comment = "Bit 10 = FOLVA: Forced Output Compare A.\n•0: No effect.\n•1: Forces OLVLA to be copied to the OCMPA pin."
Group_6_Item_12_Type = 1, no effect, copy OLVA
Group_6_Item_12_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x400)?1:0);
Group_6_Item_12_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x400:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x400));
Group_6_Item_13_Name = FOLVB
Group_6_Item_13_Comment = "Bit 11 = FOLVB: Forced Output Compare B.\n•0: No effect.\n•1: Forces OLVLB to be copied to the OCMPB pin."
Group_6_Item_13_Type = 1, no effect, copy OLVB
Group_6_Item_13_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x800)?1:0);
Group_6_Item_13_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x800:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x800));
Group_6_Item_14_Name = PWMI
Group_6_Item_14_Comment = "Bit 14 = PWMI: Pulse Width Modulation Input.\n•0: PWM Input is not active.\n•1: PWM Input is active."
Group_6_Item_14_Type = 1, disabled, active
Group_6_Item_14_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x4000)?1:0);
Group_6_Item_14_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x4000:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x4000));
Group_6_Item_15_Name = EN
Group_6_Item_15_Comment = "Bit 15 = EN: Timer Count Enable.\n•0: Timer counter is stopped.\n•1: Timer counter is enabled."
Group_6_Item_15_Type = 1, stopped, enabled
Group_6_Item_15_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x14)&0x8000)?1:0);
Group_6_Item_15_DecodingProc = SetWordValue(0,0xE000B000 +0x14,(GetInt()?0x8000:0)|(GetWordValue(0,0xE000B000 +0x14)&~0x8000));
Group_7_Name = Ctrl 2 Reg (CR2)
Group_7_Comment= "Control Register 2 (TIMn_CR2).\n•Address Offset: 18h.\n•Reset value: 0000h."
Group_7_ItemsNumber = 8
Group_7_Item_1_Name = CR2
Group_7_Item_1_Comment= "Ctrl 2 Reg (CR2).\n•Bit 10:8 = Reserved. These bits must be always written to 0."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000B000 +0x18).toString(16));
Group_7_Item_1_DecodingProc = SetWordValue(0,0xE000B000 +0x18,parseInt(GetString()));
Group_7_Item_2_Name = CC
Group_7_Item_2_Comment= "Bit 7:0 = CC7-CC0: Prescaler division factor.\nThis 8-bit string is the factor used by the prescaler to divide the internal clock. Timer clock will be equal to fPCLK2 / (CC7÷CC0 +1)."
Group_7_Item_2_Type = 0
Group_7_Item_2_CodingProc = SetString("0x"+(GetWordValue(0,0xE000B000 +0x18)&0x00FF).toString(16));
Group_7_Item_2_DecodingProc = SetWordValue(0,0xE000B000 +0x18,(parseInt(GetString()))&~0x00FF);
Group_7_Item_3_Name = OCBIE
Group_7_Item_3_Comment = "Bit 11 = OCBIE: Output Compare B Interrupt Enable.\n•0: No interrupt on OCFB set.\n•1: Generate interrupt if OCFB flag is set."
Group_7_Item_3_Type = 1, disabled, enabled
Group_7_Item_3_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x18)&0x800)?1:0);
Group_7_Item_3_DecodingProc = SetWordValue(0,0xE000B000 +0x18,(GetInt()?0x800:0)|(GetWordValue(0,0xE000B000 +0x18)&~0x800));
Group_7_Item_4_Name = ICBIE
Group_7_Item_4_Comment= "Bit 12= ICBIE: Input Capture B Interrupt Enable.\n•0: No interrupt on input capture B.\n•1: Generate interrupt if ICFB flag is set."
Group_7_Item_4_Type = 1, disabled, enabled
Group_7_Item_4_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x18)&0x1000)?1:0);
Group_7_Item_4_DecodingProc = SetWordValue(0,0xE000B000 +0x18,(GetInt()?0x1000:0)|(GetWordValue(0,0xE000B000 +0x18)&~0x1000));
Group_7_Item_5_Name = TOIE
Group_7_Item_5_Comment= "Bit 13 = TOIE: Timer Overflow Interrupt Enable.\n•0: Interrupt is inhibited.\n•1: A timer interrupt is enabled whenever the TOF bit of the SR register is set."
Group_7_Item_5_Type = 1, disabled, enabled
Group_7_Item_5_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x18)&0x2000)?1:0);
Group_7_Item_5_DecodingProc = SetWordValue(0,0xE000B000 +0x18,(GetInt()?0x2000:0)|(GetWordValue(0,0xE000B000 +0x18)&~0x2000));
Group_7_Item_6_Name = OCAIE
Group_7_Item_6_Comment = "Bit 14 = OCAIE: Output Compare A Interrupt Enable.\n•0: No interrupt on OCFA set.\n•1: Generate interrupt if OCFA flag is set."
Group_7_Item_6_Type = 1, disabled, enabled
Group_7_Item_6_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x18)&0x4000)?1:0);
Group_7_Item_6_DecodingProc = SetWordValue(0,0xE000B000 +0x18,(GetInt()?0x4000:0)|(GetWordValue(0,0xE000B000 +0x18)&~0x4000));
Group_7_Item_7_Name = ICAIE
Group_7_Item_7_Comment= "Bit 15 = ICAIE: Input Capture A Interrupt Enable.\n•0: No interrupt on input capture A.\n•1: Generate interrupt if ICFA flag is set."
Group_7_Item_7_Type = 1, disabled, enabled
Group_7_Item_7_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x18)&0x8000)?1:0);
Group_7_Item_7_DecodingProc = SetWordValue(0,0xE000B000 +0x18,(GetInt()?0x8000:0)|(GetWordValue(0,0xE000B000 +0x18)&~0x8000));
Group_8_Name = Status Reg (SR)
Group_8_Comment ="Status Register.\n•Address Offset: 1Ch.\n•Reset value: 0000h."
Group_8_ItemsNumber = 6
Group_8_Item_1_Name = TIM2_SR
Group_8_Item_1_Comment = "Status Register (TIMn_SR).\n•Bit 10:0 = Reserved."
Group_8_Item_1_Type = 0
Group_8_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000B000 +0x1C).toString(16));
Group_8_Item_1_DecodingProc = SetWordValue(0,0xE000B000 +0x1C,parseInt(GetString()));
Group_8_Item_2_Name = OCFB
Group_8_Item_2_Comment= "Bit 11= OCFB: Output Compare Flag B.\n•0: No match (reset value).\n•1: The content of the counter has matched the content of the OCBR register.It is set in PWM mode too. To clear this bit, write the SR register, with a ‘0’ in bit 11 (and ‘1’ in all the other bits,just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_2_Type = 1,no match, a match occured
Group_8_Item_2_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x1C)&0x800)?1:0);
Group_8_Item_2_DecodingProc = SetWordValue(0,0xE000B000 +0x1C,(GetInt()?0x800:0)|(GetWordValue(0,0xE000B000 +0x1C)&~0x800));
Group_8_Item_3_Name = ICFB
Group_8_Item_3_Comment= "Bit 12= ICFB: Input Capture Flag B.\n•0: No input capture (reset value).\n•1: An input capture has occurred.To clear this bit, write the SR register, with a ‘0’ in bit 12 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_3_Type = 1, no capture, capture occured
Group_8_Item_3_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x1C)&0x1000)?1:0);
Group_8_Item_3_DecodingProc = SetWordValue(0,0xE000B000 +0x1C,(GetInt()?0x1000:0)|(GetWordValue(0,0xE000B000 +0x1C)&~0x1000));
Group_8_Item_4_Name = TOF
Group_8_Item_4_Comment= "Bit 13= TOF: Timer Overflow.\n•0: No timer overflow (reset value).\n•1:The counter rolled over from FFFFh to 0000h. To clear this bit, write the SR register, with a ‘0’ in bit 13 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_4_Type = 1, no overflow, overflow occured
Group_8_Item_4_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x1C)&0x2000)?1:0);
Group_8_Item_4_DecodingProc = SetWordValue(0,0xE000B000 +0x1C,(GetInt()?0x2000:0)|(GetWordValue(0,0xE000B000 +0x1C)&~0x2000));
Group_8_Item_5_Name = OCFA
Group_8_Item_5_Comment= "Bit 14= OCFA: Output Compare Flag A.\n•0: No match (reset value).\n•1: The content of the counter has matched the content of the OCAR register. This bit is not set in the PWM mode even if counter matches OCAR. To clear this bit, write the SR register, with a ‘0’ in bit 14 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_5_Type = 1, no match, match occured
Group_8_Item_5_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x1C)&0x4000)?1:0);
Group_8_Item_5_DecodingProc = SetWordValue(0,0xE000B000 +0x1C,(GetInt()?0x4000:0)|(GetWordValue(0,0xE000B000 +0x1C)&~0x4000));
Group_8_Item_6_Name = ICFA
Group_8_Item_6_Comment= "Bit 15= ICFA: Input Capture Flag A.\n•0: No input capture (reset value).\n•1: An input capture has occurred. To clear this bit, write the SR register, with a ‘0’ in bit 15 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_6_Type = 1, no capture, capture occured
Group_8_Item_6_CodingProc = SetInt((GetWordValue(0,0xE000B000 +0x1C)&0x8000)?1:0);
Group_8_Item_6_DecodingProc = SetWordValue(0,0xE000B000 +0x1C,(GetInt()?0x8000:0)|(GetWordValue(0,0xE000B000 +0x1C)&~0x8000));
[Timer3]
SegmentsNumber = 1
Segment_1 = TIM3_SEG, 32, 0xE000C000, 0x20
SymbsNumber = 8
Symb_1 = TIM3_ICAR, 0, 0xE000C000 +0x00
Symb_2 = TIM3_ICBR, 0, 0xE000C000 +0x04
Symb_3 = TIM3_OCAR, 0, 0xE000C000 +0x08
Symb_4 = TIM3_OCBR, 0, 0xE000C000 +0x0C
Symb_5 = TIM3_CNTR, 0, 0xE000C000 +0x10
Symb_6 = TIM3_CR1, 0, 0xE000C000 +0x14
Symb_7 = TIM3_CR2, 0, 0xE000C000 +0x18
Symb_8 = TIM3_SR, 0, 0xE000C000 +0x1C
ResetCode = {SetWordValue(0,0xE000C000 +0x00,0x00);SetWordValue(0,0xE000C000 +0x04,0x00);SetWordValue(0,0xE000C000 +0x08,0x8000);SetWordValue(0,0xE000C000 +0x0C,0x8000);SetWordValue(0,0xE000C000 +0x10,0xFFFC);SetWordValue(0,0xE000C000 +0x14,0x0);SetWordValue(0,0xE000C000 +0x18,0x0);SetWordValue(0,0xE000C000 +0x1C,0x0);}
GroupsNumber = 8
Group_1_Name = Input Capt A (ICAR)
Group_1_comment = "This is a 16-bit read only register that contains the counter value transferred by the Input Capture A event."
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = ICAR
Group_1_Item_1_comment = "Input Capture A Register (TIMn_ICAR).\n•Address Offset: 00h.\n•Reset value: xxxxh."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000C000 +0x00).toString(16));
Group_2_Name = Input Capt B (ICBR)
Group_2_Comment= "This is a 16-bit read only register that contains the counter value transferred by the Input Capture B event."
Group_2_ItemsNumber = 1
Group_2_Item_1_Name = TIM3_ICBR
Group_2_Item_1_Comment= "Input Capture B Register (TIMn_ICBR).\n•Address Offset: 04h.\n•Reset value: xxxxh."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000C000 +0x04).toString(16));
Group_3_Name = Output Comp A (OCAR)
Group_3_Comment = "This is a 16-bit register that contains the value to be compared to the CNTR register and signalled on OCMPA output."
Group_3_ItemsNumber = 1
Group_3_Item_1_Name = TIM3_OCAR
Group_3_Item_1_Comment = "Output Compare A Register (TIMn_OCAR).\n•Address Offset: 08h.\n•Reset value: 8000h."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000C000 +0x08).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xE000C000 +0x08,parseInt(GetString()));
Group_4_Name = Output Comp B (OCBR)
Group_4_Comment = "This is a 16-bit register that contains the value to be compared to the CNTR register and signalled on OCMPB output."
Group_4_ItemsNumber = 1
Group_4_Item_1_Name = TIM3_OCBR
Group_4_Item_1_Comment = "Output Compare B Register (TIMn_OCBR).\n•Address Offset: 0Ch.\n•Reset value: 8000h."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0xE000C000 +0x0C).toString(16));
Group_4_Item_1_DecodingProc = SetWordValue(0,0xE000C000 +0x0C,parseInt(GetString()));
Group_5_Name = Counter Reg (CNTR)
Group_5_Comment= "This is a 16-bit register that contains the counter value. By writing in this register the counter is reset to the FFFCh value."
Group_5_ItemsNumber = 1
Group_5_Item_1_Name = TIM3_CNTR
Group_5_Item_1_Comment= "Counter Register (TIMn_CNTR).\n•Address Offset: 10h.\n•Reset value: FFFCh."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000C000 +0x10).toString(16));
Group_6_Name = Ctrl 1 Reg (CR1)
Group_6_Comment = "Control Register 1 (TIMn_CR1).\n•Address Offset: 14h.\n•Reset value: 0000h."
Group_6_ItemsNumber = 16
Group_6_Item_1_Name = CR1
Group_6_Item_1_Comment = "Ctrl 1 Reg (CR1).\n•Bit 13:12 = Reserved. These bits must be always written to 0."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000C000 +0x14).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xE000C000 +0x14,parseInt(GetString()));
Group_6_Item_2_Name = ECKEN
Group_6_Item_2_comment = "Bit 0 = ECKEN: External Clock Enable.\n•0: Internal clock, divided by prescaler division factor, is used to feed timer clock.\n•1: External source is used for timer clock."
Group_6_Item_2_Type = 1, internal, external
Group_6_Item_2_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&1)?1:0);
Group_6_Item_2_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?1:0)|(GetWordValue(0,0xE000C000 +0x14)&~1));
Group_6_Item_3_Name = EXEDG
Group_6_Item_3_Comment = "Bit 1 = EXEDG: External Clock Edge.\nThis bit determines which type of level transition on the external clock pin (or internal signal)EXTCLK will trigger the counter.\n•0: A falling edge triggers the counter.\n•1: A rising edge triggers the counter."
Group_6_Item_3_Type = 1, falling, rising
Group_6_Item_3_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x02)?1:0);
Group_6_Item_3_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x02:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x02));
Group_6_Item_4_Name = IEDGA
Group_6_Item_4_Comment= "Bit 2 = IEDGA: Input Edge A.\nThis bit determines which type of level transition on the ICAPA pin will trigger the capture.\n•0: A falling edge triggers the capture.\n•1: A rising edge triggers the capture."
Group_6_Item_4_Type = 1, falling, rising
Group_6_Item_4_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x04)?1:0);
Group_6_Item_4_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x04:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x04));
Group_6_Item_5_Name = IEDGB
Group_6_Item_5_Comment= "Bit 3 = IEDGB: Input Edge B.\nThis bit determines which type of level transition on the ICAPB pin will trigger the capture.\n•0: A falling edge triggers the capture.\n•1: A rising edge triggers the capture."
Group_6_Item_5_Type = 1, falling, rising
Group_6_Item_5_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x8)?1:0);
Group_6_Item_5_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x8:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x8));
Group_6_Item_6_Name = PWM
Group_6_Item_6_Comment = "Bit 4 = PWM: Pulse Width Modulation.\n•0: PWM mode is not active.\n•1: PWM mode is active, the OCMPA pin outputs a programmable cyclic signal; the length of the pulse depends on the value of OCAR register; the period depends on the value of OCBR register."
Group_6_Item_6_Type = 1, disabled, active
Group_6_Item_6_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x10)?1:0);
Group_6_Item_6_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x10:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x10));
Group_6_Item_7_Name = OPM
Group_6_Item_7_Comment= "Bit 5 = OPM: One Pulse Mode.\n•0: One Pulse Mode is not active.\n•1: One Pulse Mode is active, the ICAPA pin can be used to trigger one pulse on the OCMPA pin; the active transition is given by the IEDGA bit. The length of the generated pulse depends on the contents of the OCAR register."
Group_6_Item_7_Type = 1, disabled, active
Group_6_Item_7_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x20)?1:0);
Group_6_Item_7_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x20:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x20));
Group_6_Item_8_Name = OCAE
Group_6_Item_8_Comment= "Bit 6= OCAE: Output Compare A Enable.\n•0: Output Compare A function is enabled, but the OCMPA pin is a general I/O.\n•1: Output Compare A function is enabled, the OCMPA pin is dedicated to the Output Compare A capability of the timer."
Group_6_Item_8_Type = 1, general IO, dedicated pin
Group_6_Item_8_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x40)?1:0);
Group_6_Item_8_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x40:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x40));
Group_6_Item_9_Name = OCBE
Group_6_Item_9_Comment= "Bit 7= OCBE: Output Compare B Enable.\n•0: Output Compare B function is enabled, but the OCMPB pin is a general I/O.\n•1: Output Compare B function is enabled, the OCMPB pin is dedicated to the Output Compare B capability of the timer."
Group_6_Item_9_Type = 1, general IO, dedicated pin
Group_6_Item_9_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x80)?1:0);
Group_6_Item_9_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x80:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x80));
Group_6_Item_10_Name = OLVLA
Group_6_Item_10_Comment = "Bit 8= OLVLA: Output Level A. The OLVLA bit is copied to the OCMPA pin whenever a successful comparison occurs with the OCAR register and the OCAE bit is set in the CR2 register."
Group_6_Item_10_Type = 1, 0, 1
Group_6_Item_10_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x100)?1:0);
Group_6_Item_10_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x100:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x100));
Group_6_Item_11_Name = OLVLB
Group_6_Item_11_Comment = "Bit 9 = OLVLB: Output Level B.This bit is copied to the OCMPB pin whenever a successful comparison occurs with the OCBR register and OCBE is set in the CR2 register. This value is copied to the OCMPA pin in One Pulse Mode and Pulse Width Modulation mode."
Group_6_Item_11_Type = 1, 0, 1
Group_6_Item_11_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x200)?1:0);
Group_6_Item_11_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x200:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x200));
Group_6_Item_12_Name = FOLVA
Group_6_Item_12_Comment = "Bit 10 = FOLVA: Forced Output Compare A.\n•0: No effect.\n•1: Forces OLVLA to be copied to the OCMPA pin."
Group_6_Item_12_Type = 1, no effect, copy OLVA
Group_6_Item_12_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x400)?1:0);
Group_6_Item_12_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x400:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x400));
Group_6_Item_13_Name = FOLVB
Group_6_Item_13_Comment = "Bit 11 = FOLVB: Forced Output Compare B.\n•0: No effect.\n•1: Forces OLVLB to be copied to the OCMPB pin."
Group_6_Item_13_Type = 1, no effect, copy OLVB
Group_6_Item_13_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x800)?1:0);
Group_6_Item_13_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x800:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x800));
Group_6_Item_14_Name = PWMI
Group_6_Item_14_Comment = "Bit 14 = PWMI: Pulse Width Modulation Input.\n•0: PWM Input is not active.\n•1: PWM Input is active."
Group_6_Item_14_Type = 1, disabled, active
Group_6_Item_14_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x4000)?1:0);
Group_6_Item_14_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x4000:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x4000));
Group_6_Item_15_Name = EN
Group_6_Item_15_Comment = "Bit 15 = EN: Timer Count Enable.\n•0: Timer counter is stopped.\n•1: Timer counter is enabled."
Group_6_Item_15_Type = 1, stopped, enabled
Group_6_Item_15_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x14)&0x8000)?1:0);
Group_6_Item_15_DecodingProc = SetWordValue(0,0xE000C000 +0x14,(GetInt()?0x8000:0)|(GetWordValue(0,0xE000C000 +0x14)&~0x8000));
Group_7_Name = Ctrl 2 Reg (CR2)
Group_7_Comment= "Control Register 2 (TIMn_CR2).\n•Address Offset: 18h.\n•Reset value: 0000h."
Group_7_ItemsNumber = 8
Group_7_Item_1_Name = CR2
Group_7_Item_1_Comment= "Ctrl 2 Reg (CR2).\n•Bit 10:8 = Reserved. These bits must be always written to 0."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000C000 +0x18).toString(16));
Group_7_Item_1_DecodingProc = SetWordValue(0,0xE000C000 +0x18,parseInt(GetString()));
Group_7_Item_2_Name = CC
Group_7_Item_2_Comment= "Bit 7:0 = CC7-CC0: Prescaler division factor.\nThis 8-bit string is the factor used by the prescaler to divide the internal clock. Timer clock will be equal to fPCLK2 / (CC7÷CC0 +1)."
Group_7_Item_2_Type = 0
Group_7_Item_2_CodingProc = SetString("0x"+(GetWordValue(0,0xE000C000 +0x18)&0x00FF).toString(16));
Group_7_Item_2_DecodingProc = SetWordValue(0,0xE000C000 +0x18,(parseInt(GetString()))&~0x00FF);
Group_7_Item_3_Name = OCBIE
Group_7_Item_3_Comment = "Bit 11 = OCBIE: Output Compare B Interrupt Enable.\n•0: No interrupt on OCFB set.\n•1: Generate interrupt if OCFB flag is set."
Group_7_Item_3_Type = 1, disabled, enabled
Group_7_Item_3_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x18)&0x800)?1:0);
Group_7_Item_3_DecodingProc = SetWordValue(0,0xE000C000 +0x18,(GetInt()?0x800:0)|(GetWordValue(0,0xE000C000 +0x18)&~0x800));
Group_7_Item_4_Name = ICBIE
Group_7_Item_4_Comment= "Bit 12= ICBIE: Input Capture B Interrupt Enable.\n•0: No interrupt on input capture B.\n•1: Generate interrupt if ICFB flag is set."
Group_7_Item_4_Type = 1, disabled, enabled
Group_7_Item_4_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x18)&0x1000)?1:0);
Group_7_Item_4_DecodingProc = SetWordValue(0,0xE000C000 +0x18,(GetInt()?0x1000:0)|(GetWordValue(0,0xE000C000 +0x18)&~0x1000));
Group_7_Item_5_Name = TOIE
Group_7_Item_5_Comment= "Bit 13 = TOIE: Timer Overflow Interrupt Enable.\n•0: Interrupt is inhibited.\n•1: A timer interrupt is enabled whenever the TOF bit of the SR register is set."
Group_7_Item_5_Type = 1, disabled, enabled
Group_7_Item_5_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x18)&0x2000)?1:0);
Group_7_Item_5_DecodingProc = SetWordValue(0,0xE000C000 +0x18,(GetInt()?0x2000:0)|(GetWordValue(0,0xE000C000 +0x18)&~0x2000));
Group_7_Item_6_Name = OCAIE
Group_7_Item_6_Comment = "Bit 14 = OCAIE: Output Compare A Interrupt Enable.\n•0: No interrupt on OCFA set.\n•1: Generate interrupt if OCFA flag is set."
Group_7_Item_6_Type = 1, disabled, enabled
Group_7_Item_6_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x18)&0x4000)?1:0);
Group_7_Item_6_DecodingProc = SetWordValue(0,0xE000C000 +0x18,(GetInt()?0x4000:0)|(GetWordValue(0,0xE000C000 +0x18)&~0x4000));
Group_7_Item_7_Name = ICAIE
Group_7_Item_7_Comment= "Bit 15 = ICAIE: Input Capture A Interrupt Enable.\n•0: No interrupt on input capture A.\n•1: Generate interrupt if ICFA flag is set."
Group_7_Item_7_Type = 1, disabled, enabled
Group_7_Item_7_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x18)&0x8000)?1:0);
Group_7_Item_7_DecodingProc = SetWordValue(0,0xE000C000 +0x18,(GetInt()?0x8000:0)|(GetWordValue(0,0xE000C000 +0x18)&~0x8000));
Group_8_Name = Status Reg (SR)
Group_8_Comment ="Status Register.\n•Address Offset: 1Ch.\n•Reset value: 0000h."
Group_8_ItemsNumber = 6
Group_8_Item_1_Name = TIM3_SR
Group_8_Item_1_Comment = "Status Register (TIMn_SR).\n•Bit 10:0 = Reserved."
Group_8_Item_1_Type = 0
Group_8_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000C000 +0x1C).toString(16));
Group_8_Item_1_DecodingProc = SetWordValue(0,0xE000C000 +0x1C,parseInt(GetString()));
Group_8_Item_2_Name = OCFB
Group_8_Item_2_Comment= "Bit 11= OCFB: Output Compare Flag B.\n•0: No match (reset value).\n•1: The content of the counter has matched the content of the OCBR register.It is set in PWM mode too. To clear this bit, write the SR register, with a ‘0’ in bit 11 (and ‘1’ in all the other bits,just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_2_Type = 1,no match, a match occured
Group_8_Item_2_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x1C)&0x800)?1:0);
Group_8_Item_2_DecodingProc = SetWordValue(0,0xE000C000 +0x1C,(GetInt()?0x800:0)|(GetWordValue(0,0xE000C000 +0x1C)&~0x800));
Group_8_Item_3_Name = ICFB
Group_8_Item_3_Comment= "Bit 12= ICFB: Input Capture Flag B.\n•0: No input capture (reset value).\n•1: An input capture has occurred.To clear this bit, write the SR register, with a ‘0’ in bit 12 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_3_Type = 1, no capture, capture occured
Group_8_Item_3_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x1C)&0x1000)?1:0);
Group_8_Item_3_DecodingProc = SetWordValue(0,0xE000C000 +0x1C,(GetInt()?0x1000:0)|(GetWordValue(0,0xE000C000 +0x1C)&~0x1000));
Group_8_Item_4_Name = TOF
Group_8_Item_4_Comment= "Bit 13= TOF: Timer Overflow.\n•0: No timer overflow (reset value).\n•1:The counter rolled over from FFFFh to 0000h. To clear this bit, write the SR register, with a ‘0’ in bit 13 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_4_Type = 1, no overflow, overflow occured
Group_8_Item_4_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x1C)&0x2000)?1:0);
Group_8_Item_4_DecodingProc = SetWordValue(0,0xE000C000 +0x1C,(GetInt()?0x2000:0)|(GetWordValue(0,0xE000C000 +0x1C)&~0x2000));
Group_8_Item_5_Name = OCFA
Group_8_Item_5_Comment= "Bit 14= OCFA: Output Compare Flag A.\n•0: No match (reset value).\n•1: The content of the counter has matched the content of the OCAR register. This bit is not set in the PWM mode even if counter matches OCAR. To clear this bit, write the SR register, with a ‘0’ in bit 14 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_5_Type = 1, no match, match occured
Group_8_Item_5_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x1C)&0x4000)?1:0);
Group_8_Item_5_DecodingProc = SetWordValue(0,0xE000C000 +0x1C,(GetInt()?0x4000:0)|(GetWordValue(0,0xE000C000 +0x1C)&~0x4000));
Group_8_Item_6_Name = ICFA
Group_8_Item_6_Comment= "Bit 15= ICFA: Input Capture Flag A.\n•0: No input capture (reset value).\n•1: An input capture has occurred. To clear this bit, write the SR register, with a ‘0’ in bit 15 (and ‘1’ in all the other bits, just to avoid an unwanted clearing of another pending bit)."
Group_8_Item_6_Type = 1, no capture, capture occured
Group_8_Item_6_CodingProc = SetInt((GetWordValue(0,0xE000C000 +0x1C)&0x8000)?1:0);
Group_8_Item_6_DecodingProc = SetWordValue(0,0xE000C000 +0x1C,(GetInt()?0x8000:0)|(GetWordValue(0,0xE000C000 +0x1C)&~0x8000));
[BSPI0]
SegmentsNumber = 1
Segment_1 = BSPI0_SEG, 32, 0xC000A000, 0x14
SymbsNumber = 6
Symb_1 = BSPI0_RXR, 0, 0xC000A000
Symb_2 = BSPI0_TXR, 0, 0xC000A004
Symb_3 = BSPI0_CSR1, 0, 0xC000A008
Symb_4 = BSPI0_CSR2, 0, 0xC000A00C
Symb_5 = BSPI0_CLK, 0, 0xC000A010
ResetCode = {SetWordValue(0,0xC000A000,0x0);SetWordValue(0,0xC000A008,0x0);SetWordValue(0,0xC000A00C,0x40);SetWordValue(0,0xC000A010,0x06);}
GroupsNumber = 6
Group_1_Name = RX buffer
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = BSPI0_RX
Group_1_Item_1_Comment= "Bits 15:0 = RX[15:0]: Received data.\nThis register contains the data received from the BSPI bus. If the FIFO is disabled then the data from the shift register is placed into the receive register directly. If the FIFO is enabled then the received data is transferred into the FIFO. In sixteen bit mode all the register bitsare utilised. In eight bit transmission mode only the upper eight bits of the register are used. The data is left justified in the register in both transmission modes,.i.e Bit[15] = MSB, Bit[0] / Bit[8] = LSB depending on the operating mode."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC000A000).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xC000A000,parseInt(GetString()));
Group_2_Name = TX buffer
Group_2_ItemsNumber = 1
Group_2_Item_1_Name = BSPI0_TX
Group_2_Item_1_Comment= "Bits 15:0 = TX[15:0]: Transmit data.\nThis register is used to write data for transmission into the BSPI. If the FIFO is enabled then data written to this register will be transferred to the FIFO before transmission. If the FIFO is disabled then the register contents are transferred directly to the shift register for transmission. In sixteen bit mode all of the register bits are used. In eight bit mode only the upper eight bits of the register are used. In both case the data is left justified,.i.e Bit[15] = MSB, Bit[0] / Bit[8] = LSB depending on the operating mode."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC000A004).toString(16));
Group_2_Item_1_DecodingProc = SetWordValue(0,0xC000A004,parseInt(GetString()));
Group_3_Name = Control/Status Reg 1
Group_3_Comment = "Control/Status Register 1."
Group_3_ItemsNumber = 9
Group_3_Item_1_Name = CSR1
Group_3_Item_1_Comment = "BSPI Control/Status Register 1 (BSPIn_CSR1).\n•Address Offset: 08h.\n•Reset value: 0000h."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC000A008).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xC000A008,parseInt(GetString()));
Group_3_Item_2_Name = BSPE
Group_3_Item_2_Comment= "Bit 0 = BSPE: BSPI System Enable.\n•0: BSPI system is disabled.\n•1: BSPI system is enabled.\n•Note: The peripheral should be enabled before selecting the interrupts. In this way the user can avoid unexpected behaviours of interrupt request signal."
Group_3_Item_2_Type = 1, disabled, enabled
Group_3_Item_2_CodingProc = SetInt((GetWordValue(0,0xC000A008)&0x1)?1:0);
Group_3_Item_2_DecodingProc = SetWordValue(0,0xC000A008,(GetInt()?0x1:0)|(GetWordValue(0,0xC000A008)&~0x1));
Group_3_Item_3_Name = MSTR
Group_3_Item_3_Comment = "Bit 1 = MSTR: Master/Slave Select.\n•0: BSPI is configured as a slave.\n•1: BSPI is configured as a master"
Group_3_Item_3_Type = 1, slave, master
Group_3_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000A008)&0x2)?1:0);
Group_3_Item_3_DecodingProc = SetWordValue(0,0xC000A008,(GetInt()?0x2:0)|(GetWordValue(0,0xC000A008)&~0x2));
Group_3_Item_4_Name = RIE
Group_3_Item_4_Comment= "Bits 3:2 = RIE[1:0]: BSPI Receive Interrupt Enable bits.\nThe RIE1:0 bits are interrupt enable bits which configure when the processor will be interrupted on received data. The following configurations are possible."
Group_3_Item_4_Type = 1, disabled, not empty, (reserved), Full
Group_3_Item_4_CodingProc = SetInt( (GetWordValue(0,0xC000A008)&0x0C)>>2 );
Group_3_Item_4_DecodingProc = SetWordValue(0,0xC000A008,(GetInt()<<2)|(GetWordValue(0,0xC000A008)&~0x0C));
Group_3_Item_5_Name = REIE
Group_3_Item_5_Comment= "Bit 4 = REIE: Receive Error Interrupt Enable.\nWhen this bit is set to a 1 and the Receiver Overflow error condition occurs, a Receive Error Interrupt will be asserted to the processor."
Group_3_Item_5_Type = 1, disabled, enabled
Group_3_Item_5_CodingProc = SetInt((GetWordValue(0,0xC000A008)&0x10)?1:0);
Group_3_Item_5_DecodingProc = SetWordValue(0,0xC000A008,(GetInt()?0x10:0)|(GetWordValue(0,0xC000A008)&~0x10));
Group_3_Item_6_Name = BEIE
Group_3_Item_6_Comment= "Bit 7 = BEIE: Bus Error Interrupt Enable.\nWhen this bit is set to a 1, an interrupt will be asserted to the processor whenever a Bus Error condition occurs."
Group_3_Item_6_Type = 1, disabled, enabled
Group_3_Item_6_CodingProc = SetInt((GetWordValue(0,0xC000A008)&0x80)?1:0);
Group_3_Item_6_DecodingProc = SetWordValue(0,0xC000A008,(GetInt()?0x80:0)|(GetWordValue(0,0xC000A008)&~0x80));
Group_3_Item_7_Name = CPOL
Group_3_Item_7_Comment= "Bit 8 = CPOL: Clock Polarity Select.\nWhen this bit is cleared and data is not being transferred, a stable low value is present on the SCLK pin. If the bit is set the SCLK pin will idle high. This bit is used with the CPHA bit to define the master-slave clock relationship.\n•0: Active high clocks selected; SCLK idles low.\n•1: Active low clocks selected; SCLK idles high."
Group_3_Item_7_Type = 1, active low, active high
Group_3_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000A008)&0x100)?1:0);
Group_3_Item_7_DecodingProc = SetWordValue(0,0xC000A008,(GetInt()?0x100:0)|(GetWordValue(0,0xC000A008)&~0x100));
Group_3_Item_7_Name = CPHA
Group_3_Item_7_Comment = "Bit 9 = CPHA: Clock Phase Select.\nUsed with the CPOL bit to define the master-slave clock relationship. When CPHA=0, as soon as the SS goes low the first data sample is captured on the first edge of SCLK. When CPHA=1, the data is captured on the second edge."
Group_3_Item_7_Type = 1, first edge, second edge
Group_3_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000A008)&0x200)?1:0);
Group_3_Item_7_DecodingProc = SetWordValue(0,0xC000A008,(GetInt()?0x200:0)|(GetWordValue(0,0xC000A008)&~0x200));
Group_3_Item_8_Name = WL
Group_3_Item_8_Comment = "Bit 11:10 = WL[1:0]: Word Length.\nThese two bits configure the word length operation of the Receive FIFO and transmit data registers"
Group_3_Item_8_Type = 1, 8-bit, 16-bit, reserved, reserved
Group_3_Item_8_CodingProc = SetInt( (GetWordValue(0,0xC000A008)&0x0C00)>>10 );
Group_3_Item_8_DecodingProc = SetWordValue(0,0xC000A008,(GetInt()<<10)|(GetWordValue(0,0xC000A008)&~0x0C00));
Group_3_Item_9_Name = RFE
Group_3_Item_9_Comment = "Bits 15:12 = RFE[3:0]: Receive FIFO Enable.\nThe receive FIFO can be programmed to operate with a word depth up to 10. The receive FIFO enable bits declare how many words deep the FIFO is for all transfers. The FIFO defaults to one word deep, i.e. similar to a single data register. Table below shows how the FIFO is controlled."
Group_3_Item_9_Type = 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 1, 1, 1, 1, 1
Group_3_Item_9_CodingProc = SetInt( (GetWordValue(0,0xC000A008)&0xF000)>>12 );
Group_3_Item_9_DecodingProc = SetWordValue(0,0xC000A008,(GetInt()<<12)|(GetWordValue(0,0xC000A008)&~0xF000));
Group_4_Name = Control/Status Reg 2
Group_4_Comment = "Control/Status Register 2."
Group_4_ItemsNumber = 12
Group_4_Item_1_Name = BSPI0_CSR2
Group_4_Item_1_Comment = "BSPI Control/Status Register 2 (BSPIn_CSR2).\n•Address Offset: 0Ch.\n•Reset value: 0040h."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0xC000A00C).toString(16));
Group_4_Item_1_DecodingProc = SetWordValue(0,0xC000A00C,parseInt(GetString()));
Group_4_Item_2_Name = DFIFO
Group_4_Item_2_Comment = "Bit 0 = DFIFO: Disable for the FIFO.\nWhen this bit is enabled, the FIFO pointers are all reset to zero, the RFE bits are set to zero and therefore the BSPI is set to one location. The data within the FIFO is lost. This bit is reset to zero after a clock cycle"
Group_4_Item_2_Type = 1,enabled,disabled
Group_4_Item_2_CodingProc = SetInt((GetWordValue(0,0xC000A00C)&0x1)?1:0);
Group_4_Item_2_DecodingProc = SetWordValue(0,0xC000A00C,(GetInt()?0x1:0)|(GetWordValue(0,0xC000A00C)&~0x1));
Group_4_Item_3_Name = BERR
Group_4_Item_3_Comment = "Bit 2 = BERR: Bus Error.\nThis status bit indicates that a Bus Error condition has occurred, i.e. that more than one device has acted as a Master simultaneously on the BSPI bus. A Bus Error condition is defined as a condition where the Slave Select line goes active low when the module is configured as a Master. This indicates contention in that more than one node on the BSPI bus is attempting to function as a Master."
Group_4_Item_3_Type = 1, no error, error
Group_4_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000A00C)&0x4)?1:0);
Group_4_Item_4_Name = RFNE
Group_4_Item_4_Comment = "Bit 3 = RFNE: Receive FIFO Not Empty.\nThis status bit indicates that there is data in the Receive FIFO. It is set whenever there is at least one block of data in the FIFO i.e. for 8-bit mode 8 bits and for 16-bit mode 16 bits. If the RIE[1:0] bits are configured to ‘01’ then whenever this bit gets set an interrupt will be asserted to the processor. This bit is cleared when all valid data has been read out of the FIFO."
Group_4_Item_4_Type = 1, no data, not empty
Group_4_Item_4_CodingProc = SetInt((GetWordValue(0,0xC000A00C)&0x8)?1:0);
Group_4_Item_5_Name = RFF
Group_4_Item_5_Comment = "Bit 4 = RFF: Receive FIFO Full.\nThis status bit indicates that the number of FIFO locations, as defined by the RFE[3:0] bits,are all full, i.e. if the FIFO is 4 deep then all data has been received to all four locations. If the RIE[1:0] bits are configured as ‘11’ then, when this status bit gets set, an interrupt will be asserted to the processor. This bit is cleared when at least one data word has been read."
Group_4_Item_5_Type = 1, not full, full
Group_4_Item_5_CodingProc = SetInt((GetWordValue(0,0xC000A00C)&0x10)?1:0);
Group_4_Item_6_Name = ROFL
Group_4_Item_6_Comment = "Bit 5 = ROFL: Receiver Overflow.\nThis bit gets set if the Receive FIFO is full and has not been read by the processor by the time another received word arrives. If the REIE bit is set then, when this bit gets set an interrupt will be asserted to the processor. This bit is cleared when a read takes place of the CSR register and the FIFO."
Group_4_Item_6_Type = 1, no ovl, overflow
Group_4_Item_6_CodingProc = SetInt((GetWordValue(0,0xC000A00C)&0x20)?1:0);
Group_4_Item_7_Name = TFE
Group_4_Item_7_Comment = "Bit 6 = TFE: Transmit FIFO Empty.\nThis bit gets set whenever the Transmit FIFO has transferred its last data word to the transmit buffer. If interrupts are enabled then an interrupt will be asserted whenever the last word has been transferred to the transmit buffer."
Group_4_Item_7_Type = 1, not empty, empty
Group_4_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000A00C)&0x40)?1:0);
Group_4_Item_8_Name = TUFL
Group_4_Item_8_Comment = "Bit 7 = TUFL: Transmit Underflow.\nThis status bit gets set if the TFE bit is set and, by the time the Transmit Data Register contents are to be transferred to the shift register for the next transmission, the processor has not yet put the data for transmission into the Transmit Data Register.\nTUFL is set on the first edge of the clock when CPHA = 1 and when CPHA = 0 on the assertion of SS. If TIE[1:0] bits are set to “10” then, when TUFL gets set an interrupt will be asserted to the processor.\n•Note: From an application point of view, it is important to be aware that the first word available after an underflow event has occurred should be ignored, as this data was loaded into the shift register before the underflow condition was flagged."
Group_4_Item_8_Type = 1, no underflow, underflow
Group_4_Item_8_CodingProc = SetInt((GetWordValue(0,0xC000A00C)&0x80)?1:0);
Group_4_Item_9_Name = TFF
Group_4_Item_9_Comment = "Bit 8 = TFF: Transmit FIFO Full.\nTFF is set whenever the number of words written to the transmit FIFO is equal to the number of FIFO locations enabled by TFE[3:0]. The flag is set immediately after the data write is complete."
Group_4_Item_9_Type = 1, not full, full
Group_4_Item_9_CodingProc = SetInt((GetWordValue(0,0xC000A00C)&0x100)?1:0);
Group_4_Item_10_Name = TFNE
Group_4_Item_10_Comment = "Bit 9 = TFNE: Transmit FIFO Not Empty.\nThis bit is set whenever the FIFO contains at least one data word."
Group_4_Item_10_Type = 1, empty, not empty
Group_4_Item_10_CodingProc = SetInt((GetWordValue(0,0xC000A00C)&0x200)?1:0);
Group_4_Item_11_Name = TFE
Group_4_Item_11_Comment = "Bits 13:10 = TFE[3:0]: Transmit FIFO Enable.\nThese bits control the depth of the transmit FIFO. The table below indicates all valid settings."
Group_4_Item_11_Type = 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 1, 1, 1, 1, 1
Group_4_Item_11_CodingProc = SetInt( (GetWordValue(0,0xC000A00C)&0x3C00)>>10 );
Group_4_Item_11_DecodingProc = SetWordValue(0,0xC000A00C,(GetInt()<<12)|(GetWordValue(0,0xC000A00C)&~0x3C00));
Group_4_Item_12_Name = TIE
Group_4_Item_12_Comment = "Bits 15:14 = TIE[1:0]: BSPI Transmit Interrupt Enable.\nThese bits control the source of the transmit interrupt."
Group_4_Item_12_Type = 1, disabled, Empty, Underflow, Full
Group_4_Item_12_CodingProc = SetInt( (GetWordValue(0,0xC000A00C)&0xC000)>>14 );
Group_4_Item_12_DecodingProc = SetWordValue(0,0xC000A00C,(GetInt()<<14)|(GetWordValue(0,0xC000A00C)&~0xC000));
Group_5_Name = Master Clock Div.(CLK)
Group_5_Comment = "BSPI Master Clock Divider Register.\n•Address Offset: 10h.\n•Reset value: 0006h."
Group_5_ItemsNumber = 1
Group_5_CodingProc = SetString("0x"+GetWordValue(0,0xC000A010).toString(16));
Group_5_DecodingProc = SetWordValue(0,0xC000A010,parseInt(GetString()));
Group_5_Item_1_Name = DIV
Group_5_Item_1_Comment = "Bits 7:0 = DIV[7:0]: Divide factor bits.\nThese bits are used to control the frequency of the BSPI serial clock with relation to the APB1 clock. In master mode this number must be an even number greater than five, i.e. six is the lowest divide factor. In slave mode this number must be an even number greater than seven,i.e. eight is the lowest divide factor.\nThese bits must be set before the BSPE or MSTR bits, i.e. before the BSPI is configured into master mode.\n•Bits 15:8 = Reserved, must be kept at reset value (0)."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000A010)&0x00FF).toString(16));
Group_5_Item_1_DecodingProc = SetWordValue(0,0xC000A010,(parseInt(GetString())&~0x00FF));
[BSPI1]
SegmentsNumber = 1
Segment_1 = BSPI1_SEG, 32, 0xC000B000, 0x14
SymbsNumber = 6
Symb_1 = BSPI1_RXR, 0, 0xC000B000
Symb_2 = BSPI1_TXR, 0, 0xC000B004
Symb_3 = BSPI1_CSR1, 0, 0xC000B008
Symb_4 = BSPI1_CSR2, 0, 0xC000B00C
Symb_5 = BSPI1_CLK, 0, 0xC000B010
ResetCode = {SetWordValue(0,0xC000B000,0x0);SetWordValue(0,0xC000B008,0x0);SetWordValue(0,0xC000B00C,0x40);SetWordValue(0,0xC000B010,0x06);}
GroupsNumber = 6
Group_1_Name = RX buffer
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = BSPI1_RX
Group_1_Item_1_Comment= "Bits 15:0 = RX[15:0]: Received data.\nThis register contains the data received from the BSPI bus. If the FIFO is disabled then the data from the shift register is placed into the receive register directly. If the FIFO is enabled then the received data is transferred into the FIFO. In sixteen bit mode all the register bitsare utilised. In eight bit transmission mode only the upper eight bits of the register are used. The data is left justified in the register in both transmission modes,.i.e Bit[15] = MSB, Bit[0] / Bit[8] = LSB depending on the operating mode."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC000B000).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xC000B000,parseInt(GetString()));
Group_2_Name = TX buffer
Group_2_ItemsNumber = 1
Group_2_Item_1_Name = BSPI1_TX
Group_2_Item_1_Comment= "Bits 15:0 = TX[15:0]: Transmit data.\nThis register is used to write data for transmission into the BSPI. If the FIFO is enabled then data written to this register will be transferred to the FIFO before transmission. If the FIFO is disabled then the register contents are transferred directly to the shift register for transmission. In sixteen bit mode all of the register bits are used. In eight bit mode only the upper eight bits of the register are used. In both case the data is left justified,.i.e Bit[15] = MSB, Bit[0] / Bit[8] = LSB depending on the operating mode."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC000B004).toString(16));
Group_2_Item_1_DecodingProc = SetWordValue(0,0xC000B004,parseInt(GetString()));
Group_3_Name = Control/Status Reg 1
Group_3_Comment = "Control/Status Register 1."
Group_3_ItemsNumber = 9
Group_3_Item_1_Name = CSR1
Group_3_Item_1_Comment = "BSPI Control/Status Register 1 (BSPIn_CSR1).\n•Address Offset: 08h.\n•Reset value: 0000h."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC000B008).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xC000B008,parseInt(GetString()));
Group_3_Item_2_Name = BSPE
Group_3_Item_2_Comment= "Bit 0 = BSPE: BSPI System Enable.\n•0: BSPI system is disabled.\n•1: BSPI system is enabled.\n•Note: The peripheral should be enabled before selecting the interrupts. In this way the user can avoid unexpected behaviours of interrupt request signal."
Group_3_Item_2_Type = 1, disabled, enabled
Group_3_Item_2_CodingProc = SetInt((GetWordValue(0,0xC000B008)&0x1)?1:0);
Group_3_Item_2_DecodingProc = SetWordValue(0,0xC000B008,(GetInt()?0x1:0)|(GetWordValue(0,0xC000B008)&~0x1));
Group_3_Item_3_Name = MSTR
Group_3_Item_3_Comment = "Bit 1 = MSTR: Master/Slave Select.\n•0: BSPI is configured as a slave.\n•1: BSPI is configured as a master"
Group_3_Item_3_Type = 1, slave, master
Group_3_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000B008)&0x2)?1:0);
Group_3_Item_3_DecodingProc = SetWordValue(0,0xC000B008,(GetInt()?0x2:0)|(GetWordValue(0,0xC000B008)&~0x2));
Group_3_Item_4_Name = RIE
Group_3_Item_4_Comment= "Bits 3:2 = RIE[1:0]: BSPI Receive Interrupt Enable bits.\nThe RIE1:0 bits are interrupt enable bits which configure when the processor will be interrupted on received data. The following configurations are possible."
Group_3_Item_4_Type = 1, disabled, not empty, (reserved), Full
Group_3_Item_4_CodingProc = SetInt( (GetWordValue(0,0xC000B008)&0x0C)>>2 );
Group_3_Item_4_DecodingProc = SetWordValue(0,0xC000B008,(GetInt()<<2)|(GetWordValue(0,0xC000B008)&~0x0C));
Group_3_Item_5_Name = REIE
Group_3_Item_5_Comment= "Bit 4 = REIE: Receive Error Interrupt Enable.\nWhen this bit is set to a 1 and the Receiver Overflow error condition occurs, a Receive Error Interrupt will be asserted to the processor."
Group_3_Item_5_Type = 1, disabled, enabled
Group_3_Item_5_CodingProc = SetInt((GetWordValue(0,0xC000B008)&0x10)?1:0);
Group_3_Item_5_DecodingProc = SetWordValue(0,0xC000B008,(GetInt()?0x10:0)|(GetWordValue(0,0xC000B008)&~0x10));
Group_3_Item_6_Name = BEIE
Group_3_Item_6_Comment= "Bit 7 = BEIE: Bus Error Interrupt Enable.\nWhen this bit is set to a 1, an interrupt will be asserted to the processor whenever a Bus Error condition occurs."
Group_3_Item_6_Type = 1, disabled, enabled
Group_3_Item_6_CodingProc = SetInt((GetWordValue(0,0xC000B008)&0x80)?1:0);
Group_3_Item_6_DecodingProc = SetWordValue(0,0xC000B008,(GetInt()?0x80:0)|(GetWordValue(0,0xC000B008)&~0x80));
Group_3_Item_7_Name = CPOL
Group_3_Item_7_Comment= "Bit 8 = CPOL: Clock Polarity Select.\nWhen this bit is cleared and data is not being transferred, a stable low value is present on the SCLK pin. If the bit is set the SCLK pin will idle high. This bit is used with the CPHA bit to define the master-slave clock relationship.\n•0: Active high clocks selected; SCLK idles low.\n•1: Active low clocks selected; SCLK idles high."
Group_3_Item_7_Type = 1, active low, active high
Group_3_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000B008)&0x100)?1:0);
Group_3_Item_7_DecodingProc = SetWordValue(0,0xC000B008,(GetInt()?0x100:0)|(GetWordValue(0,0xC000B008)&~0x100));
Group_3_Item_7_Name = CPHA
Group_3_Item_7_Comment = "Bit 9 = CPHA: Clock Phase Select.\nUsed with the CPOL bit to define the master-slave clock relationship. When CPHA=0, as soon as the SS goes low the first data sample is captured on the first edge of SCLK. When CPHA=1, the data is captured on the second edge."
Group_3_Item_7_Type = 1, first edge, second edge
Group_3_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000B008)&0x200)?1:0);
Group_3_Item_7_DecodingProc = SetWordValue(0,0xC000B008,(GetInt()?0x200:0)|(GetWordValue(0,0xC000B008)&~0x200));
Group_3_Item_8_Name = WL
Group_3_Item_8_Comment = "Bit 11:10 = WL[1:0]: Word Length.\nThese two bits configure the word length operation of the Receive FIFO and transmit data registers"
Group_3_Item_8_Type = 1, 8-bit, 16-bit, reserved, reserved
Group_3_Item_8_CodingProc = SetInt( (GetWordValue(0,0xC000B008)&0x0C00)>>10 );
Group_3_Item_8_DecodingProc = SetWordValue(0,0xC000B008,(GetInt()<<10)|(GetWordValue(0,0xC000B008)&~0x0C00));
Group_3_Item_9_Name = RFE
Group_3_Item_9_Comment = "Bits 15:12 = RFE[3:0]: Receive FIFO Enable.\nThe receive FIFO can be programmed to operate with a word depth up to 10. The receive FIFO enable bits declare how many words deep the FIFO is for all transfers. The FIFO defaults to one word deep, i.e. similar to a single data register. Table below shows how the FIFO is controlled."
Group_3_Item_9_Type = 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 1, 1, 1, 1, 1
Group_3_Item_9_CodingProc = SetInt( (GetWordValue(0,0xC000B008)&0xF000)>>12 );
Group_3_Item_9_DecodingProc = SetWordValue(0,0xC000B008,(GetInt()<<12)|(GetWordValue(0,0xC000B008)&~0xF000));
Group_4_Name = Control/Status Reg 2
Group_4_Comment = "Control/Status Register 2."
Group_4_ItemsNumber = 12
Group_4_Item_1_Name = BSPI1_CSR2
Group_4_Item_1_Comment = "BSPI Control/Status Register 2 (BSPIn_CSR2).\n•Address Offset: 0Ch.\n•Reset value: 0040h."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0xC000B00C).toString(16));
Group_4_Item_1_DecodingProc = SetWordValue(0,0xC000B00C,parseInt(GetString()));
Group_4_Item_2_Name = DFIFO
Group_4_Item_2_Comment = "Bit 0 = DFIFO: Disable for the FIFO.\nWhen this bit is enabled, the FIFO pointers are all reset to zero, the RFE bits are set to zero and therefore the BSPI is set to one location. The data within the FIFO is lost. This bit is reset to zero after a clock cycle"
Group_4_Item_2_Type = 1,enabled,disabled
Group_4_Item_2_CodingProc = SetInt((GetWordValue(0,0xC000B00C)&0x1)?1:0);
Group_4_Item_2_DecodingProc = SetWordValue(0,0xC000B00C,(GetInt()?0x1:0)|(GetWordValue(0,0xC000B00C)&~0x1));
Group_4_Item_3_Name = BERR
Group_4_Item_3_Comment = "Bit 2 = BERR: Bus Error.\nThis status bit indicates that a Bus Error condition has occurred, i.e. that more than one device has acted as a Master simultaneously on the BSPI bus. A Bus Error condition is defined as a condition where the Slave Select line goes active low when the module is configured as a Master. This indicates contention in that more than one node on the BSPI bus is attempting to function as a Master."
Group_4_Item_3_Type = 1, no error, error
Group_4_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000B00C)&0x4)?1:0);
Group_4_Item_4_Name = RFNE
Group_4_Item_4_Comment = "Bit 3 = RFNE: Receive FIFO Not Empty.\nThis status bit indicates that there is data in the Receive FIFO. It is set whenever there is at least one block of data in the FIFO i.e. for 8-bit mode 8 bits and for 16-bit mode 16 bits. If the RIE[1:0] bits are configured to ‘01’ then whenever this bit gets set an interrupt will be asserted to the processor. This bit is cleared when all valid data has been read out of the FIFO."
Group_4_Item_4_Type = 1, no data, not empty
Group_4_Item_4_CodingProc = SetInt((GetWordValue(0,0xC000B00C)&0x8)?1:0);
Group_4_Item_5_Name = RFF
Group_4_Item_5_Comment = "Bit 4 = RFF: Receive FIFO Full.\nThis status bit indicates that the number of FIFO locations, as defined by the RFE[3:0] bits,are all full, i.e. if the FIFO is 4 deep then all data has been received to all four locations. If the RIE[1:0] bits are configured as ‘11’ then, when this status bit gets set, an interrupt will be asserted to the processor. This bit is cleared when at least one data word has been read."
Group_4_Item_5_Type = 1, not full, full
Group_4_Item_5_CodingProc = SetInt((GetWordValue(0,0xC000B00C)&0x10)?1:0);
Group_4_Item_6_Name = ROFL
Group_4_Item_6_Comment = "Bit 5 = ROFL: Receiver Overflow.\nThis bit gets set if the Receive FIFO is full and has not been read by the processor by the time another received word arrives. If the REIE bit is set then, when this bit gets set an interrupt will be asserted to the processor. This bit is cleared when a read takes place of the CSR register and the FIFO."
Group_4_Item_6_Type = 1, no ovl, overflow
Group_4_Item_6_CodingProc = SetInt((GetWordValue(0,0xC000B00C)&0x20)?1:0);
Group_4_Item_7_Name = TFE
Group_4_Item_7_Comment = "Bit 6 = TFE: Transmit FIFO Empty.\nThis bit gets set whenever the Transmit FIFO has transferred its last data word to the transmit buffer. If interrupts are enabled then an interrupt will be asserted whenever the last word has been transferred to the transmit buffer."
Group_4_Item_7_Type = 1, not empty, empty
Group_4_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000B00C)&0x40)?1:0);
Group_4_Item_8_Name = TUFL
Group_4_Item_8_Comment = "Bit 7 = TUFL: Transmit Underflow.\nThis status bit gets set if the TFE bit is set and, by the time the Transmit Data Register contents are to be transferred to the shift register for the next transmission, the processor has not yet put the data for transmission into the Transmit Data Register.\nTUFL is set on the first edge of the clock when CPHA = 1 and when CPHA = 0 on the assertion of SS. If TIE[1:0] bits are set to “10” then, when TUFL gets set an interrupt will be asserted to the processor.\n•Note: From an application point of view, it is important to be aware that the first word available after an underflow event has occurred should be ignored, as this data was loaded into the shift register before the underflow condition was flagged."
Group_4_Item_8_Type = 1, no underflow, underflow
Group_4_Item_8_CodingProc = SetInt((GetWordValue(0,0xC000B00C)&0x80)?1:0);
Group_4_Item_9_Name = TFF
Group_4_Item_9_Comment = "Bit 8 = TFF: Transmit FIFO Full.\nTFF is set whenever the number of words written to the transmit FIFO is equal to the number of FIFO locations enabled by TFE[3:0]. The flag is set immediately after the data write is complete."
Group_4_Item_9_Type = 1, not full, full
Group_4_Item_9_CodingProc = SetInt((GetWordValue(0,0xC000B00C)&0x100)?1:0);
Group_4_Item_10_Name = TFNE
Group_4_Item_10_Comment = "Bit 9 = TFNE: Transmit FIFO Not Empty.\nThis bit is set whenever the FIFO contains at least one data word."
Group_4_Item_10_Type = 1, empty, not empty
Group_4_Item_10_CodingProc = SetInt((GetWordValue(0,0xC000B00C)&0x200)?1:0);
Group_4_Item_11_Name = TFE
Group_4_Item_11_Comment = "Bits 13:10 = TFE[3:0]: Transmit FIFO Enable.\nThese bits control the depth of the transmit FIFO. The table below indicates all valid settings."
Group_4_Item_11_Type = 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 1, 1, 1, 1, 1
Group_4_Item_11_CodingProc = SetInt( (GetWordValue(0,0xC000B00C)&0x3C00)>>10 );
Group_4_Item_11_DecodingProc = SetWordValue(0,0xC000B00C,(GetInt()<<12)|(GetWordValue(0,0xC000B00C)&~0x3C00));
Group_4_Item_12_Name = TIE
Group_4_Item_12_Comment = "Bits 15:14 = TIE[1:0]: BSPI Transmit Interrupt Enable.\nThese bits control the source of the transmit interrupt."
Group_4_Item_12_Type = 1, disabled, Empty, Underflow, Full
Group_4_Item_12_CodingProc = SetInt( (GetWordValue(0,0xC000B00C)&0xC000)>>14 );
Group_4_Item_12_DecodingProc = SetWordValue(0,0xC000B00C,(GetInt()<<14)|(GetWordValue(0,0xC000B00C)&~0xC000));
Group_5_Name = Master Clock Div.(CLK)
Group_5_Comment = "BSPI Master Clock Divider Register.\n•Address Offset: 10h.\n•Reset value: 0006h."
Group_5_ItemsNumber = 1
Group_5_CodingProc = SetString("0x"+GetWordValue(0,0xC000B010).toString(16));
Group_5_DecodingProc = SetWordValue(0,0xC000B010,parseInt(GetString()));
Group_5_Item_1_Name = DIV
Group_5_Item_1_Comment = "Bits 7:0 = DIV[7:0]: Divide factor bits.\nThese bits are used to control the frequency of the BSPI serial clock with relation to the APB1 clock. In master mode this number must be an even number greater than five, i.e. six is the lowest divide factor. In slave mode this number must be an even number greater than seven,i.e. eight is the lowest divide factor.\nThese bits must be set before the BSPE or MSTR bits, i.e. before the BSPI is configured into master mode.\n•Bits 15:8 = Reserved, must be kept at reset value (0)."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000B010)&0x00FF).toString(16));
Group_5_Item_1_DecodingProc = SetWordValue(0,0xC000B010,(parseInt(GetString())&~0x00FF));
[FLASH_CTRL]
SegmentsNumber = 2
Segment_1 = FLASHR_SEG, 32, 0x40100000, 0x18
Segment_2 = FLASHNV_SEG, 32, 0x4010DFB0, 0x10
SymbsNumber = 9
Symb_1 = FLASH_CR0, 0, 0x40100000
Symb_2 = FLASH_CR1, 0, 0x40100004
Symb_3 = FLASH_DR0, 0, 0x40100008
Symb_4 = FLASH_DR1, 0, 0x4010000C
Symb_5 = FLASH_AR, 0, 0x40100010
Symb_6 = FLASH_ER, 0, 0x40100014
Symb_7 = FLASH_NVWPAR, 0, 0x4010DFB0
Symb_8 = FLASH_NVAPR0, 0, 0x4010DFB8
Symb_9 = FLASH_NVAPR1, 0, 0x4010DFBC
ResetCode = {SetDWordValue(0,0x40100000,0x00);SetDWordValue(0,0x40100004,0x00);SetDWordValue(0,0x40100008,0xffffffff);SetDWordValue(0,0x4010000C,0xffffffff);SetDWordValue(0,0x40100010,0x0);SetDWordValue(0,0x40100014,0x0);}
GroupsNumber = 5
Group_1_Name = Control Reg0 (CR0)
Group_1_Comment = "Flash Control Register 0 (FLASH_CR0).\n•Address offset: 0x0000h.\n•Reset value: 0x0000 0000h."
Group_1_ItemsNumber = 12
Group_1_Item_1_Name = FLASH_CR0
Group_1_Item_1_Comment = "The Flash Control Register 0 (FLASH_CR0) is used to enable and to monitor all the write operations for the Flash controller.\n•Note: If two or more operation selection bits (WPG, DWPG or SER) are set at the same time,they will be ignored and the current operation will be cancelled."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0x40100000).toString(16));
Group_1_Item_1_DecodingProc = SetDWordValue(0,0x40100000,parseInt(GetString()));
Group_1_Item_2_Name = BSY
Group_1_Item_2_Comment = "Bit 2:1 = BSY[1:0]: Bank 1:0 Busy.\nThese bits indicate that a write operation is ongoing in the corresponding bank. They are automatically set when bit WMS is set. A Set Protection operation sets bit BSY0. When these bits are set any read access to the corresponding bank will output invalid data, while any write access to the bank will be ignored. At the end of the write operation or during a Program or Erase Suspend these bits are automatically reset and the bank returns to read mode. After a Program or Erase Resume these bits are automatically set again. All BSY[1:0] bits remain high for a maximum of 20ìs after Power-Up and when exiting Power-Down mode, meaning that the Flash banks are not yet ready to be accessed. These bits are Read-Only."
Group_1_Item_2_Type = 0
Group_1_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0x40100000)&0x0006)>>1).toString(16));
Group_1_Item_3_Name = LOCK
Group_1_Item_3_Comment = "Bit 4 = LOCK: Flash Register Access Locked (Read Only).\nWhen this bit is set, it means that the access to all the Flash control registers is locked: any read access to the registers will output invalid data (0xE6000010) and any write access will be ineffective. Please note that the “1” of the invalid data is located exactly in the position of the LOCK bit:\ntherefore it is the only bit the user can always access to detect the status of the Flash registers. The LOCK bit is automatically set when the Flash bit WMS is set.\nOnce it is found low, the rest of FLASH_CR0 and all the other Flash registers are user accessible.\nThis bit is Read-Only."
Group_1_Item_3_Type = 1, unlocked, locked
Group_1_Item_3_CodingProc = SetInt((GetDWordValue(0,0x40100000)&0x10)?1:0);
Group_1_Item_4_Name = PWD mode
Group_1_Item_4_Comment = "Bit 15 = PWD: Power Down Mode (Read/Write).\nWhen the device is put in “STOP” mode, the Flash module can be put into two different low power modes.\n•0: Normal Mode (default), the Flash Stand-by mode is selected (immediate read from Flash is possible, but a residual consumption is present).\n•1: Flash is powered down when device enters Stop mode (minimum consumption). On wake-up a delay is inserted automatically to ensure Flash is operational before restarting the CPU.\n•Note: You can also use this feature in Low-Power Wait-for-Interrupt mode.\nHowever, because the CPU restarts immediately, you must map the interrupt vectors and interrupt service routines in RAM (and remap it to 0x00h). You have to insert a 20ìs software delay in the interrupt service routine before accessing any Flash location."
Group_1_Item_4_Type = 1, Normal, Low Power
Group_1_Item_4_CodingProc = SetInt((GetDWordValue(0,0x40100000)&0x8000)?1:0);
Group_1_Item_4_DecodingProc = SetDWordValue(0,0x40100000,(GetInt()?0x8000:0)|(GetDWordValue(0,0x40100000)&~0x8000));
Group_1_Item_5_Name = INTP
Group_1_Item_5_Comment = "Bit 20 = INTP: end of write Interrupt Pending (Read/Clear).\nThis bit is automatically set at the end of a write operation in the Flash, if bit INTM is set. This bit has to be software reset by the interrupt service routine."
Group_1_Item_5_Type = 1, IRQ disabled, IRQ enabled
Group_1_Item_5_CodingProc = SetInt((GetDWordValue(0,0x40100000)&0x100000)?1:0);
Group_1_Item_5_DecodingProc = SetDWordValue(0,0x40100000,(GetInt()?0x100000:0)|(GetDWordValue(0,0x40100000)&~0x100000));
Group_1_Item_6_Name = INTM
Group_1_Item_6_Comment = "Bit 21 = INTM: end of write Interrupt Mask (Read/Write).\nIf this bit is set, the Flash controller generates an interrupt at the end of each Write Operation."
Group_1_Item_6_Type = 1, masked, enabled
Group_1_Item_6_CodingProc = SetInt((GetDWordValue(0,0x40100000)&0x200000)?1:0);
Group_1_Item_6_DecodingProc = SetDWordValue(0,0x40100000,(GetInt()?0x200000:0)|(GetDWordValue(0,0x40100000)&~0x200000));
Group_1_Item_7_Name = SPR
Group_1_Item_7_Comment = "Bit 24 = SPR: Set Protection.\nThis bit must be set to select the Set Protection operation. The Set Protection operation allows to program 0s in place of 1s in the Flash Non Volatile Protection Registers. After selecting the write protection operation you must write the address of the FLASH_NVWPARx register in the FLASH_AR register and write the protection bit data in the FLASH_DR0 register. Then set the WMS bit to execute the operation. A sequence error is flagged by bit SEQER of FLASH_ER if the address written in FLASH_AR out of range. This bit is automatically reset at the end of the Set Protection operation."
Group_1_Item_7_Type = 1, disabled, enabled
Group_1_Item_7_CodingProc = SetInt((GetDWordValue(0,0x40100000)&0x8000000)?1:0);
Group_1_Item_7_DecodingProc = SetDWordValue(0,0x40100000,(GetInt()?0x8000000:0)|(GetDWordValue(0,0x40100000)&~0x8000000));
Group_1_Item_8_Name = SER
Group_1_Item_8_Comment = "Bit 27 = SER: Sector Erase.\nThis bit must be set to select the Sector Erase operation in the Flash module.\nThe Sector Erase operation allows to erase all the Flash locations to 0xFFFFFFFF. From 1 to all the sectors of the same bank can be selected to be erased through bits BxFy in the FLASH_CR1 register. The SER bit must be programmed before starting the execution by setting the WMS bit. It is not necessary to pre-program the sectors to 0x00, because this is done automatically. This bit is automatically reset at the end of the Sector Erase operation."
Group_1_Item_8_Type = 1, disabled, enabled
Group_1_Item_8_CodingProc = SetInt((GetDWordValue(0,0x40100000)&0x1000000)?1:0);
Group_1_Item_8_DecodingProc = SetDWordValue(0,0x40100000,(GetInt()?0x1000000:0)|(GetDWordValue(0,0x40100000)&~0x1000000));
Group_1_Item_9_Name = DWPG
Group_1_Item_9_Comment = "Bit 28 = DWPG: Double Word Program.\nThis bit must be set to select Double Word (64 bits) Program operation in the Flash module. The Double Word Program operation allows to program 0s in place of 1s. The Flash Address to be programmed (aligned with even words) must be written in the FLASH_AR register, while the 2 Flash Data to be programmed must be written in the FLASH_DR0 register (even word) and FLASH_DR1 register (odd word) before starting the execution by setting bit WMS. This bit is automatically reset at the end of the Double Word Program operation."
Group_1_Item_9_Type = 1, disabled, enabled
Group_1_Item_9_CodingProc = SetInt((GetDWordValue(0,0x40100000)&0x10000000)?1:0);
Group_1_Item_9_DecodingProc = SetDWordValue(0,0x40100000,(GetInt()?0x10000000:0)|(GetDWordValue(0,0x40100000)&~0x10000000));
Group_1_Item_10_Name = WPG
Group_1_Item_10_Comment = "Bit 29 = WPG: Word Program (Read/Write).\nThis bit must be set to select the single Word (32-bit) Program operation in the Flash module. The single Word Program operation allows to program 0s in place of 1s. The Flash Address to be programmed must be written in the FLASH_AR register, while the Flash Data to be programmed must be written in the FLASH_DR0 register before starting the execution by setting bit WMS.This bit is automatically reset at the end of the Word Program operation."
Group_1_Item_10_Type = 1, disabled, enabled
Group_1_Item_10_CodingProc = SetInt((GetDWordValue(0,0x40100000)&0x20000000)?1:0);
Group_1_Item_10_DecodingProc = SetDWordValue(0,0x40100000,(GetInt()?0x20000000:0)|(GetDWordValue(0,0x40100000)&~0x20000000));
Group_1_Item_11_Name = SUSP
Group_1_Item_11_Comment = "Bit 30 = SUSP: Suspend (Read/Write).\nThis bit must be set to suspend the current single/double word program or sector erase operation in order to read data in the same bank under modification or to program data in another bank. The Suspend operation resets the Flash bank to normal read mode (automatically resetting bits BSYA1, BSYA0).\nThis bit must be reset by the user when the suspend request has been served. WMS bit must be set again, together with the appropriate bit (WPG,DWPG, SER) to resume a suspended operation.\n•Note: When in Program Suspend, the Flash controller accepts only the following operations: Read and Program Resume.\nWhen in Erase Suspend, the Flash controller accepts only the following operations: Read, Erase Resume and Program (single/double Word Program operations cannot be suspended during Erase Suspend).\n•Note: It is forbidden to start a new Write operation when this bit is already set."
Group_1_Item_11_Type = 1, disabled, enabled
Group_1_Item_11_CodingProc = SetInt((GetDWordValue(0,0x40100000)&0x40000000)?1:0);
Group_1_Item_11_DecodingProc = SetDWordValue(0,0x40100000,(GetInt()?0x40000000:0)|(GetDWordValue(0,0x40100000)&~0x40000000));
Group_1_Item_12_Name = WMS
Group_1_Item_12_Comment = "Bit 31 = WMS: Write Mode Start.\nThis bit must be set to start a write operation (program or erase) in the Flash module. At the end of the write operation or during a suspend, this bit is automatically reset.\nResetting this bit by software has no effect.\n•Note: Setting WMS if bit ERR in the FLASH_ER register is high has no effect: the operation is ignored.\n•Note: It is forbidden to start a new write operation (by setting WMS high)with bit SUSP in the FLASH_CR0 register is high. To resume a suspended operation, SUSP must be first cleared and then WMS must be set again."
Group_1_Item_12_Type = 1, disabled, enabled
Group_1_Item_12_CodingProc = SetInt((GetDWordValue(0,0x40100000)&0x80000000)?1:0);
Group_1_Item_12_DecodingProc = SetDWordValue(0,0x40100000,(GetInt()?0x80000000:0)|(GetDWordValue(0,0x40100000)&~0x80000000));
Group_2_Name = Control Reg1 (CR1)
Group_2_Comment = "Flash Control Register 1 (FLASH_CR1).\n•Address offset: 0x0004h.\n•Reset value: 0x0000 0000h."
Group_2_ItemsNumber = 4
Group_2_Item_1_Name = FLASH_CR1
Group_2_Item_1_Comment = "The Flash Control Register 1 (FLASH_CR1) is used to specify the Sectors or the banks to be erased, or during any write operation started with the WMS bit to monitor the status of each sector and each bank of the module."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0x40100004).toString(16));
Group_2_Item_1_DecodingProc = SetDWordValue(0,0x40100004,parseInt(GetString()));
Group_2_Item_2_Name = B0F
Group_2_Item_2_Comment = "Bit 7:0 = B0F(7:0): Bank 0 Flash Sector 7:0 Control/Status.\nThese bits must be set by the user during a Sector Erase operation the sectors to be erased in bank 0. If no errors are detected,automatically reset at the end of the Sector Erase operation."
Group_2_Item_2_Type = 0
Group_2_Item_2_CodingProc = SetString("0x"+(GetDWordValue(0,0x40100004)&0x00FF).toString(16));
Group_2_Item_2_DecodingProc = SetDWordValue(0,0x40100004,(parseInt(GetString()))&~0x00FF);
Group_2_Item_3_Name = B1F
Group_2_Item_3_Comment = "Bit 17:16 = B1F[1:0]: Bank 1 Flash Sector 1:0 Control/Status.\nThese bits must be set by the user during a Sector Erase operation to select the sectors to be erased in bank 1. If no errors are detected these bits are automatically cleared at the end of the Sector Erase operation."
Group_2_Item_3_Type = 0
Group_2_Item_3_CodingProc = SetString("0x"+((GetDWordValue(0,0x40100004)&0x0300)>>16).toString(16));
Group_2_Item_3_DecodingProc = SetDWordValue(0,0x40100004,((parseInt(GetString()))<<16)|(GetDWordValue(0,0x40100004)&~0x0300));
Group_2_Item_4_Name = B1S, B0S
Group_2_Item_4_Comment = "Bit 25:24 = B0S, B1S: Bank 1-0 Status.\nAt the end of any Sector Erase operation these bits are automatically modified by hardware to give the status of the 2 banks:0: No errors detected during erase operation on bank x,1: Error detected during the erase operation on bank x."
Group_2_Item_4_Type = 0
Group_2_Item_4_CodingProc = SetString("0x"+((GetDWordValue(0,0x40100004)&0x3000)>>24).toString(16));
Group_2_Item_4_DecodingProc = SetDWordValue(0,0x40100004,((parseInt(GetString()))<<24)|(GetDWordValue(0,0x40100004)&~0x3000));
Group_3_Name = Data Reg (DR0-DR1)
Group_3_Comment = "Flash Data Registers (FLASH_DR1-DR0).\n•Address offset (FLASH_DR1): 0x000Ch.\n•Address offset (FLASH_DR0): 0x0008h.\n•Reset value: 0xFFFF FFFFh."
Group_3_ItemsNumber = 2
Group_3_Item_1_Name = FLASH_DR0
Group_3_Item_1_Comment = "the Flash Data Registers (FLASH_DR0)must be written by software, prior to starting a programming operation, to specify the target address and the data to be programmed in Flash."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0x40100008).toString(16));
Group_3_Item_1_DecodingProc = SetDWordValue(0,0x40100008,parseInt(GetString()));
Group_3_Item_2_Name = FLASH_DR1
Group_3_Item_2_Comment = "the Flash Data Registers (FLASH_DR1)must be written by software, prior to starting a programming operation, to specify the target address and the data to be programmed in Flash."
Group_3_Item_2_Type = 0
Group_3_Item_2_CodingProc = SetString("0x"+GetDWordValue(0,0x4010000C).toString(16));
Group_3_Item_2_DecodingProc = SetDWordValue(0,0x4010000C,parseInt(GetString()));
Group_4_Name = Address Reg (AR)
Group_4_Comment = "Flash Address Register (FLASH_AR).\n•Address offset: 0x0010h.\n•Reset value: 0x0000 0000h."
Group_4_ItemsNumber = 1
Group_4_Item_1_Name = FLASH_AR
Group_4_Item_1_Comment = "The Flash Address Register (FLASH_AR) must be written by software, prior to starting a programming operation, to specify the target address and the data to be programmed in Flash."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0x40100010)&0x1FFFFC).toString(16));
Group_4_Item_1_DecodingProc = SetDWordValue(0,0x40100010,parseInt(GetString())&0x1FFFFC );
Group_5_Name = Error Reg (ER)
Group_5_Comment = "Flash Error Register (FLASH_ER).\n•Address offset: 0x0014h.\n•Reset value: 0x0000 0000h."
Group_5_ItemsNumber = 8
Group_5_Item_1_Name = FLASH_ER
Group_5_Item_1_Comment = "Flash Error Register (FLASH_ER)"
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0x40100014).toString(16));
Group_5_Item_1_DecodingProc = SetDWordValue(0,0x40100014,parseInt(GetString()));
Group_5_Item_2_Name = ERR
Group_5_Item_2_Comment = "Bit 0 = ERR: Write Error.\nThis bit is automatically set when an error occurs during a Flash write operation or due to a bad write operation setup. Once the error has been discovered and understood, ERR bit must be cleared by software."
Group_5_Item_2_Type = 1, no error, error
Group_5_Item_2_CodingProc = SetInt((GetDWordValue(0,0x40100014)&1)?1:0);
Group_5_Item_2_DecodingProc = SetDWordValue(0,0x40100014,(GetInt()?1:0)|(GetDWordValue(0,0x40100014)&~1));
Group_5_Item_3_Name = ERER
Group_5_Item_3_Comment = "Bit 1 = ERER: Erase Error.\nThis bit is automatically set when an Erase error occurs during a Flash write operation. This error is due to a real failure of a Flash cell, that can no longer be erased. This kind of error is fatal and the sector where it occurred must be discarded. This bit has to be cleared by software."
Group_5_Item_3_Type = 1, no error, error
Group_5_Item_3_CodingProc = SetInt((GetDWordValue(0,0x40100014)&2)?1:0);
Group_5_Item_3_DecodingProc = SetDWordValue(0,0x40100014,(GetInt()?2:0)|(GetDWordValue(0,0x40100014)&~2));
Group_5_Item_4_Name = PGER
Group_5_Item_4_Comment = "Bit 2 = PGER: Program Error.\nThis bit is automatically set when a Program error occurs during a Flash write operation. This error is due to a real failure of a Flash cell, that can no longer be programmed. The word where this error occurred must be discarded. This bit has to be cleared by software."
Group_5_Item_4_Type = 1, no error, error
Group_5_Item_4_CodingProc = SetInt((GetDWordValue(0,0x40100014)&4)?1:0);
Group_5_Item_4_DecodingProc = SetDWordValue(0,0x40100014,(GetInt()?4:0)|(GetDWordValue(0,0x40100014)&~4));
Group_5_Item_5_Name = "10ER "
Group_5_Item_5_Comment = "Bit 3 = 10ER. 1 over 0 Error.\nThis bit is automatically set when trying to program to 1 bits previously programmed to 0 (this does not happen when programming the Protection bits). This error is not due to a failure of the Flash cell, but only flags that the desired data has not been written. This bit has to be cleared by software."
Group_5_Item_5_Type = 1, no error, error
Group_5_Item_5_CodingProc = SetInt((GetDWordValue(0,0x40100014)&8)?1:0);
Group_5_Item_5_DecodingProc = SetDWordValue(0,0x40100014,(GetInt()?8:0)|(GetDWordValue(0,0x40100014)&~8));
Group_5_Item_6_Name = SEQER
Group_5_Item_6_Comment = "Bit 6 = SEQER: Sequence Error.\nThis bit is automatically set when the control registers (FLASH_CR1-0,FLASH_AR, FLASH_DR1-0) are not correctly filled to execute a valid Write Operation. In this case, no Write Operation is executed. This bit has to be cleared by software."
Group_5_Item_6_Type = 1, no error, error
Group_5_Item_6_CodingProc = SetInt((GetDWordValue(0,0x40100014)&0x40)?1:0);
Group_5_Item_6_DecodingProc = SetDWordValue(0,0x40100014,(GetInt()?0x40:0)|(GetDWordValue(0,0x40100014)&~0x40));
Group_5_Item_7_Name = RESER
Group_5_Item_7_Comment = "Bit 7 = RESER: Resume Error.\nThis bit is automatically set when a suspended Program or Erase operation is not resumed correctly due to a protocol error. In this case, the suspended operation is aborted. This bit has to be cleared by software."
Group_5_Item_7_Type = 1, no error, error
Group_5_Item_7_CodingProc = SetInt((GetDWordValue(0,0x40100014)&0x80)?1:0);
Group_5_Item_7_DecodingProc = SetDWordValue(0,0x40100014,(GetInt()?0x80:0)|(GetDWordValue(0,0x40100014)&~0x80));
Group_5_Item_8_Name = WPF
Group_5_Item_8_Comment = "Bit 8 = WPF: Write Protection Flag.\nThis bit is automatically set when trying to program or erase a write protected sector. This bit has to be cleared by software."
Group_5_Item_8_Type = 1, no error, error
Group_5_Item_8_CodingProc = SetInt((GetDWordValue(0,0x40100014)&0x100)?1:0);
Group_5_Item_8_DecodingProc = SetDWordValue(0,0x40100014,(GetInt()?0x100:0)|(GetDWordValue(0,0x40100014)&~0x100));
[I2C0]
SegmentsNumber = 1
Segment_1 = I2C0_REGS, 32,0xC0001000, 0x20
SymbsNumber = 8
Symb_1 = I2C0_CR, 0, 0xC0001000
Symb_2 = I2C0_SR1, 0, 0xC0001004
Symb_3 = I2C0_SR2, 0, 0xC0001008
Symb_4 = I2C0_CCR, 0, 0xC000100C
Symb_5 = I2C0_OAR1, 0, 0xC0001010
Symb_6 = I2C0_OAR2, 0, 0xC0001014
Symb_7 = I2C0_DR, 0, 0xC0001018
Symb_8 = I2C0_ECCR, 0, 0xC000101C
ResetCode = {SetDWordValue(0,0xC0001000 +0x00,0x00);SetDWordValue(0,0xC0001000 +0x04,0x00);SetDWordValue(0,0xC0001000 +0x08,0x00);SetDWordValue(0,0xC0001000 +0x0C,0x00);SetDWordValue(0,0xC0001000 +0x10,0x00);SetDWordValue(0,0xC0001000 +0x14,0x00);SetDWordValue(0,0xC0001000 +0x18,0x00);SetDWordValue(0,0xC0001000 +0x1C,0x00);}
GroupsNumber = 5
Group_1_Name = Control Register (CR)
Group_1_Comment="Control Register.\n•Address Offset: 00h.\n•Reset value: 00h."
Group_1_ItemsNumber = 7
Group_1_Item_1_Name = I2C_CR
Group_1_Item_1_Comment = "I2C Control Register (I2Cn_CR).\n•Bit 7:6 = Reserved, always read as 0."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetDWordValue(0, 0xC0001000 +0x00).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xC0001000 +0x00,parseInt(GetString()));
Group_1_Item_2_Name = ITE
Group_1_Item_2_Comment = "Bit 0 = ITE: Interrupt enable.\nThis bit is set and cleared by software and cleared by hardware when the interface is disabled (PE=0).\n•0: Interrupts disabled.\n•1: Interrupts enabled.\nRefer to Figure 59 for the relationship between the events and the interrupts.\nSCL is held low when the ADD10, SB, BTF or ADSL flags or an EV6 event is detected."
Group_1_Item_2_Type = 1, interrupts disabled, interrupts enabled
Group_1_Item_2_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x00)&0x01)?1:0);
Group_1_Item_2_DecodingProc = SetDWordValue(0, 0xC0001000 +0x00, GetInt()|(GetDWordValue(0,0xC0001000 +0x00)&~0x01));
Group_1_Item_3_Name = STOP
Group_1_Item_3_Comment = "Bit 1 = STOP: Generation of a Stop condition.\nThis bit is set and cleared by software. It is also cleared by hardware in master mode.\n•Note:\nThis bit is not cleared when the interface is disabled (PE=0).\n- In master mode:\n •0: No stop generation.\n •1: Stop generation after the current byte transfer or after the current Start condition is sent. The STOP bit is cleared by hardware when the Stop condition is sent.\n- In slave mode:\n •0: No stop generation.\n •1: Release the SCL and SDA li nes after the current byte transfer (BTF=1). In this mode the STOP bit has to be cleared by software."
Group_1_Item_3_Type = 1, no stop generation , release lines (slave), generate stop (master)
Group_1_Item_3_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x00)&0x02)?((GetDWordValue(0, 0xC0001000 +0x00)&0x02)?2:0):((GetDWordValue(0, 0xC0001000 +0x00)&0x02)?1:0));
Group_1_Item_3_DecodingProc = SetDWordValue(0, 0xC0001000 +0x00, (GetInt()?0x02:0)|(GetDWordValue(0,0xC0001000 +0x00)&~0x02));
Group_1_Item_4_Name = ACK
Group_1_Item_4_Comment = "Bit 2 = ACK: Acknowledge enable.\nThis bit is set and cleared by software. It is also cleared by hardware when the interface is disabled (PE=0).\n•0: No acknowledge returned\n•1: Acknowledge returned after an address byte or a data byte is received Group_1_Item_3_Type = 1, ack disabled, ack enabled"
Group_1_Item_4_Type = 1, no acknowledge, acknowledge
Group_1_Item_4_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x00)&0x04)?1:0);
Group_1_Item_4_DecodingProc = SetDWordValue(0, 0xC0001000 +0x00, (GetInt()?0x04:0)|(GetDWordValue(0,0xC0001000 +0x00)&~0x04));
Group_1_Item_5_Name = START
Group_1_Item_5_Comment = "Bit 3 = START: Generation of a Start condition.\nThis bit is set and cleared by software. It is also cleared by hardware when the interface is disabled (PE=0) or when the Start condition is sent (with interrupt generation if ITE=1).\n- In master mode:\n •0: No start generation.\n •1: Repeated start generation.\n- In slave mode:\n •0: No start generation.\n •1: Start generation when the bus is free."
Group_1_Item_5_Type = 1, no start generation , generate start if bus free (slave), generate repeated start (master)
Group_1_Item_5_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x00)&0x02)?((GetDWordValue(0, 0xC0001000 +0x00)&0x08)?2:0):((GetDWordValue(0, 0xC0001000 +0x00)&0x08)?1:0));
Group_1_Item_5_DecodingProc = SetDWordValue(0, 0xC0001000 +0x00, (GetInt()?0x08:0)|(GetDWordValue(0,0xC0001000 +0x00)&~0x08));
Group_1_Item_6_Name = ENGC
Group_1_Item_6_Comment = "Bit 4 = ENGC: Enable General Call.\nThis bit is set and cleared by software. It is also cleared by hardware when the interface is disabled (PE=0). The 00h General Call address is acknowledged (01h ignored).\n•0: General Call disabled.\n•1: General Call enabled."
Group_1_Item_6_Type = 1, general call enabled, general call disabled
Group_1_Item_6_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x00)&0x10)?1:0);
Group_1_Item_6_DecodingProc = SetDWordValue(0, 0xC0001000 +0x00, (GetInt()?0x10:0)|(GetDWordValue(0,0xC0001000 +0x00)&~0x10));
Group_1_Item_7_Name = PE
Group_1_Item_7_Comment = "Bit 5 = PE: Peripheral Enable.\nThis bit is set and cleared by software.\n•0: Peripheral disabled\n•1: Master/Slave capability\nNotes:\n•0: all the bits of the I2Cn_CR register and the I2Cn_SR register except the STOP bit are reset. All outputs are released while PE=0.\n•1: the corresponding I/O pins are selected by hardware as alternate functions.\nTo enable the I2C interface, write the I2Cn_CR register TWICE with PE=1 as the first write only activates the interface (only PE is set)."
Group_1_Item_7_Type = 1, peripheral disabled, master/slave capability
Group_1_Item_7_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x00)&0x20)?1:0);
Group_1_Item_7_DecodingProc = SetDWordValue(0, 0xC0001000 +0x00, (GetInt()?0x20:0)|(GetDWordValue(0,0xC0001000 +0x00)&~0x20));
Group_2_Name = Status Registers (SR1, SR2)
Group_2_Comment= "I2C Status Register 1 and 2 (I2Cn_SR1,I2Cn_SR2)."
Group_2_ItemsNumber = 15
Group_2_Item_1_Name = I2C_SR
Group_2_Item_1_Comment = "Status Registers\nI2Cn_SR1:\n•Address Offset: 04h.\n•Reset value: 00h.\nI2Cn_SR2:\n•Address Offset: 08h.\n•Reset value: 00h.\n•Bit 7:6 = Reserved, always read as 0."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+GetDWordValue(0, 0xC0001000 +0x04).toString(16)+", 0x"+GetDWordValue(0, 0xC0001000 +0x08).toString(16));
Group_2_Item_2_Name = SB
Group_2_Item_2_Comment = "Bit 0 = SB: Start bit (Master mode).\nThis bit is set by hardware as soon as the Start condition is generated (following a write START=1). An interrupt is generated if ITE=1. It is cleared by software reading I2Cn_SR1 register followed by writing the address byte in I2Cn_DR register. It is also cleared by hardware when the interface is disabled (PE=0).\n•0: No Start condition.\n•1: Start condition generated."
Group_2_Item_2_Type = 1, no start condition generated, start condition generated
Group_2_Item_2_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x04)&0x01)?1:0);
Group_2_Item_3_Name = M/SL
Group_2_Item_3_Comment= "Bit 1 = M/SL: Master/Slave.\nThis bit is set by hardware as soon as the interface is in Master mode (writing START=1). It is cleared by hardware after detecting a Stop condition on the bus or a loss of arbitration (ARLO=1). It is also cleared when the interface is disabled (PE=0).\n•0: Slave mode.\n•1: Master mode."
Group_2_Item_3_Type = 1, slave, master
Group_2_Item_3_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x04)&0x02)?1:0);
Group_2_Item_4_Name = ADSL
Group_2_Item_4_Comment = "Bit 2 = ADSL: Address matched (Slave mode). This bit is set by hardware as soon as the received slave address matched with the I2Cn_OAR register content or a general call is recognized. An interrupt is generated if ITE=1. It is cleared by software reading I2Cn_SR1 register or by hardware when the interface is disabled (PE=0).\nThe SCL line is held low while ADSL=1.\n•0: Address mismatched or not received.\n•1: Received address matched."
Group_2_Item_4_Type = 1, address mismatched or not received, received address matched
Group_2_Item_4_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x04)&0x04)?1:0);
Group_2_Item_5_Name = BTF
Group_2_Item_5_Comment = "Bit 3 = BTF: Byte transfer finished.\nThis bit is set by hardware as soon as a byte is correctly received or transmitted with interrupt generation if ITE=1. It is cleared by software reading I2Cn_SR1 register followed by a read or write of I2Cn_DR register. It is also cleared by hardware when the interface is disabled (PE=0).\n• Following a byte transmission, this bit is set after reception of the acknowledge clock pulse. In case an address byte is sent, this bit is set only after the EV6 event (See Figure 58). BTF is cleared by writing the next byte in I2Cn_DR register.\n• Following a byte reception, this bit is set after transmission of the acknowledge clock pulse if ACK=1. BTF is cleared by reading I2Cn_SR1 register followed by reading the byte from I2Cn_DR register.\nThe SCL line is held low while BTF=1.\n•0: Byte transfer not done\n•1: Byte transfer succeeded"
Group_2_Item_5_Type = 1, byte transfer not done, byte transfer succeeded
Group_2_Item_5_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x04)&0x08)?1:0);
Group_2_Item_6_Name = BUSY
Group_2_Item_6_Comment = "Bit 4 = BUSY: Bus busy.\nThis bit is set by hardware on detection of a Start condition and cleared by hardware on detection of a Stop condition. It indicates a communication in progress on the bus. This information is still updated when the interface is disabled (PE=0).\n•0: No communication on the bus\n•1: Communication ongoing on the bus"
Group_2_Item_6_Type = 1, no communication on the bus, communication ongoing on the bus
Group_2_Item_6_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x04)&0x10)?1:0);
Group_2_Item_7_Name = TRA
Group_2_Item_7_Comment = "Bit 5 = TRA: Transmitter/Receiver.\nWhen BTF is set, TRA=1 if a data byte has been transmitted. It is cleared automatically when BTF is cleared. It is also cleared by hardware after detection of Stop condition (STOPF=1),loss of bus arbitration (ARLO=1) or when the interface is disabled (PE=0).\n•0: Data byte received (if BTF=1).\n•1: Data byte transmitted."
Group_2_Item_7_Type = 1, data byte received, data byte transmitted, no data transferred
Group_2_Item_7_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x04)&0x08)?((GetDWordValue(0, 0xC0001000 +0x04)&0x20)?1:0):2);
Group_2_Item_8_Name = ADD10
Group_2_Item_8_Comment = "Bit 6 = ADD10: 10-bit addressing in Master mode.\nThis bit is set by hardware when the master has sent the first byte in 10-bit address mode. It is cleared by software reading I2Cn_SR2 register followed by a write in the I2Cn_DR register of the second address byte. It is also cleared by hardware when the peripheral is disabled (PE=0).\n•0: No ADD10 event occurred.\n•1: Master has sent first address byte (header)."
Group_2_Item_8_Type = 1, no ADD10 event occured, master has sent the first address byte (header)
Group_2_Item_8_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x04)&0x40)?1:0);
Group_2_Item_9_Name = EVF
Group_2_Item_9_Comment = "Bit 7 = EVF: Event flag.\nThis bit is set by hardware as soon as an event occurs. It is cleared by software reading I2Cn_SR2 register in case of error event or as described in Figure 58. It is also cleared by hardware when the interface is disabled (PE=0).\n•0: No event\n•1: One of the following events has occurred:\n- BTF=1 (Byte received or transmitted)\n- ADSL=1 (Address matched in Slave mode while ACK=1)\n- SB=1 (Start condition generated in Master mode)\n- AF=1 (No acknowledge received after byte transmission)\n- STOPF=1 (Stop condition detected in Slave mode)\n- ARLO=1 (Arbitration lost in Master mode)\n- BERR=1 (Bus error, misplaced Start or Stop condition detected)\n- ADD10=1 (Master has sent header byte)\n- ENDAD=1 (Address byte successfully transmitted in Master mode)."
Group_2_Item_9_Type = 1, no event, event occured (see other bits)
Group_2_Item_9_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x04)&0x80)?1:0);
Group_2_Item_10_Name = GCAL
Group_2_Item_10_Comment = "Bit 0 = GCAL General Call (Slave mode).\nThis bit is set by hardware when a general call address is detected on the bus while ENGC=1.\nIt is cleared by hardware detecting a Stop condition (STOPF=1) or when the interface is disabled (PE=0).\n•0: No general call address detected on bus\n•1: general call address detected on bus"
Group_2_Item_10_Type = 1, no general call address detected, general call address detected
Group_2_Item_10_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x08)&0x01)?1:0);
Group_2_Item_11_Name = BERR
Group_2_Item_11_Comment = "Bit 1 = BERR: Bus error.\nThis bit is set by hardware when the interface detects a misplaced Start or Stop condition. An interrupt is generated if ITE=1. It is cleared by software reading I2Cn_SR2 register or by hardware when the interface is disabled (PE=0).\nThe SCL line is not held low while BERR=1.\n•0: No misplaced Start or Stop condition\n•1: Misplaced Start or Stop condition"
Group_2_Item_11_Type = 1, no misplaced start or stop condition, misplaced start or stop condition
Group_2_Item_11_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x08)&0x02)?1:0);
Group_2_Item_12_Name = ARLO
Group_2_Item_12_Comment = "Bit 2 = ARLO: Arbitration lost.\nThis bit is set by hardware when the interface loses the arbitration of the bus to another master. An interrupt is generated if ITE=1. It is cleared by software reading I2Cn_SR2 register or by hardware when the interface is disabled (PE=0).\nAfter an ARLO event the interface switches back automatically to Slave mode (M/SL=0).\nThe SCL line is not held low while ARLO=1.\n•0: No arbitration lost detected\n•1: Arbitration lost detected"
Group_2_Item_12_Type = 1, no arbitration lost detected, arbitration lost detected
Group_2_Item_12_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x08)&0x04)?1:0);
Group_2_Item_13_Name = STOPF
Group_2_Item_13_Comment = "Bit 3 = STOPF: Stop detection (Slave mode).\nThis bit is set by hardware when a Stop condition is detected on the bus after an acknowledge (if ACK=1). An interrupt is generated if ITE=1. It is cleared by software reading I2Cn_SR2 register or by hardware when the interface is disabled (PE=0).\nThe SCL line is not held low while STOPF=1.\n•0: No Stop condition detected\n•1: Stop condition detected"
Group_2_Item_13_Type = 1, no stop condition detected, stop condition detected
Group_2_Item_13_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x08)&0x08)?1:0);
Group_2_Item_14_Name = AF
Group_2_Item_14_Comment = "Bit 4 = AF: Acknowledge failure.\nThis bit is set by hardware when no acknowledge is returned. An interrupt is generated if ITE=1. It is cleared by software by reading I2Cn_SR2 register or by hardware when the interface is disabled (PE=0).\nThe SCL line is not held low while AF=1.\n•0: No acknowledge failure\n•1: Acknowledge failure"
Group_2_Item_14_Type = 1, no acknowledge failure, acknowledge failure
Group_2_Item_14_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x08)&0x10)?1:0);
Group_2_Item_15_Name = ENDAD
Group_2_Item_15_Comment = "Bit 5 = ENDAD: End of address transmission.\nThis bit is set by hardware when:\n• 7-bit addressing mode: the address byte has been transmitted;\n• 10-bit addressing mode: the MSB and the LSB have been transmitted during the addressing phase.\nWhen the master needs to receive data from the slave, it has to send just the MSB of the slave address once again; hence the ENDAD flag is set, without waiting for the LSB of the address.\nIt is cleared by software by reading SR2 and a following write to the CR or by hardware when the interface is disabled (PE=0).\n•0: No end of address transmission\n•1: End of address transmission"
Group_2_Item_15_Type = 1, no end of address transmission, end of address transmission
Group_2_Item_15_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x08)&0x20)?1:0);
Group_3_Name = Clock Control Registers (CCR, ECCR)
Group_3_Comment= "I2C Clock Control Register (I2Cn_CCR),I2C Extended Clock Control Register (I2Cn_ECCR)."
Group_3_ItemsNumber = 3
Group_3_Item_1_Name = I2C_CCR,I2C_ECCR
Group_3_Item_1_Comment = "Clock Control Registers.\n•Address Offset: 0Ch.\n•Reset value: 00h.\nExtended Clock Control Register (I2Cn_ECCR).\n•Address Offset: 1Ch.\n•Reset value: 00h."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetDWordValue(0, 0xC0001000 +0x0C).toString(16)+", 0x"+GetDWordValue(0, 0xC0001000 +0x1C).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xC0001000 +0x0C,parseInt(GetString())), SetWordValue(0,0xC0001000 +0x1C,parseInt(GetString()));
Group_3_Item_2_Name = CC11-CC0
Group_3_Item_2_Comment = "Bit 6:0 = CC6-CC0: 12-bit clock divider.\nThese bits along with CC11-CC7 of the Extended Clock Control Register select the speed of the bus (fSCL) depending on the I2C mode. They are not cleared when the interface is disabled (PE=0).\n• Standard mode (FM/SM=0): fSCL = 100kHz\nfSCL = fPCLK1/ (2 x [CC11..CC0]+7)\nGiven a certain fPCLK1, it is easy to obtain the right divider factor:\n[CC11..CC0] = ((fPCLK1 / fSCL)-7) / 2 = ((tSCL / tPCLK1) - 7) / 2\n• Fast mode (FM/SM=1): 100kHz<fSCL<400kHz\nfSCL = fPCLK1/ (3 x [CC11..CC0]+9)\nGiven a certain fPCLK1, it is easy to obtain the right divider factor:\n[CC11..CC0] = ((fPCLK1 / fSCL)-9) /3 = ((tSCL / tPCLK1)-9) / 3\nNote The programmed fSCL assumes no load on SCL and SDA lines.\nNote For a correct usage of the divider, [CC11..CC0] must be equal or greater than 0x002(000000000010b). [CC11..CC0] equal to 0x001 (000000000001b) is not admitted.\nNote The acheived speed can have ~2% tolerance.Bit 7-5 = Reserved, always read as 0."
Group_3_Item_2_Type = 0
Group_3_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0, 0xC0001000 +0x1C)<<7)|(GetDWordValue(0, 0xC0001000 +0x0C)&0x7F)).toString(16));
Group_3_Item_2_DecodingProc = {SetDWordValue(0, 0xC0001000 +0x0C, (parseInt(GetString())&0x7F)|(GetDWordValue(0, 0xC0001000 +0x0C)&0x80));SetDWordValue(0, 0xC0001000 +0x1C, parseInt(GetString())>>7);}
Group_3_Item_3_Name = FM/SM
Group_3_Item_3_Comment = "Bit 7 = FM/SM: Fast/Standard I2C mode.\nThis bit is set and cleared by software. It is not cleared when the interface is disabled (PE=0).\n•0: Standard I2C mode\n•1: Fast I2C mode"
Group_3_Item_3_Type = "1, standard I²C mode, fast I²C mode"
Group_3_Item_3_CodingProc = SetInt((GetDWordValue(0, 0xC0001000 +0x0C)&0x80)?1:0);
Group_3_Item_3_DecodingProc = SetDWordValue(0, 0xC0001000 +0x0C, (GetInt()?0x80:0)|(GetDWordValue(0,0xC000200C)&~0x80));
Group_4_Name = Own Address Registers (OAR1, OAR2)
Group_4_Comment= "I2C Own Address Register 1 (I2Cn_OAR1).\n•Address Offset: 10h.\n•Reset value: 00h.\nI2C Own Address Register 2 (I2Cn_OAR2).\n•Address Offset: 14h.\n•Reset value: 20h."
Group_4_ItemsNumber = 3
Group_4_Item_1_Name = I2C_OAR1,I2C_OAR2
Group_4_Item_1_Comment = "•Bit 4:3 = Reserved, always read as 0."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+GetDWordValue(0, 0xC0001000 +0x10).toString(16)+", 0x"+GetDWordValue(0, 0xC0001000 +0x14).toString(16));
Group_4_Item_1_DecodingProc = SetWordValue(0,0xC0001000 +0x10,parseInt(GetString())), SetWordValue(0,0xC0001000 +0x14,parseInt(GetString()));
Group_4_Item_2_Name = ADD9-ADD0
Group_4_Item_2_Comment = "ADD9-ADD0: Interface address.\nThese are the least significant bits of the I2C bus address of the interface. They are not cleared when the interface is disabled (PE=0).Group_4_Item_1_Type = 0"
Group_4_Item_2_Type = 0
Group_4_Item_2_CodingProc = SetString("0x"+(((GetDWordValue(0, 0xC0001000 +0x14)&0x06)<<7)|GetDWordValue(0, 0xC0001000 +0x10)).toString(16));
Group_4_Item_2_DecodingProc = {SetDWordValue(0, 0xC0001000 +0x14, ((parseInt(GetString())>>7)&0x06)|(GetDWordValue(0, 0xC0001000 +0x0C)&~0x06));SetDWordValue(0, 0xC0001000 +0x1C, parseInt(GetString())>>7);}
Group_4_Item_3_Name = FR2-FR0
Group_4_Item_3_Comment = "Bit 7:5 = FR2-FR0: Frequency bits.\nThese bits are set by software only when the interface is disabled (PE=0). To configure the interface to I2C specified delays select the value corresponding to the system frequency fPCLK1."
Group_4_Item_3_Type = 0
Group_4_Item_3_CodingProc = SetString("0x"+(GetDWordValue(0, 0xC0001000 +0x14)>>5).toString(16));
Group_4_Item_3_DecodingProc = SetDWordValue(0, 0xC0001000 +0x14, (parseInt(GetString())<<5)|(GetDWordValue(0, 0xC0001000 +0x0C)&~0xE0));
Group_5_Name = Data Register (DR)
Group_5_Comment = "I2C Data Register (I2Cn_DR)."
Group_5_ItemsNumber = 2
Group_5_Item_1_Name = I2C_DR
Group_5_Item_1_Comment = "Data Register.\n•Address Offset: 18h.\n•Reset value: 00h."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+GetDWordValue(0, 0xC0001000 +0x18).toString(16));
Group_5_Item_1_DecodingProc = SetWordValue(0,0xC0001000 +0x18,parseInt(GetString()));
Group_5_Item_2_Name = DR
Group_5_Item_2_Comment = "Bit 7:0 = D7-D0: 8-bit Data Register.\nThese bits contain the byte to be received or transmitted on the bus.\n• Transmitter mode: Byte transmission start automatically when the software writes in the I2Cn_DR register.\n• Receiver mode: the first data byte is received automatically in the I2Cn_DR register using the least significant bit of the address. Then, the following data bytes are received one by one after reading the I2Cn_DR register."
Group_5_Item_2_Type = 0
Group_5_Item_2_CodingProc = SetString("0x"+GetDWordValue(0, 0xC0001000 +0x18).toString(16));
Group_5_Item_2_DecodingProc = SetDWordValue(0, 0xC0001000 +0x18, parseInt(GetString()));
[I2C1]
SegmentsNumber = 1
Segment_1 = I2C1_REGS, 32,0xC0002000, 0x20
SymbsNumber = 8
Symb_1 = I2C1_CR, 0, 0xC0002000
Symb_2 = I2C1_SR1, 0, 0xC0002004
Symb_3 = I2C1_SR2, 0, 0xC0002008
Symb_4 = I2C1_CCR, 0, 0xC000200C
Symb_5 = I2C1_OAR1, 0, 0xC0002010
Symb_6 = I2C1_OAR2, 0, 0xC0002014
Symb_7 = I2C1_DR, 0, 0xC0002018
Symb_8 = I2C1_ECCR, 0, 0xC000201C
ResetCode = {SetDWordValue(0,0xC0002000 +0x00,0x00);SetDWordValue(0,0xC0002000 +0x04,0x00);SetDWordValue(0,0xC0002000 +0x08,0x00);SetDWordValue(0,0xC0002000 +0x0C,0x00);SetDWordValue(0,0xC0002000 +0x10,0x00);SetDWordValue(0,0xC0002000 +0x14,0x00);SetDWordValue(0,0xC0002000 +0x18,0x00);SetDWordValue(0,0xC0002000 +0x1C,0x00);}
GroupsNumber = 5
Group_1_Name = Control Register (CR)
Group_1_Comment="Control Register.\n•Address Offset: 00h.\n•Reset value: 00h."
Group_1_ItemsNumber = 7
Group_1_Item_1_Name = I2C_CR
Group_1_Item_1_Comment = "I2C Control Register (I2Cn_CR).\n•Bit 7:6 = Reserved, always read as 0."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetDWordValue(0, 0xC0002000 +0x00).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xC0002000 +0x00,parseInt(GetString()));
Group_1_Item_2_Name = ITE
Group_1_Item_2_Comment = "Bit 0 = ITE: Interrupt enable.\nThis bit is set and cleared by software and cleared by hardware when the interface is disabled (PE=0).\n•0: Interrupts disabled.\n•1: Interrupts enabled.\nRefer to Figure 59 for the relationship between the events and the interrupts.\nSCL is held low when the ADD10, SB, BTF or ADSL flags or an EV6 event is detected."
Group_1_Item_2_Type = 1, interrupts disabled, interrupts enabled
Group_1_Item_2_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x00)&0x01)?1:0);
Group_1_Item_2_DecodingProc = SetDWordValue(0, 0xC0002000 +0x00, GetInt()|(GetDWordValue(0,0xC0002000 +0x00)&~0x01));
Group_1_Item_3_Name = STOP
Group_1_Item_3_Comment = "Bit 1 = STOP: Generation of a Stop condition.\nThis bit is set and cleared by software. It is also cleared by hardware in master mode.\n•Note:\nThis bit is not cleared when the interface is disabled (PE=0).\n- In master mode:\n •0: No stop generation.\n •1: Stop generation after the current byte transfer or after the current Start condition is sent. The STOP bit is cleared by hardware when the Stop condition is sent.\n- In slave mode:\n •0: No stop generation.\n •1: Release the SCL and SDA li nes after the current byte transfer (BTF=1). In this mode the STOP bit has to be cleared by software."
Group_1_Item_3_Type = 1, no stop generation , release lines (slave), generate stop (master)
Group_1_Item_3_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x00)&0x02)?((GetDWordValue(0, 0xC0002000 +0x00)&0x02)?2:0):((GetDWordValue(0, 0xC0002000 +0x00)&0x02)?1:0));
Group_1_Item_3_DecodingProc = SetDWordValue(0, 0xC0002000 +0x00, (GetInt()?0x02:0)|(GetDWordValue(0,0xC0002000 +0x00)&~0x02));
Group_1_Item_4_Name = ACK
Group_1_Item_4_Comment = "Bit 2 = ACK: Acknowledge enable.\nThis bit is set and cleared by software. It is also cleared by hardware when the interface is disabled (PE=0).\n•0: No acknowledge returned\n•1: Acknowledge returned after an address byte or a data byte is received Group_1_Item_3_Type = 1, ack disabled, ack enabled"
Group_1_Item_4_Type = 1, no acknowledge, acknowledge
Group_1_Item_4_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x00)&0x04)?1:0);
Group_1_Item_4_DecodingProc = SetDWordValue(0, 0xC0002000 +0x00, (GetInt()?0x04:0)|(GetDWordValue(0,0xC0002000 +0x00)&~0x04));
Group_1_Item_5_Name = START
Group_1_Item_5_Comment = "Bit 3 = START: Generation of a Start condition.\nThis bit is set and cleared by software. It is also cleared by hardware when the interface is disabled (PE=0) or when the Start condition is sent (with interrupt generation if ITE=1).\n- In master mode:\n •0: No start generation.\n •1: Repeated start generation.\n- In slave mode:\n •0: No start generation.\n •1: Start generation when the bus is free."
Group_1_Item_5_Type = 1, no start generation , generate start if bus free (slave), generate repeated start (master)
Group_1_Item_5_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x00)&0x02)?((GetDWordValue(0, 0xC0002000 +0x00)&0x08)?2:0):((GetDWordValue(0, 0xC0002000 +0x00)&0x08)?1:0));
Group_1_Item_5_DecodingProc = SetDWordValue(0, 0xC0002000 +0x00, (GetInt()?0x08:0)|(GetDWordValue(0,0xC0002000 +0x00)&~0x08));
Group_1_Item_6_Name = ENGC
Group_1_Item_6_Comment = "Bit 4 = ENGC: Enable General Call.\nThis bit is set and cleared by software. It is also cleared by hardware when the interface is disabled (PE=0). The 00h General Call address is acknowledged (01h ignored).\n•0: General Call disabled.\n•1: General Call enabled."
Group_1_Item_6_Type = 1, general call enabled, general call disabled
Group_1_Item_6_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x00)&0x10)?1:0);
Group_1_Item_6_DecodingProc = SetDWordValue(0, 0xC0002000 +0x00, (GetInt()?0x10:0)|(GetDWordValue(0,0xC0002000 +0x00)&~0x10));
Group_1_Item_7_Name = PE
Group_1_Item_7_Comment = "Bit 5 = PE: Peripheral Enable.\nThis bit is set and cleared by software.\n•0: Peripheral disabled\n•1: Master/Slave capability\nNotes:\n•0: all the bits of the I2Cn_CR register and the I2Cn_SR register except the STOP bit are reset. All outputs are released while PE=0.\n•1: the corresponding I/O pins are selected by hardware as alternate functions.\nTo enable the I2C interface, write the I2Cn_CR register TWICE with PE=1 as the first write only activates the interface (only PE is set)."
Group_1_Item_7_Type = 1, peripheral disabled, master/slave capability
Group_1_Item_7_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x00)&0x20)?1:0);
Group_1_Item_7_DecodingProc = SetDWordValue(0, 0xC0002000 +0x00, (GetInt()?0x20:0)|(GetDWordValue(0,0xC0002000 +0x00)&~0x20));
Group_2_Name = Status Registers (SR1, SR2)
Group_2_Comment= "I2C Status Register 1 and 2 (I2Cn_SR1,I2Cn_SR2)."
Group_2_ItemsNumber = 15
Group_2_Item_1_Name = I2C_SR
Group_2_Item_1_Comment = "Status Registers\nI2Cn_SR1:\n•Address Offset: 04h.\n•Reset value: 00h.\nI2Cn_SR2:\n•Address Offset: 08h.\n•Reset value: 00h.\n•Bit 7:6 = Reserved, always read as 0."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+GetDWordValue(0, 0xC0002000 +0x04).toString(16)+", 0x"+GetDWordValue(0, 0xC0002000 +0x08).toString(16));
Group_2_Item_2_Name = SB
Group_2_Item_2_Comment = "Bit 0 = SB: Start bit (Master mode).\nThis bit is set by hardware as soon as the Start condition is generated (following a write START=1). An interrupt is generated if ITE=1. It is cleared by software reading I2Cn_SR1 register followed by writing the address byte in I2Cn_DR register. It is also cleared by hardware when the interface is disabled (PE=0).\n•0: No Start condition.\n•1: Start condition generated."
Group_2_Item_2_Type = 1, no start condition generated, start condition generated
Group_2_Item_2_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x04)&0x01)?1:0);
Group_2_Item_3_Name = M/SL
Group_2_Item_3_Comment= "Bit 1 = M/SL: Master/Slave.\nThis bit is set by hardware as soon as the interface is in Master mode (writing START=1). It is cleared by hardware after detecting a Stop condition on the bus or a loss of arbitration (ARLO=1). It is also cleared when the interface is disabled (PE=0).\n•0: Slave mode.\n•1: Master mode."
Group_2_Item_3_Type = 1, slave, master
Group_2_Item_3_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x04)&0x02)?1:0);
Group_2_Item_4_Name = ADSL
Group_2_Item_4_Comment = "Bit 2 = ADSL: Address matched (Slave mode). This bit is set by hardware as soon as the received slave address matched with the I2Cn_OAR register content or a general call is recognized. An interrupt is generated if ITE=1. It is cleared by software reading I2Cn_SR1 register or by hardware when the interface is disabled (PE=0).\nThe SCL line is held low while ADSL=1.\n•0: Address mismatched or not received.\n•1: Received address matched."
Group_2_Item_4_Type = 1, address mismatched or not received, received address matched
Group_2_Item_4_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x04)&0x04)?1:0);
Group_2_Item_5_Name = BTF
Group_2_Item_5_Comment = "Bit 3 = BTF: Byte transfer finished.\nThis bit is set by hardware as soon as a byte is correctly received or transmitted with interrupt generation if ITE=1. It is cleared by software reading I2Cn_SR1 register followed by a read or write of I2Cn_DR register. It is also cleared by hardware when the interface is disabled (PE=0).\n• Following a byte transmission, this bit is set after reception of the acknowledge clock pulse. In case an address byte is sent, this bit is set only after the EV6 event (See Figure 58). BTF is cleared by writing the next byte in I2Cn_DR register.\n• Following a byte reception, this bit is set after transmission of the acknowledge clock pulse if ACK=1. BTF is cleared by reading I2Cn_SR1 register followed by reading the byte from I2Cn_DR register.\nThe SCL line is held low while BTF=1.\n•0: Byte transfer not done\n•1: Byte transfer succeeded"
Group_2_Item_5_Type = 1, byte transfer not done, byte transfer succeeded
Group_2_Item_5_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x04)&0x08)?1:0);
Group_2_Item_6_Name = BUSY
Group_2_Item_6_Comment = "Bit 4 = BUSY: Bus busy.\nThis bit is set by hardware on detection of a Start condition and cleared by hardware on detection of a Stop condition. It indicates a communication in progress on the bus. This information is still updated when the interface is disabled (PE=0).\n•0: No communication on the bus\n•1: Communication ongoing on the bus"
Group_2_Item_6_Type = 1, no communication on the bus, communication ongoing on the bus
Group_2_Item_6_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x04)&0x10)?1:0);
Group_2_Item_7_Name = TRA
Group_2_Item_7_Comment = "Bit 5 = TRA: Transmitter/Receiver.\nWhen BTF is set, TRA=1 if a data byte has been transmitted. It is cleared automatically when BTF is cleared. It is also cleared by hardware after detection of Stop condition (STOPF=1),loss of bus arbitration (ARLO=1) or when the interface is disabled (PE=0).\n•0: Data byte received (if BTF=1).\n•1: Data byte transmitted."
Group_2_Item_7_Type = 1, data byte received, data byte transmitted, no data transferred
Group_2_Item_7_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x04)&0x08)?((GetDWordValue(0, 0xC0002000 +0x04)&0x20)?1:0):2);
Group_2_Item_8_Name = ADD10
Group_2_Item_8_Comment = "Bit 6 = ADD10: 10-bit addressing in Master mode.\nThis bit is set by hardware when the master has sent the first byte in 10-bit address mode. It is cleared by software reading I2Cn_SR2 register followed by a write in the I2Cn_DR register of the second address byte. It is also cleared by hardware when the peripheral is disabled (PE=0).\n•0: No ADD10 event occurred.\n•1: Master has sent first address byte (header)."
Group_2_Item_8_Type = 1, no ADD10 event occured, master has sent the first address byte (header)
Group_2_Item_8_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x04)&0x40)?1:0);
Group_2_Item_9_Name = EVF
Group_2_Item_9_Comment = "Bit 7 = EVF: Event flag.\nThis bit is set by hardware as soon as an event occurs. It is cleared by software reading I2Cn_SR2 register in case of error event or as described in Figure 58. It is also cleared by hardware when the interface is disabled (PE=0).\n•0: No event\n•1: One of the following events has occurred:\n- BTF=1 (Byte received or transmitted)\n- ADSL=1 (Address matched in Slave mode while ACK=1)\n- SB=1 (Start condition generated in Master mode)\n- AF=1 (No acknowledge received after byte transmission)\n- STOPF=1 (Stop condition detected in Slave mode)\n- ARLO=1 (Arbitration lost in Master mode)\n- BERR=1 (Bus error, misplaced Start or Stop condition detected)\n- ADD10=1 (Master has sent header byte)\n- ENDAD=1 (Address byte successfully transmitted in Master mode)."
Group_2_Item_9_Type = 1, no event, event occured (see other bits)
Group_2_Item_9_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x04)&0x80)?1:0);
Group_2_Item_10_Name = GCAL
Group_2_Item_10_Comment = "Bit 0 = GCAL General Call (Slave mode).\nThis bit is set by hardware when a general call address is detected on the bus while ENGC=1.\nIt is cleared by hardware detecting a Stop condition (STOPF=1) or when the interface is disabled (PE=0).\n•0: No general call address detected on bus\n•1: general call address detected on bus"
Group_2_Item_10_Type = 1, no general call address detected, general call address detected
Group_2_Item_10_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x08)&0x01)?1:0);
Group_2_Item_11_Name = BERR
Group_2_Item_11_Comment = "Bit 1 = BERR: Bus error.\nThis bit is set by hardware when the interface detects a misplaced Start or Stop condition. An interrupt is generated if ITE=1. It is cleared by software reading I2Cn_SR2 register or by hardware when the interface is disabled (PE=0).\nThe SCL line is not held low while BERR=1.\n•0: No misplaced Start or Stop condition\n•1: Misplaced Start or Stop condition"
Group_2_Item_11_Type = 1, no misplaced start or stop condition, misplaced start or stop condition
Group_2_Item_11_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x08)&0x02)?1:0);
Group_2_Item_12_Name = ARLO
Group_2_Item_12_Comment = "Bit 2 = ARLO: Arbitration lost.\nThis bit is set by hardware when the interface loses the arbitration of the bus to another master. An interrupt is generated if ITE=1. It is cleared by software reading I2Cn_SR2 register or by hardware when the interface is disabled (PE=0).\nAfter an ARLO event the interface switches back automatically to Slave mode (M/SL=0).\nThe SCL line is not held low while ARLO=1.\n•0: No arbitration lost detected\n•1: Arbitration lost detected"
Group_2_Item_12_Type = 1, no arbitration lost detected, arbitration lost detected
Group_2_Item_12_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x08)&0x04)?1:0);
Group_2_Item_13_Name = STOPF
Group_2_Item_13_Comment = "Bit 3 = STOPF: Stop detection (Slave mode).\nThis bit is set by hardware when a Stop condition is detected on the bus after an acknowledge (if ACK=1). An interrupt is generated if ITE=1. It is cleared by software reading I2Cn_SR2 register or by hardware when the interface is disabled (PE=0).\nThe SCL line is not held low while STOPF=1.\n•0: No Stop condition detected\n•1: Stop condition detected"
Group_2_Item_13_Type = 1, no stop condition detected, stop condition detected
Group_2_Item_13_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x08)&0x08)?1:0);
Group_2_Item_14_Name = AF
Group_2_Item_14_Comment = "Bit 4 = AF: Acknowledge failure.\nThis bit is set by hardware when no acknowledge is returned. An interrupt is generated if ITE=1. It is cleared by software by reading I2Cn_SR2 register or by hardware when the interface is disabled (PE=0).\nThe SCL line is not held low while AF=1.\n•0: No acknowledge failure\n•1: Acknowledge failure"
Group_2_Item_14_Type = 1, no acknowledge failure, acknowledge failure
Group_2_Item_14_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x08)&0x10)?1:0);
Group_2_Item_15_Name = ENDAD
Group_2_Item_15_Comment = "Bit 5 = ENDAD: End of address transmission.\nThis bit is set by hardware when:\n• 7-bit addressing mode: the address byte has been transmitted;\n• 10-bit addressing mode: the MSB and the LSB have been transmitted during the addressing phase.\nWhen the master needs to receive data from the slave, it has to send just the MSB of the slave address once again; hence the ENDAD flag is set, without waiting for the LSB of the address.\nIt is cleared by software by reading SR2 and a following write to the CR or by hardware when the interface is disabled (PE=0).\n•0: No end of address transmission\n•1: End of address transmission"
Group_2_Item_15_Type = 1, no end of address transmission, end of address transmission
Group_2_Item_15_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x08)&0x20)?1:0);
Group_3_Name = Clock Control Registers (CCR, ECCR)
Group_3_Comment= "I2C Clock Control Register (I2Cn_CCR),I2C Extended Clock Control Register (I2Cn_ECCR)."
Group_3_ItemsNumber = 3
Group_3_Item_1_Name = I2C_CCR,I2C_ECCR
Group_3_Item_1_Comment = "Clock Control Registers.\n•Address Offset: 0Ch.\n•Reset value: 00h.\nExtended Clock Control Register (I2Cn_ECCR).\n•Address Offset: 1Ch.\n•Reset value: 00h."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetDWordValue(0, 0xC0002000 +0x0C).toString(16)+", 0x"+GetDWordValue(0, 0xC0002000 +0x1C).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xC0002000 +0x0C,parseInt(GetString())), SetWordValue(0,0xC0002000 +0x1C,parseInt(GetString()));
Group_3_Item_2_Name = CC11-CC0
Group_3_Item_2_Comment = "Bit 6:0 = CC6-CC0: 12-bit clock divider.\nThese bits along with CC11-CC7 of the Extended Clock Control Register select the speed of the bus (fSCL) depending on the I2C mode. They are not cleared when the interface is disabled (PE=0).\n• Standard mode (FM/SM=0): fSCL = 100kHz\nfSCL = fPCLK1/ (2 x [CC11..CC0]+7)\nGiven a certain fPCLK1, it is easy to obtain the right divider factor:\n[CC11..CC0] = ((fPCLK1 / fSCL)-7) / 2 = ((tSCL / tPCLK1) - 7) / 2\n• Fast mode (FM/SM=1): 100kHz<fSCL<400kHz\nfSCL = fPCLK1/ (3 x [CC11..CC0]+9)\nGiven a certain fPCLK1, it is easy to obtain the right divider factor:\n[CC11..CC0] = ((fPCLK1 / fSCL)-9) /3 = ((tSCL / tPCLK1)-9) / 3\nNote The programmed fSCL assumes no load on SCL and SDA lines.\nNote For a correct usage of the divider, [CC11..CC0] must be equal or greater than 0x002(000000000010b). [CC11..CC0] equal to 0x001 (000000000001b) is not admitted.\nNote The acheived speed can have ~2% tolerance.Bit 7-5 = Reserved, always read as 0."
Group_3_Item_2_Type = 0
Group_3_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0, 0xC0002000 +0x1C)<<7)|(GetDWordValue(0, 0xC0002000 +0x0C)&0x7F)).toString(16));
Group_3_Item_2_DecodingProc = {SetDWordValue(0, 0xC0002000 +0x0C, (parseInt(GetString())&0x7F)|(GetDWordValue(0, 0xC0002000 +0x0C)&0x80));SetDWordValue(0, 0xC0002000 +0x1C, parseInt(GetString())>>7);}
Group_3_Item_3_Name = FM/SM
Group_3_Item_3_Comment = "Bit 7 = FM/SM: Fast/Standard I2C mode.\nThis bit is set and cleared by software. It is not cleared when the interface is disabled (PE=0).\n•0: Standard I2C mode\n•1: Fast I2C mode"
Group_3_Item_3_Type = "1, standard I²C mode, fast I²C mode"
Group_3_Item_3_CodingProc = SetInt((GetDWordValue(0, 0xC0002000 +0x0C)&0x80)?1:0);
Group_3_Item_3_DecodingProc = SetDWordValue(0, 0xC0002000 +0x0C, (GetInt()?0x80:0)|(GetDWordValue(0,0xC000200C)&~0x80));
Group_4_Name = Own Address Registers (OAR1, OAR2)
Group_4_Comment= "I2C Own Address Register 1 (I2Cn_OAR1).\n•Address Offset: 10h.\n•Reset value: 00h.\nI2C Own Address Register 2 (I2Cn_OAR2).\n•Address Offset: 14h.\n•Reset value: 20h."
Group_4_ItemsNumber = 3
Group_4_Item_1_Name = I2C_OAR1,I2C_OAR2
Group_4_Item_1_Comment = "•Bit 4:3 = Reserved, always read as 0."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+GetDWordValue(0, 0xC0002000 +0x10).toString(16)+", 0x"+GetDWordValue(0, 0xC0002000 +0x14).toString(16));
Group_4_Item_1_DecodingProc = SetWordValue(0,0xC0002000 +0x10,parseInt(GetString())), SetWordValue(0,0xC0002000 +0x14,parseInt(GetString()));
Group_4_Item_2_Name = ADD9-ADD0
Group_4_Item_2_Comment = "ADD9-ADD0: Interface address.\nThese are the least significant bits of the I2C bus address of the interface. They are not cleared when the interface is disabled (PE=0).Group_4_Item_1_Type = 0"
Group_4_Item_2_Type = 0
Group_4_Item_2_CodingProc = SetString("0x"+(((GetDWordValue(0, 0xC0002000 +0x14)&0x06)<<7)|GetDWordValue(0, 0xC0002000 +0x10)).toString(16));
Group_4_Item_2_DecodingProc = {SetDWordValue(0, 0xC0002000 +0x14, ((parseInt(GetString())>>7)&0x06)|(GetDWordValue(0, 0xC0002000 +0x0C)&~0x06));SetDWordValue(0, 0xC0002000 +0x1C, parseInt(GetString())>>7);}
Group_4_Item_3_Name = FR2-FR0
Group_4_Item_3_Comment = "Bit 7:5 = FR2-FR0: Frequency bits.\nThese bits are set by software only when the interface is disabled (PE=0). To configure the interface to I2C specified delays select the value corresponding to the system frequency fPCLK1."
Group_4_Item_3_Type = 0
Group_4_Item_3_CodingProc = SetString("0x"+(GetDWordValue(0, 0xC0002000 +0x14)>>5).toString(16));
Group_4_Item_3_DecodingProc = SetDWordValue(0, 0xC0002000 +0x14, (parseInt(GetString())<<5)|(GetDWordValue(0, 0xC0002000 +0x0C)&~0xE0));
Group_5_Name = Data Register (DR)
Group_5_Comment = "I2C Data Register (I2Cn_DR)."
Group_5_ItemsNumber = 2
Group_5_Item_1_Name = I2C_DR
Group_5_Item_1_Comment = "Data Register.\n•Address Offset: 18h.\n•Reset value: 00h."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+GetDWordValue(0, 0xC0002000 +0x18).toString(16));
Group_5_Item_1_DecodingProc = SetWordValue(0,0xC0002000 +0x18,parseInt(GetString()));
Group_5_Item_2_Name = DR
Group_5_Item_2_Comment = "Bit 7:0 = D7-D0: 8-bit Data Register.\nThese bits contain the byte to be received or transmitted on the bus.\n• Transmitter mode: Byte transmission start automatically when the software writes in the I2Cn_DR register.\n• Receiver mode: the first data byte is received automatically in the I2Cn_DR register using the least significant bit of the address. Then, the following data bytes are received one by one after reading the I2Cn_DR register."
Group_5_Item_2_Type = 0
Group_5_Item_2_CodingProc = SetString("0x"+GetDWordValue(0, 0xC0002000 +0x18).toString(16));
Group_5_Item_2_DecodingProc = SetDWordValue(0, 0xC0002000 +0x18, parseInt(GetString()));
[ADC]
SegmentsNumber = 1
Segment_1 = ADC_SEG, 32, 0xE0007000, 0x32
SymbsNumber = 6
Symb_1 = ADC_DATA0, 0, 0xE0007000
Symb_2 = ADC_DATA1, 0, 0xE0007008
Symb_3 = ADC_DATA2, 0, 0xE0007010
Symb_4 = ADC_DATA3, 0, 0xE0007018
Symb_5 = ADC_CSR, 0, 0xE0007020
Symb_6 = ADC_CPR, 0, 0xE0007030
ResetCode = {SetWordValue(0,0xE0007000,0x00);SetWordValue(0,0xE0007008,0x00);SetWordValue(0,0xE0007010,0x00);SetWordValue(0,0xE0007018,0x00);SetWordValue(0,0xE0007020,0x00);SetWordValue(0,0xE0007030,0x05);}
GroupsNumber = 6
Group_1_Name = DATA0
Group_1_Comment = "The 11 most significant bits will contain the result of the conversion, while the 5 least significant bits should be ignored. The data registers will be filled in numerical sequence in the round-robin channel mode. In single channel mode, only the selected channel will be updated."
Group_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0007000).toString(16));
Group_1_DecodingProc = SetWordValue(0,0xE0007000,parseInt(GetString()));
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = Data[0-10]
Group_1_Item_1_Type = 0
Group_1_Item_1_Comment = "This read-only register contains the last sampled value on the channel 0."
Group_1_Item_1_CodingProc = SetString("0x"+((GetWordValue(0,0xE0007000)>>5)&0x7FF).toString(16));
Group_2_Name = DATA1
Group_2_Comment = "The 11 most significant bits will contain the result of the conversion, while the 5 least significant bits should be ignored. The data registers will be filled in numerical sequence in the round-robin channel mode. In single channel mode, only the selected channel will be updated."
Group_2_CodingProc = SetString("0x"+GetWordValue(0,0xE0007008).toString(16));
Group_2_DecodingProc = SetWordValue(0,0xE0007008,parseInt(GetString()));
Group_2_ItemsNumber = 1
Group_2_Item_1_Name = Data[0-10]
Group_2_Item_1_Type = 0
Group_2_Item_1_Comment = "This read-only register contains the last sampled value on the channel 1."
Group_2_Item_1_CodingProc = SetString("0x"+((GetWordValue(0,0xE0007008)>>5)&0x7FF).toString(16));
Group_3_Name = DATA2
Group_3_Comment = "The 11 most significant bits will contain the result of the conversion, while the 5 least significant bits should be ignored. The data registers will be filled in numerical sequence in the round-robin channel mode. In single channel mode, only the selected channel will be updated."
Group_3_CodingProc = SetString("0x"+GetWordValue(0,0xE0007010).toString(16));
Group_3_DecodingProc = SetWordValue(0,0xE0007010,parseInt(GetString()));
Group_3_ItemsNumber = 1
Group_3_Item_1_Name = Data[0-10]
Group_3_Item_1_Type = 0
Group_3_Item_1_Comment = "This read-only register contains the last sampled value on the channel 2."
Group_3_Item_1_CodingProc = SetString("0x"+((GetWordValue(0,0xE0007010)>>5)&0x7FF).toString(16));
Group_4_Name = DATA3
Group_4_Comment = "The 11 most significant bits will contain the result of the conversion, while the 5 least significant bits should be ignored. The data registers will be filled in numerical sequence in the round-robin channel mode. In single channel mode, only the selected channel will be updated."
Group_4_CodingProc = SetString("0x"+GetWordValue(0,0xE0007018).toString(16));
Group_4_DecodingProc = SetWordValue(0,0xE0007018,parseInt(GetString()));
Group_4_ItemsNumber = 1
Group_4_Item_1_Name = Data[0-10]
Group_4_Item_1_Type = 0
Group_4_Item_1_Comment = "This read-only register contains the last sampled value on the channel 3."
Group_4_Item_1_CodingProc = SetString("0x"+((GetWordValue(0,0xE0007018)>>5)&0x7FF).toString(16));
Group_5_Name = Control/Status Register (CSR)
Group_5_Comment = "This register controls the operating mode of the ADC, sets the interrupt enables, contains status flags for the availability of data and error flags in the event of data being overwritten before being read."
Group_5_ItemsNumber = 12
Group_5_Item_1_Name = CSR
Group_5_Item_1_Type = 0
Group_5_Item_1_Comment = "ADC Control/Status Register (ADC_CSR).\n•Address Offset: 20h.\n•Reset Value: 0000h."
Group_5_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0007020).toString(16));
Group_5_Item_1_DecodingProc = SetWordValue(0,0xE0007020,parseInt(GetString()));
Group_5_Item_2_Name = DA0
Group_5_Item_2_Type = 1, no sample, sample available
Group_5_Item_2_Comment = "This bit is set by hardware as soon as a new sample is available on channel 0 and must be cleared by software by explicitly writing it to “0”. Writing it to “1” has no effect. This bit also acts as interrupt flags for the channel 0."
Group_5_Item_2_CodingProc = SetInt((GetWordValue(0,0xE0007020)&0x0001)?1:0);
Group_5_Item_2_DecodingProc = SetWordValue(0,0xE0007020,(GetInt()?0x0001:0)|(GetWordValue(0,0xE0007020)&~0x0001));
Group_5_Item_3_Name = DA1
Group_5_Item_3_Type = 1, no sample, available
Group_5_Item_3_Comment = "This bit is set by hardware as soon as a new sample is available on channel 1 and must be cleared by software by explicitly writing it to “0”. Writing it to “1” has no effect. This bit also acts as interrupt flags for the channel 1."
Group_5_Item_3_CodingProc = SetInt((GetWordValue(0,0xE0007020)&0x0002)?1:0);
Group_5_Item_3_DecodingProc = SetWordValue(0,0xE0007020,(GetInt()?0x0002:0)|(GetWordValue(0,0xE0007020)&~0x0002));
Group_5_Item_4_Name = DA2
Group_5_Item_4_Type = 1, no sample, available
Group_5_Item_4_Comment = "This bit is set by hardware as soon as a new sample is available on channel 2 and must be cleared by software by explicitly writing it to “0”. Writing it to “1” has no effect. This bit also acts as interrupt flags for the channel 2."
Group_5_Item_4_CodingProc = SetInt((GetWordValue(0,0xE0007020)&0x0004)?1:0);
Group_5_Item_4_DecodingProc = SetWordValue(0,0xE0007020,(GetInt()?0x0004:0)|(GetWordValue(0,0xE0007020)&~0x0004));
Group_5_Item_5_Name = DA3
Group_5_Item_5_Type = 1, no sample, available
Group_5_Item_5_Comment = "This bit is set by hardware as soon as a new sample is available on channel 3 and must be cleared by software by explicitly writing it to “0”. Writing it to “1” has no effect. This bit also acts as interrupt flags for the channel 3."
Group_5_Item_5_CodingProc = SetInt((GetWordValue(0,0xE0007020)&0x0008)?1:0);
Group_5_Item_5_DecodingProc = SetWordValue(0,0xE0007020,(GetInt()?0x0008:0)|(GetWordValue(0,0xE0007020)&~0x0008));
Group_5_Item_6_Name = Selected channel
Group_5_Item_6_Type = 1, AIN0, AIN1, AIN2, AIN3
Group_5_Item_6_Comment = "These bits select the external channel to be sampled when external addressing is enabled."
Group_5_Item_6_CodingProc = SetInt((GetWordValue(0,0xE0007020)&0x0030)>>4)
Group_5_Item_6_DecodingProc = SetWordValue(0,0xE0007020,(GetInt()<<4)|(GetWordValue(0,0xE0007020)&~0x0030));
Group_5_Item_7_Name = AXT
Group_5_Item_7_Type = 1, round-robin, single channel
Group_5_Item_7_Comment = "This bit allows to enable the single-channel operation, configuring the ADC to convert repeatedly the channel identified by A[1:0] bits of this register.\n•0: Round-robin addressing enabled.\n•1: Single-channel addressing enabled."
Group_5_Item_7_CodingProc = SetInt((GetWordValue(0,0xE0007020)&0x0040)?1:0);
Group_5_Item_7_DecodingProc = SetWordValue(0,0xE0007020,(GetInt()?0x0040:0)|(GetWordValue(0,0xE0007020)&~0x0040));
Group_5_Item_8_Name = IE0
Group_5_Item_8_Type = 1, disabled, enabled
Group_5_Item_8_Comment = "This bit allows to enable interrupt requests independently for the ADC channel 0."
Group_5_Item_8_CodingProc = SetInt((GetWordValue(0,0xE0007020)&0x100)?1:0);
Group_5_Item_8_DecodingProc = SetWordValue(0,0xE0007020,(GetInt()?0x100:0)|(GetWordValue(0,0xE0007020)&~0x100));
Group_5_Item_9_Name = IE1
Group_5_Item_9_Type = 1, disabled, enabled
Group_5_Item_9_Comment = "This bit allows to enable interrupt requests independently for the ADC channel 1."
Group_5_Item_9_CodingProc = SetInt((GetWordValue(0,0xE0007020)&0x200)?1:0);
Group_5_Item_9_DecodingProc = SetWordValue(0,0xE0007020,(GetInt()?0x200:0)|(GetWordValue(0,0xE0007020)&~0x200));
Group_5_Item_10_Name = IE2
Group_5_Item_10_Type = 1, disabled, enabled
Group_5_Item_10_Comment = "This bit allows to enable interrupt requests independently for the ADC channel 2."
Group_5_Item_10_CodingProc = SetInt((GetWordValue(0,0xE0007020)&0x400)?1:0);
Group_5_Item_10_DecodingProc = SetWordValue(0,0xE0007020,(GetInt()?0x400:0)|(GetWordValue(0,0xE0007020)&~0x400));
Group_5_Item_11_Name = IE3
Group_5_Item_11_Type = 1, disabled, enabled
Group_5_Item_11_Comment = "This bit allows to enable interrupt requests independently for the ADC channel 3."
Group_5_Item_11_CodingProc = SetInt((GetWordValue(0,0xE0007020)&0x800)?1:0);
Group_5_Item_11_DecodingProc = SetWordValue(0,0xE0007020,(GetInt()?0x800:0)|(GetWordValue(0,0xE0007020)&~0x800));
Group_5_Item_12_Name = OR
Group_5_Item_12_Type = 1, normal, overrun occurred
Group_5_Item_12_Comment = "This read-write bit is used to notify application software that data on one of the channels has been overwritten before being read. This bit is set by hardware as soon as an overrun condition is detected and must be cleared by software by explicitly writing it to “0”."
Group_5_Item_12_CodingProc = SetInt((GetWordValue(0,0xE0007020)&0x2000)?1:0);
Group_5_Item_12_DecodingProc = SetWordValue(0,0xE0007020,(GetInt()?0x2000:0)|(GetWordValue(0,0xE0007020)&~0x2000));
Group_6_Name = Clock Prescaler Register
Group_6_ItemsNumber = 1
Group_6_Comment = "The 12-bit value specified on the prescaler register determines the factor by which the ADC input clock will be divided down in order to produce the oversampling clock of the sigma-delta modulator, the actual factor being twice the PRESC register value. The value placed in this register must subsequently generate an oversampling clock frequency not greater than 2.5 MHz from the PCLK2 clock applied to the ADC. These bits can only be written, any read operation on them returns 0."
Group_6_Item_1_Name = CPR
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0007030).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xE0007030,parseInt(GetString()));
Group_6_Item_1_Comment = "ADC Clock Prescaler Register (ADC_CPR).\n•Address Offset: 30h.\n•Reset Value: 05h."
[EIC]
SegmentsNumber = 1
Segment_1 = EIC_SEG, 32, 0xFFFFF800, 0xE0
SymbsNumber = 75
Symb_1 = EIC_ICR, 0, 0xFFFFF800
Symb_2 = EIC_CICR, 0, 0xFFFFF804
Symb_3 = EIC_CIPR, 0, 0xFFFFF808
Symb_4 = EIC_IVR, 0, 0xFFFFF818
Symb_5 = EIC_FIR, 0, 0xFFFFF81C
Symb_6 = EIC_IER, 0, 0xFFFFF820
Symb_7 = EIC_IPR, 0, 0xFFFFF840
Symb_8 = EIC_SIR0, 0, 0xFFFFF860
Symb_9 = EIC_SIR1, 0, 0xFFFFF864
Symb_10 = EIC_SIR2, 0, 0xFFFFF868
Symb_11 = EIC_SIR3, 0, 0xFFFFF86C
Symb_12 = EIC_SIR4, 0, 0xFFFFF870
Symb_13 = EIC_SIR5, 0, 0xFFFFF874
Symb_14 = EIC_SIR6, 0, 0xFFFFF878
Symb_15 = EIC_SIR7, 0, 0xFFFFF87C
Symb_16 = EIC_SIR8, 0, 0xFFFFF880
Symb_17 = EIC_SIR9, 0, 0xFFFFF884
Symb_18 = EIC_SIR10, 0, 0xFFFFF888
Symb_19 = EIC_SIR11, 0, 0xFFFFF88C
Symb_20 = EIC_SIR12, 0, 0xFFFFF890
Symb_21 = EIC_SIR13, 0, 0xFFFFF894
Symb_22 = EIC_SIR14, 0, 0xFFFFF898
Symb_23 = EIC_SIR15, 0, 0xFFFFF89C
Symb_24 = EIC_SIR16, 0, 0xFFFFF8A0
Symb_25 = EIC_SIR17, 0, 0xFFFFF8A4
Symb_26 = EIC_SIR18, 0, 0xFFFFF8A8
Symb_27 = EIC_SIR19, 0, 0xFFFFF8AC
Symb_28 = EIC_SIR20, 0, 0xFFFFF8B0
Symb_29 = EIC_SIR21, 0, 0xFFFFF8B4
Symb_30 = EIC_SIR22, 0, 0xFFFFF8B8
Symb_31 = EIC_SIR23, 0, 0xFFFFF8BC
Symb_32 = EIC_SIR24, 0, 0xFFFFF8C0
Symb_33 = EIC_SIR25, 0, 0xFFFFF8C4
Symb_34 = EIC_SIR26, 0, 0xFFFFF8C8
Symb_35 = EIC_SIR27, 0, 0xFFFFF8CC
Symb_36 = EIC_SIR28, 0, 0xFFFFF8D0
Symb_37 = EIC_SIR29, 0, 0xFFFFF8D4
Symb_38 = EIC_SIR30, 0, 0xFFFFF8D8
Symb_39 = EIC_SIR31, 0, 0xFFFFF8DC
ResetCode = { var i; var initaddr_array = new Array(0x00,0x04,0x08,0x10,0x14,0x18,0x1C,0x20,0x24,0x40,0x44,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80,0x84,0x88,0x8C,0x90,0x94,0x98,0x9C,0xA0,0xA4,0xA8,0xAC,0xB0,0xB4,0xB8,0xBC,0xC0,0xC4,0xC8,0xCC,0xD0,0xD4,0xD8,0xDC,0xE0,0xE4,0xE8,0xEC,0xF0,0xF4,0xF8,0xFC,0x100,0x104,0x108,0x10C,0x110,0x114,0x118,0x11C,0x120,0x124,0x128,0x12C,0x130,0x134,0x138,0x13C,0x140,0x144,0x148,0x14C,0x150,0x154,0x158,0x15C); for (i = 0; i < 75; i++) {SetDWordValue(0,0xFFFFF800 +initaddr_array[i],0x00);} }
GroupsNumber = 75
Group_1_Name = Interrupt Control Register (EIC_ICR)
Group_1_Comment = "Interrupt Control Register (EIC_ICR).\n•Address Offset: 00h.\n•Reset value: 0000 0000h.\n•Bit 31:2 Reserved, always read as 0.\nThis Register is used to control the interrupt"
Group_1_ItemsNumber = 2
Group_1_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF800).toString(16));
Group_1_Item_1_Name = IRQ_EN
Group_1_Item_1_Comment = "Bit 0 = IRQ output Enable bit\n•0: Enhanced Interrupt Controller IRQ output request to CPU is disabled,even if the EIC has detected valid and enabled interrupt requests at its inputs.\n•1: Enhanced Interrupt Controller IRQ output request to CPU is enabled.\nSoftware can read and write to this bit."
Group_1_Item_1_Type = 1,disabled,enabled
Group_1_Item_1_CodingProc = SetInt((GetDWordValue(0,0xFFFFF800)&1)?1:0);
Group_1_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF800,(GetInt()?1:0)|(GetDWordValue(0,0xFFFFF800)&~1));
Group_1_Item_2_Name = FIQ_EN
Group_1_Item_2_Comment = "Bit 1 = FIQ output Enable bit.\n•0: Enhanced Interrupt Controller FIQ output request to CPU is disabled,even if the EIC has detected valid and enabled fast interrupt requests at its inputs.\n•1: Enhanced Interrupt Controller FIQ output request to CPU is enabled.\nSoftware can read and write to this bit."
Group_1_Item_2_Type = 1,disabled,enabled
Group_1_Item_2_CodingProc = SetInt((GetDWordValue(0,0xFFFFF800)&2)?1:0);
Group_1_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF800,(GetInt()?1:0)|(GetDWordValue(0,0xFFFFF800)&~2));
Group_2_Name = Current Interrupt Channel Register (EIC_CICR)
Group_2_Comment = "Current Interrupt Channel Register (EIC_CICR).\n•Address Offset: 04h.\n•Reset value: 0000 0000h.\n•Bit 31:5 Reserved, always read as 0.\nThe EIC_CICR reports the number of the interrupt channel currently being serviced."
Group_2_ItemsNumber = 1
Group_2_CodingProc = SetString("0x"+GetDWordValue(0, 0xFFFFF804).toString(16));
Group_2_Item_1_Name = CIC
Group_2_Item_1_Comment = "Bit 4:0 = CIC[4:0]: Current Interrupt Channel\nNumber of the interrupts whose service routine is currently in execution phase. These are read-only bits."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF804)&0x001F).toString(16));
Group_3_Name = Current Interrupt Priority Register (EIC_CIPR)
Group_3_Comment = "Current Interrupt Priority Register (EIC_CIPR).\n•Address Offset: 08h.\n•Reset value: 0000 0000h.\n•Bit 31:4 Reserved, always read as 0.\nThe EIC_CIPR register reports the priority value of the interrupt currently being serviced."
Group_3_ItemsNumber = 1
Group_3_CodingProc = SetString("0x"+GetDWordValue(0, 0xFFFFF808).toString(16));
Group_3_Item_1_Name = CIP
Group_3_Item_1_Comment = "Bit 3:0 = CIP[3:0]: Current Interrupt Priority\nPriority value of the interrupt which is currently in execution phase. The software can read and write to these bits."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF808)&0x000F).toString(16));
Group_3_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF808,(parseInt(GetString()))|(GetDWordValue(0,0xFFFFF808)&~0x000F));
Group_4_Name = Interrupt Vector Register (EIC_IVR)
Group_4_Comment = "Interrupt Vector Register (EIC_IVR).\n•Address Offset: 18h.\n•Reset value: 0000 0000h.\nThe EIC_IVR read operation informs the EIC that the interrupt service routine (ISR) corresponding to the pending request has been initiated."
Group_4_ItemsNumber = 2
Group_4_CodingProc = SetString("0x"+GetDWordValue(0, 0xFFFFF818).toString(16));
Group_4_Item_1_Name = IVRL
Group_4_Item_1_Comment = "Bit 15:0 = IVR(15:0): Interrupt Vector (Low portion)\nThis register value depends on the interrupts to be serviced, and it is a copy of the Source Interrupt Vector (SIV) value of the EIC_SIR corresponding to the channel to be serviced. These are read only bits."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF818)&0x0000FFFF).toString(16));
Group_4_Item_2_Name = IVRH
Group_4_Item_2_Comment = "Bit 31:16 = IVR(31:16): Interrupt Vector (High portion)\nThis register value does not depend on the interrupts to be serviced. It has to be programmed by the user (see Note) at the time of initialization. It is common to all the interrupt channels. Software can read and write to these bits."
Group_4_Item_2_Type = 0
Group_4_Item_2_CodingProc = SetString("0x"+( ( (GetDWordValue(0,0xFFFFF818)&0xFFFF0000)>>16 ) & 0xFFFF ).toString(16));
Group_4_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF818,(parseInt(GetString())<<16)|(GetDWordValue(0,0xFFFFF818)&~0xFFFF0000));
Group_5_Name = Fast Interrupt Register (EIC_FIR)
Group_5_Comment = "Fast Interrupt Register (EIC_FIR).\n•Address Offset: 1Ch.\n•Reset value: 0000 0000h."
Group_5_ItemsNumber = 4
Group_5_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF81C).toString(16));
Group_5_Item_1_Name = FIE0
Group_5_Item_1_Comment = "Bit 0 = FIE[0]: FIQ Channel 0 Interrupt Enable bit\nIn order to have the controller responding to a FIQ on a specific channel, the corresponding FIE bit must be set.\n•0: Fast Interrupt request on FIQ channel n disabled.\n•1: Fast Interrupt request on FIQ channel n enabled."
Group_5_Item_1_Type = 1,disabled,enabled
Group_5_Item_1_CodingProc = SetInt((GetDWordValue(0,0xFFFFF81C)&0x0001)?1:0);
Group_5_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF81C,(GetInt()?0x0001:0)|(GetDWordValue(0,0xFFFFF81C)&~0x0001));
Group_5_Item_2_Name = FIE1
Group_5_Item_2_Comment = "Bit 1 = FIE[1]: FIQ Channel 1 Interrupt Enable bit\nIn order to have the controller responding to a FIQ on a specific channel, the corresponding FIE bit must be set.\n•0: Fast Interrupt request on FIQ channel n disabled.\n•1: Fast Interrupt request on FIQ channel n enabled."
Group_5_Item_2_Type = 1,disabled,enabled
Group_5_Item_2_CodingProc = SetInt((GetDWordValue(0,0xFFFFF81C)&0x0002)?1:0);
Group_5_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF81C,(GetInt()?0x0002:0)|(GetDWordValue(0,0xFFFFF81C)&~0x0002));
Group_5_Item_3_Name = FIP0
Group_5_Item_3_Comment = "Bit 2 = FIP[0]: Channel 0 Fast Interrupt Pending Bit\nThis bit is set by hardware by a Fast interrupt request on the corresponding channel. These bits are cleared only by software, i.e. writing a ‘0’ has no effect, whereas writing a ‘1’ clears the bit (forces it to ‘0’).\n•0: No Fast interrupt pending on channel n.\n•1: Fast Interrupt pending on channel n."
Group_5_Item_3_Type = 1,no fast interrupt,fast interrupt
Group_5_Item_3_CodingProc = SetInt((GetDWordValue(0,0xFFFFF81C)&0x0004)?1:0);
Group_5_Item_3_DecodingProc = SetDWordValue(0,0xFFFFF81C,(GetInt()?0x0004:0)|(GetDWordValue(0,0xFFFFF81C)&~0x0004));
Group_5_Item_4_Name = FIP1
Group_5_Item_4_Comment = "Bit 3 = FIP[1]: Channel 1 Fast Interrupt Pending Bit\nThis bit is set by hardware by a Fast interrupt request on the corresponding channel. These bits are cleared only by software, i.e. writing a ‘0’ has no effect, whereas writing a ‘1’ clears the bit (forces it to ‘0’).\n•0: No Fast interrupt pending on channel n.\n•1: Fast Interrupt pending on channel n."
Group_5_Item_4_Type = 1,no fast interrupt,fast interrupt
Group_5_Item_4_CodingProc = SetInt((GetDWordValue(0,0xFFFFF81C)&0x0008)?1:0);
Group_5_Item_4_DecodingProc = SetDWordValue(0,0xFFFFF81C,(GetInt()?0x0008:0)|(GetDWordValue(0,0xFFFFF81C)&~0x0008));
Group_6_Name = Interrupt Enable Register 0 (EIC_IER0)
Group_6_Comment = "Interrupt Enable Register 0 (EIC_IER0).\n•Address Offset: 20h.\n•Reset value: 0000 0000h.\nThe EIC_IER0 is a 32 bit register: it provides an enable bit for each of the 32 EIC interrupt input channels."
Group_6_ItemsNumber = 1
Group_6_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF820).toString(16));
Group_6_Item_1_Name = IER
Group_6_Item_1_Comment = " Bit 31:0 = IER[31:0]: Channel 31 to 0 Interrupt Enable bits\nIn order to enable the interrupt response to a specific interrupt input channel,the corresponding bit in the EIC_IER0 register must be set to ‘1’.A ‘0’ value prevents the corresponding pending bit geing set.\n•0: Input channel disabled.\n•1: Input channel enabled."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF820).toString(16));
Group_6_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF820,parseInt(GetString()));
Group_7_Name = Interrupt Pending Register 0 (EIC_IPR0)
Group_7_Comment = "Interrupt Pending Register 0 (EIC_IPR0).\n•Address Offset: 40h.\n•Reset value: 0000 0000h.\nThe EIC_IPR0 is a 32 bit register, which provides a pending bit for each of the 32 EIC interrupt input channels."
Group_7_ItemsNumber = 2
Group_7_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF840).toString(16));
Group_7_Item_1_Name = IPR
Group_7_Item_1_Comment = "Bit 31:0 = IPR[31:0]: Channel 31 to 0 Interrupt Pending bit\nThis is where the information about the channel interrupt status is kept. If the corresponding bit in the enable register EIC_IER0 has been set, the EIC_IPR0 bit set high implies that the related channel has asserted an interrupt request that has not been serviced yet.\nThe bits are Read/Clear, i.e. writing a ‘0’ has no effect, whereas writing a ‘1’ clears the bit.\n•0: No interrupt pending.\n•1: Interrupt pending."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF840).toString(16));
Group_7_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF840,parseInt(GetString()));
Group_8_Name = Source Interrupt Registers(EIC_SIR0)
Group_8_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_8_ItemsNumber = 2
Group_8_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF860).toString(16));
Group_8_Item_1_Name = SIPL
Group_8_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_8_Item_1_Type =0
Group_8_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF860)&0x000F).toString(16));
Group_8_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF860,parseInt(GetString()));
Group_8_Item_2_Name = SIV
Group_8_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_8_Item_2_Type = 0
Group_8_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF860)&0xFFFF0000)>>16).toString(16));
Group_8_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF860,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_9_Name = Source Interrupt Registers(EIC_SIR1)
Group_9_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_9_ItemsNumber = 2
Group_9_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF864).toString(16));
Group_9_Item_1_Name = SIPL
Group_9_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_9_Item_1_Type =0
Group_9_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF864)&0x000F).toString(16));
Group_9_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF864,parseInt(GetString()));
Group_9_Item_2_Name = SIV
Group_9_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_9_Item_2_Type = 0
Group_9_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF864)&0xFFFF0000)>>16).toString(16));
Group_9_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF864,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_10_Name = Source Interrupt Registers(EIC_SIR2)
Group_10_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_10_ItemsNumber = 2
Group_10_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF868).toString(16));
Group_10_Item_1_Name = SIPL
Group_10_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_10_Item_1_Type =0
Group_10_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF868)&0x000F).toString(16));
Group_10_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF868,parseInt(GetString()));
Group_10_Item_2_Name = SIV
Group_10_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_10_Item_2_Type = 0
Group_10_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF868)&0xFFFF0000)>>16).toString(16));
Group_10_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF868,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_11_Name = Source Interrupt Registers(EIC_SIR3)
Group_11_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_11_ItemsNumber = 2
Group_11_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF86C).toString(16));
Group_11_Item_1_Name = SIPL
Group_11_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_11_Item_1_Type =0
Group_11_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF86C)&0x000F).toString(16));
Group_11_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF86C,parseInt(GetString()));
Group_11_Item_2_Name = SIV
Group_11_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_11_Item_2_Type = 0
Group_11_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF86C)&0xFFFF0000)>>16).toString(16));
Group_11_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF86C,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_12_Name = Source Interrupt Registers(EIC_SIR4)
Group_12_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_12_ItemsNumber = 2
Group_12_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF870).toString(16));
Group_12_Item_1_Name = SIPL
Group_12_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_12_Item_1_Type =0
Group_12_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF870)&0x000F).toString(16));
Group_12_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF870,parseInt(GetString()));
Group_12_Item_2_Name = SIV
Group_12_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_12_Item_2_Type = 0
Group_12_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF870)&0xFFFF0000)>>16).toString(16));
Group_12_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF870,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_13_Name = Source Interrupt Registers(EIC_SIR5)
Group_13_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_13_ItemsNumber = 2
Group_13_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF874).toString(16));
Group_13_Item_1_Name = SIPL
Group_13_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_13_Item_1_Type =0
Group_13_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF874)&0x000F).toString(16));
Group_13_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF874,parseInt(GetString()));
Group_13_Item_2_Name = SIV
Group_13_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_13_Item_2_Type = 0
Group_13_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF874)&0xFFFF0000)>>16).toString(16));
Group_13_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF874,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_14_Name = Source Interrupt Registers(EIC_SIR6)
Group_14_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_14_ItemsNumber = 2
Group_14_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF878).toString(16));
Group_14_Item_1_Name = SIPL
Group_14_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_14_Item_1_Type =0
Group_14_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF878)&0x000F).toString(16));
Group_14_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF878,parseInt(GetString()));
Group_14_Item_2_Name = SIV
Group_14_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_14_Item_2_Type = 0
Group_14_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF878)&0xFFFF0000)>>16).toString(16));
Group_14_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF878,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_15_Name = Source Interrupt Registers(EIC_SIR7)
Group_15_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_15_ItemsNumber = 2
Group_15_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF87C).toString(16));
Group_15_Item_1_Name = SIPL
Group_15_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_15_Item_1_Type =0
Group_15_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF87C)&0x000F).toString(16));
Group_15_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF87C,parseInt(GetString()));
Group_15_Item_2_Name = SIV
Group_15_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_15_Item_2_Type = 0
Group_15_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF87C)&0xFFFF0000)>>16).toString(16));
Group_15_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF87C,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_16_Name = Source Interrupt Registers(EIC_SIR8)
Group_16_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_16_ItemsNumber = 2
Group_16_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF880).toString(16));
Group_16_Item_1_Name = SIPL
Group_16_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_16_Item_1_Type =0
Group_16_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF880)&0x000F).toString(16));
Group_16_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF880,parseInt(GetString()));
Group_16_Item_2_Name = SIV
Group_16_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_16_Item_2_Type = 0
Group_16_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF880)&0xFFFF0000)>>16).toString(16));
Group_16_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF880,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_17_Name = Source Interrupt Registers(EIC_SIR9)
Group_17_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_17_ItemsNumber = 2
Group_17_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF884).toString(16));
Group_17_Item_1_Name = SIPL
Group_17_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_17_Item_1_Type =0
Group_17_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF884)&0x000F).toString(16));
Group_17_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF884,parseInt(GetString()));
Group_17_Item_2_Name = SIV
Group_17_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_17_Item_2_Type = 0
Group_17_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF884)&0xFFFF0000)>>16).toString(16));
Group_17_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF884,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_18_Name = Source Interrupt Registers(EIC_SIR10)
Group_18_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_18_ItemsNumber = 2
Group_18_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF888).toString(16));
Group_18_Item_1_Name = SIPL
Group_18_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_18_Item_1_Type =0
Group_18_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF888)&0x000F).toString(16));
Group_18_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF888,parseInt(GetString()));
Group_18_Item_2_Name = SIV
Group_18_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_18_Item_2_Type = 0
Group_18_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF888)&0xFFFF0000)>>16).toString(16));
Group_18_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF888,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_19_Name = Source Interrupt Registers(EIC_SIR11)
Group_19_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_19_ItemsNumber = 2
Group_19_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF88C).toString(16));
Group_19_Item_1_Name = SIPL
Group_19_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_19_Item_1_Type =0
Group_19_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF88C)&0x000F).toString(16));
Group_19_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF88C,parseInt(GetString()));
Group_19_Item_2_Name = SIV
Group_19_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_19_Item_2_Type = 0
Group_19_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF88C)&0xFFFF0000)>>16).toString(16));
Group_19_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF88C,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_20_Name = Source Interrupt Registers(EIC_SIR12)
Group_20_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_20_ItemsNumber = 2
Group_20_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF890).toString(16));
Group_20_Item_1_Name = SIPL
Group_20_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_20_Item_1_Type =0
Group_20_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF890)&0x000F).toString(16));
Group_20_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF890,parseInt(GetString()));
Group_20_Item_2_Name = SIV
Group_20_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_20_Item_2_Type = 0
Group_20_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF890)&0xFFFF0000)>>16).toString(16));
Group_20_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF890,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_21_Name = Source Interrupt Registers(EIC_SIR13)
Group_21_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_21_ItemsNumber = 2
Group_21_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF894).toString(16));
Group_21_Item_1_Name = SIPL
Group_21_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_21_Item_1_Type =0
Group_21_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF894)&0x000F).toString(16));
Group_21_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF894,parseInt(GetString()));
Group_21_Item_2_Name = SIV
Group_21_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_21_Item_2_Type = 0
Group_21_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF894)&0xFFFF0000)>>16).toString(16));
Group_21_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF894,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_22_Name = Source Interrupt Registers(EIC_SIR14)
Group_22_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_22_ItemsNumber = 2
Group_22_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF898).toString(16));
Group_22_Item_1_Name = SIPL
Group_22_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_22_Item_1_Type =0
Group_22_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF898)&0x000F).toString(16));
Group_22_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF898,parseInt(GetString()));
Group_22_Item_2_Name = SIV
Group_22_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_22_Item_2_Type = 0
Group_22_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF898)&0xFFFF0000)>>16).toString(16));
Group_22_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF898,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_23_Name = Source Interrupt Registers(EIC_SIR15)
Group_23_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_23_ItemsNumber = 2
Group_23_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF89C).toString(16));
Group_23_Item_1_Name = SIPL
Group_23_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_23_Item_1_Type =0
Group_23_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF89C)&0x000F).toString(16));
Group_23_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF89C,parseInt(GetString()));
Group_23_Item_2_Name = SIV
Group_23_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_23_Item_2_Type = 0
Group_23_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF89C)&0xFFFF0000)>>16).toString(16));
Group_23_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF89C,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_24_Name = Source Interrupt Registers(EIC_SIR16)
Group_24_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_24_ItemsNumber = 2
Group_24_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8A0).toString(16));
Group_24_Item_1_Name = SIPL
Group_24_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_24_Item_1_Type =0
Group_24_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8A0)&0x000F).toString(16));
Group_24_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8A0,parseInt(GetString()));
Group_24_Item_2_Name = SIV
Group_24_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_24_Item_2_Type = 0
Group_24_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8A0)&0xFFFF0000)>>16).toString(16));
Group_24_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8A0,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_25_Name = Source Interrupt Registers(EIC_SIR17)
Group_25_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_25_ItemsNumber = 2
Group_25_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8A4).toString(16));
Group_25_Item_1_Name = SIPL
Group_25_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_25_Item_1_Type =0
Group_25_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8A4)&0x000F).toString(16));
Group_25_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8A4,parseInt(GetString()));
Group_25_Item_2_Name = SIV
Group_25_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_25_Item_2_Type = 0
Group_25_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8A4)&0xFFFF0000)>>16).toString(16));
Group_25_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8A4,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_26_Name = Source Interrupt Registers(EIC_SIR18)
Group_26_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_26_ItemsNumber = 2
Group_26_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8A8).toString(16));
Group_26_Item_1_Name = SIPL
Group_26_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_26_Item_1_Type =0
Group_26_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8A8)&0x000F).toString(16));
Group_26_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8A8,parseInt(GetString()));
Group_26_Item_2_Name = SIV
Group_26_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_26_Item_2_Type = 0
Group_26_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8A8)&0xFFFF0000)>>16).toString(16));
Group_26_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8A8,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_27_Name = Source Interrupt Registers(EIC_SIR19)
Group_27_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_27_ItemsNumber = 2
Group_27_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8AC).toString(16));
Group_27_Item_1_Name = SIPL
Group_27_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_27_Item_1_Type =0
Group_27_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8AC)&0x000F).toString(16));
Group_27_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8AC,parseInt(GetString()));
Group_27_Item_2_Name = SIV
Group_27_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_27_Item_2_Type = 0
Group_27_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8AC)&0xFFFF0000)>>16).toString(16));
Group_27_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8AC,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_28_Name = Source Interrupt Registers(EIC_SIR20)
Group_28_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_28_ItemsNumber = 2
Group_28_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8B0).toString(16));
Group_28_Item_1_Name = SIPL
Group_28_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_28_Item_1_Type =0
Group_28_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8B0)&0x000F).toString(16));
Group_28_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8B0,parseInt(GetString()));
Group_28_Item_2_Name = SIV
Group_28_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_28_Item_2_Type = 0
Group_28_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8B0)&0xFFFF0000)>>16).toString(16));
Group_28_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8B0,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_29_Name = Source Interrupt Registers(EIC_SIR21)
Group_29_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_29_ItemsNumber = 2
Group_29_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8B4).toString(16));
Group_29_Item_1_Name = SIPL
Group_29_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_29_Item_1_Type =0
Group_29_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8B4)&0x000F).toString(16));
Group_29_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8B4,parseInt(GetString()));
Group_29_Item_2_Name = SIV
Group_29_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_29_Item_2_Type = 0
Group_29_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8B4)&0xFFFF0000)>>16).toString(16));
Group_29_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8B4,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_30_Name = Source Interrupt Registers(EIC_SIR22)
Group_30_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_30_ItemsNumber = 2
Group_30_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8B8).toString(16));
Group_30_Item_1_Name = SIPL
Group_30_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_30_Item_1_Type =0
Group_30_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8B8)&0x000F).toString(16));
Group_30_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8B8,parseInt(GetString()));
Group_30_Item_2_Name = SIV
Group_30_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_30_Item_2_Type = 0
Group_30_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8B8)&0xFFFF0000)>>16).toString(16));
Group_30_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8B8,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_31_Name = Source Interrupt Registers(EIC_SIR23)
Group_31_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_31_ItemsNumber = 2
Group_31_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8BC).toString(16));
Group_31_Item_1_Name = SIPL
Group_31_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_31_Item_1_Type =0
Group_31_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8BC)&0x000F).toString(16));
Group_31_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8BC,parseInt(GetString()));
Group_31_Item_2_Name = SIV
Group_31_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_31_Item_2_Type = 0
Group_31_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8BC)&0xFFFF0000)>>16).toString(16));
Group_31_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8BC,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_32_Name = Source Interrupt Registers(EIC_SIR24)
Group_32_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_32_ItemsNumber = 2
Group_32_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8C0).toString(16));
Group_32_Item_1_Name = SIPL
Group_32_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_32_Item_1_Type =0
Group_32_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8C0)&0x000F).toString(16));
Group_32_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8C0,parseInt(GetString()));
Group_32_Item_2_Name = SIV
Group_32_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_32_Item_2_Type = 0
Group_32_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8C0)&0xFFFF0000)>>16).toString(16));
Group_32_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8C0,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_33_Name = Source Interrupt Registers(EIC_SIR25)
Group_33_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_33_ItemsNumber = 2
Group_33_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8C4).toString(16));
Group_33_Item_1_Name = SIPL
Group_33_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_33_Item_1_Type =0
Group_33_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8C4)&0x000F).toString(16));
Group_33_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8C4,parseInt(GetString()));
Group_33_Item_2_Name = SIV
Group_33_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_33_Item_2_Type = 0
Group_33_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8C4)&0xFFFF0000)>>16).toString(16));
Group_33_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8C4,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_34_Name = Source Interrupt Registers(EIC_SIR26)
Group_34_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_34_ItemsNumber = 2
Group_34_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8C8).toString(16));
Group_34_Item_1_Name = SIPL
Group_34_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_34_Item_1_Type =0
Group_34_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8C8)&0x000F).toString(16));
Group_34_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8C8,parseInt(GetString()));
Group_34_Item_2_Name = SIV
Group_34_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_34_Item_2_Type = 0
Group_34_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8C8)&0xFFFF0000)>>16).toString(16));
Group_34_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8C8,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_35_Name = Source Interrupt Registers(EIC_SIR27)
Group_35_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_35_ItemsNumber = 2
Group_35_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8CC).toString(16));
Group_35_Item_1_Name = SIPL
Group_35_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_35_Item_1_Type =0
Group_35_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8CC)&0x000F).toString(16));
Group_35_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8CC,parseInt(GetString()));
Group_35_Item_2_Name = SIV
Group_35_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_35_Item_2_Type = 0
Group_35_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8CC)&0xFFFF0000)>>16).toString(16));
Group_35_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8CC,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_36_Name = Source Interrupt Registers(EIC_SIR28)
Group_36_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_36_ItemsNumber = 2
Group_36_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8D0).toString(16));
Group_36_Item_1_Name = SIPL
Group_36_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_36_Item_1_Type =0
Group_36_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8D0)&0x000F).toString(16));
Group_36_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8D0,parseInt(GetString()));
Group_36_Item_2_Name = SIV
Group_36_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_36_Item_2_Type = 0
Group_36_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8D0)&0xFFFF0000)>>16).toString(16));
Group_36_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8D0,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_37_Name = Source Interrupt Registers(EIC_SIR29)
Group_37_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_37_ItemsNumber = 2
Group_37_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8D4).toString(16));
Group_37_Item_1_Name = SIPL
Group_37_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_37_Item_1_Type =0
Group_37_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8D4)&0x000F).toString(16));
Group_37_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8D4,parseInt(GetString()));
Group_37_Item_2_Name = SIV
Group_37_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_37_Item_2_Type = 0
Group_37_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8D4)&0xFFFF0000)>>16).toString(16));
Group_37_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8D4,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_38_Name = Source Interrupt Registers(EIC_SIR30)
Group_38_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_38_ItemsNumber = 2
Group_38_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8D8).toString(16));
Group_38_Item_1_Name = SIPL
Group_38_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_38_Item_1_Type =0
Group_38_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8D8)&0x000F).toString(16));
Group_38_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8D8,parseInt(GetString()));
Group_38_Item_2_Name = SIV
Group_38_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_38_Item_2_Type = 0
Group_38_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8D8)&0xFFFF0000)>>16).toString(16));
Group_38_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8D8,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
Group_39_Name = Source Interrupt Registers(EIC_SIR31)
Group_39_Comment = "Source Interrupt Registers.\n•Bit 15:4 Reserved, always read as 0."
Group_39_ItemsNumber = 2
Group_39_CodingProc = SetString("0x"+GetDWordValue(0,0xFFFFF8DC).toString(16));
Group_39_Item_1_Name = SIPL
Group_39_Item_1_Comment = "Bit 3:0 = SIPL[3:0]\nThese 4 bits allow to associate the interrupt channel to a priority value between 0 and 15. The reset value is 0."
Group_39_Item_1_Type =0
Group_39_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xFFFFF8DC)&0x000F).toString(16));
Group_39_Item_1_DecodingProc = SetDWordValue(0,0xFFFFF8DC,parseInt(GetString()));
Group_39_Item_2_Name = SIV
Group_39_Item_2_Comment = "Bits 31:16 = SIV[31:16]\nThis field contains the interrupt channel dependent part of the interrupt vector that will be provided to the processor when the EIC_IVR (address 0x18) is read.\nDepending on what the processor expects (32 bit address or opcode, see IVR description), the SIV will have to be loaded with the interrupt channel ISR address offset or with the lower part (including the jump offset) of the first ISR instruction opcode."
Group_39_Item_2_Type = 0
Group_39_Item_2_CodingProc = SetString("0x"+((GetDWordValue(0,0xFFFFF8DC)&0xFFFF0000)>>16).toString(16));
Group_39_Item_2_DecodingProc = SetDWordValue(0,0xFFFFF8DC,(parseInt(GetString()))<<16)|(GetDWordValue(0,EIC_SIR_BASE)&0x0000FFFF));
[XTI]
SegmentsNumber = 1
Segment_1 = ETI_SEG, 32, 0xE0001000, 0x40
SymbsNumber = 8
Symb_1 = ETI_SR, 0, 0xE000101C
Symb_2 = ETI_CTRL, 0, 0xE0001024
Symb_3 = ETI_MRH, 0, 0xE0001028
Symb_4 = ETI_MRL, 0, 0xE000102C
Symb_5 = ETI_TRH, 0, 0xE0001030
Symb_6 = ETI_TRL, 0, 0xE0001034
Symb_7 = ETI_PRH, 0, 0xE0001038
Symb_8 = ETI_PRL, 0, 0xE000103C
ResetCode = {SetWordValue(0,0xE000101C,0x00);SetWordValue(0,0xE0001024,0x00);SetWordValue(0,0xE0001028,0x00);SetWordValue(0,0xE000102C,0x00);SetWordValue(0,0xE0001030,0x00);SetWordValue(0,0xE0001034,0x00);SetWordValue(0,0xE0001038,0x00);SetWordValue(0,0xE000103C,0x00);}
GroupsNumber = 8
Group_1_Name = XTI Software Interrupt Register (XTI_SR)
Group_1_Comment = "XTI Software Interrupt Register (XTI_SR).\n•Address Offset: 1Ch.\n•Reset value: 00h."
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = XTIS
Group_1_Item_1_Comment = "Bit 7:0 = XTIS[7:0]: Software Interrupt Pending Bits.\nThese bits can be set by software to implement a software interrupt.\nThe interrupt routine must clear any pending bits that are set. These interrupts are masked by the global interrupt enable (bit ID1S in XTI_CTRL register) .\n•0: No software interrupt pending.\n•1: Software interrupt pending."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000101C).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xE000101C,parseInt(GetString()));
Group_2_Name = Wake-up Control Register (XTI_CTRL)
Group_2_Comment = "Wake-up Control Register (XTI_CTRL).\n•Address Offset: 24h.\n•Reset value: 00h."
Group_2_ItemsNumber = 3
Group_2_CodingProc = SetString("0x"+(GetWordValue(0,0xE0001024)&0x0007).toString(16));
Group_2_Item_1_Name = WKUP-INT
Group_2_Item_1_Comment = "Bit 0 = WKUP-INT: Wake-up Interrupt.\nThis bit is set and cleared by software.\n•0: The 16 wake-up lines can be used to generate interrupt requests on the IRQ5 channel of the EIC interrupt controller\n•1: The 16 wake-up lines work as wake-up sources for exiting from STOP mode."
Group_2_Item_1_Type = 1,generate interrupt requests,wake-up sources
Group_2_Item_1_CodingProc = SetInt((GetWordValue(0,0xE0001024)&0x0001)?1:0);
Group_2_Item_1_DecodingProc = SetWordValue(0,0xE0001024,(GetInt()?1:0)|(GetWordValue(0,0xE0001024)&~0x0001));
Group_2_Item_2_Name = ID1S
Group_2_Item_2_Comment = "Bit 1 = ID1S: XTI Global Interrupt Mask.\nThis bit is set and cleared by software.\n•0: XTI interrupts disabled.\n•1: XTI interrupts enabled.\nWARNING: To avoid spurious interrupt requests on the IRQ5 channel of the EIC, it is recommended to clear the corresponding enable bit in the EIC IER register before modifying the ID1S bit."
Group_2_Item_2_Type = 1, disabled,enabled
Group_2_Item_2_CodingProc = SetInt((GetWordValue(0,0xE0001024)&0x0002)?1:0);
Group_2_Item_2_DecodingProc = SetWordValue(0,0xE0001024,(GetInt()?1:0)|(GetWordValue(0,0xE0001024)&~0x0002));
Group_2_Item_3_Name = STOP
Group_2_Item_3_Comment = "Bit 2 = STOP: Stop bit.\nTo enter STOP Mode, write the sequence 1,0,1 to this bit with three write operations. When a correct sequence is recognized, the STOP bit is set and the PRCCU puts the MCU in STOP Mode. The software sequence succeeds only if the following conditions are true:\n– The WKUP-INT bit is 1,\n– All unmasked pending bits are reset,\n– At least one mask bit is equal to 1\nOtherwise the device cannot enter STOP mode, the program code continues executing and the STOP bit remains cleared.\nThe bit is reset by hardware if, while the device is in STOP mode, a wake-up interrupt comes from any of the unmasked wake-up lines. The STOP bit is at 1 in the two following cases:\n– After the first write instruction of the sequence\n– At the end of a successful sequence."
Group_2_Item_3_Type = 1,stop,ongoing
Group_2_Item_3_CodingProc = SetInt((GetWordValue(0,0xE0001024)&0x0004)?1:0);
Group_2_Item_3_DecodingProc = SetWordValue(0,0xE0001024,(GetInt()?1:0)|(GetWordValue(0,0xE0001024)&~0x0004));
Group_3_Name = XTI Mask Register Low (XTI_MRL))
Group_3_Comment = "XTI Mask Register Low (XTI_MRL).\n•Address Offset: 2Ch.\n•Reset value: 00h."
Group_3_ItemsNumber = 1
Group_3_Item_1_Name = XTIM
Group_3_Item_1_Comment = "Bit 7:0 = XTIM[7:0]: Wake-Up Mask bits.\nIf XTIMx is set, an interrupt and/or a wake-up event (depending on ID1S and WKUP-INT bits)are generated if the corresponding XTIPx pending bit is set."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000102C).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xE000102C,parseInt(GetString()));
Group_4_Name = XTI Mask Register High (XTI_MRH)
Group_4_Comment = "XTI Mask Register High (XTI_MRH).\n•Address Offset: 28h.\n•Reset value: 00h."
Group_4_ItemsNumber = 1
Group_4_Item_1_Name = XTIM
Group_4_Item_1_Comment = "Bit 7:0 = XTIM[15:8]: Wake-Up Mask bits.\nIf XTIMx is set, an interrupt and/or a wake-up event (depending on ID1S and WKUP-INT bits)are generated if the corresponding XTIPx pending bit is set."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0001028).toString(16));
Group_4_Item_1_DecodingProc = SetWordValue(0,0xE0001028,parseInt(GetString()));
Group_5_Name = XTI Trigger Polarity Register Low (XTI_TRL)
Group_5_Comment = "XTI Trigger Polarity Register Low (XTI_TRL).\n•Address Offset: 34h.\n•Reset value: 00h."
Group_5_ItemsNumber = 1
Group_5_Item_1_Name = XTIT
Group_5_Item_1_Comment = "Bit 7:0 = XTIT[7:0]: XTI Trigger Polarity Bits\nThese bits are set and cleared by software.\n•0: The corresponding XTIPx pending bit will be set on the falling edge of the input wake-up line.\n•1: The corresponding XTIPx pending bit will be set on the rising edge of the input wake-up line."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0001034).toString(16));
Group_5_Item_1_DecodingProc = SetWordValue(0,0xE0001034,parseInt(GetString()));
Group_6_Name = XTI Trigger Polarity Register High (XTI_TRH)
Group_6_Comment = "XTI Trigger Polarity Register High (XTI_TRH).\n•Address Offset: 30h.\n•Reset value: 00h."
Group_6_ItemsNumber = 1
Group_6_Item_1_Name = XTIT
Group_6_Item_1_Comment = "Bit 7:0 = XTIT[15:8]: XTI Trigger Polarity Bits\nThese bits are set and cleared by software.\n•0: The corresponding XTIPx pending bit will be set on the falling edge of the input wake-up line.\n•1: The corresponding XTIPx pending bit will be set on the rising edge of the input wake-up line."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0001030).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xE0001030,parseInt(GetString()));
Group_7_Name = XTI Pending Register Low (XTI_PRL).
Group_7_Comment = "XTI Pending Register Low (XTI_PRL).\n•Address Offset: 3Ch.\n•Reset value: 00h."
Group_7_ItemsNumber = 8
Group_7_Item_1_Name = XTIP
Group_7_Item_1_Comment = "Bit 7:0 = XTIP[7:0]: XTI Pending Bits.\nThese bits are set by hardware on occurrence of the trigger event on the corresponding wake-up line. These bits can be written by software only to ‘0’.\n•0: No Wake-up Trigger event occurred.\n•1: Wake-up Trigger event occurred"
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE000103C).toString(16));
Group_7_Item_1_DecodingProc = SetWordValue(0,0xE000103C,parseInt(GetString()));
Group_8_Name = XTI Pending Register High (XTI_PRH)
Group_8_Comment = "XTI Pending Register High (XTI_PRH).\n•Address Offset: 38h.\n•Reset value: 00h."
Group_8_ItemsNumber = 1
Group_8_Item_1_Name = XTIP
Group_8_Item_1_Comment = "Bit 7:0 = XTIP[15:8]: XTI Pending Bits.\nThese bits are set by hardware on occurrence of the trigger event on the corresponding wake-up line. These bits can be written by software only to ‘0’.\n•0: No Wake-up Trigger event occurred.\n•1: Wake-up Trigger event occurred."
Group_8_Item_1_Type = 0
Group_8_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xE0001038).toString(16));
Group_8_Item_1_DecodingProc = SetWordValue(0,0xE0001038,parseInt(GetString()));
[HDLC]
SegmentsNumber = 2
Segment_1 = HDLC_SEG, 32, 0xC000E000, 0x54
Segment_2 = HDLC_SEGRAM, 32, 0xC000E800, 0x40
SymbsNumber = 21
Symb_1 = HDLC_PARH, 0, 0xC000E000
Symb_2 = HDLC_PARL, 0, 0xC000E004
Symb_3 = HDLC_PAMH, 0, 0xC000E008
Symb_4 = HDLC_PAML, 0, 0xC000E00C
Symb_5 = HDLC_GA1, 0, 0xC000E010
Symb_6 = HDLC_GA0, 0, 0xC000E014
Symb_7 = HDLC_GAM1, 0, 0xC000E018
Symb_8 = HDLC_GAM0, 0, 0xC000E01C
Symb_9 = HDLC_PRES, 0, 0xC000E020
Symb_10 = HDLC_POES, 0, 0xC000E024
Symb_11 = HDLC_TCTL, 0, 0xC000E028
Symb_12 = HDLC_RCTL, 0, 0xC000E02C
Symb_13 = HDLC_BRR, 0, 0xC000E030
Symb_14 = HDLC_PRSR, 0, 0xC000E034
Symb_15 = HDLC_PSR, 0, 0xC000E038
Symb_16 = HDLC_FSBR, 0, 0xC000E03C
Symb_17 = HDLC_TFBCR, 0, 0xC000E040
Symb_18 = HDLC_RFTCR, 0, 0xC000E044
Symb_19 = HDLC_PCR, 0, 0xC000E048
Symb_20 = HDLC_ISR, 0, 0xC000E04C
Symb_21 = HDLC_IMR, 0, 0xC000E050
ResetCode = {SetWordValue(0,0xC000E000,0x00);SetWordValue(0,0xC000E004,0x00);SetWordValue(0,0xC000E008,0x00);SetWordValue(0,0xC000E00C,0x00);SetWordValue(0,0xC000E010,0x00);SetWordValue(0,0xC000E014,0x00);SetWordValue(0,0xC000E018,0x00);SetWordValue(0,0xC000E01C,0x00);SetWordValue(0,0xC000E020,0x00);SetWordValue(0,0xC000E024,0x00);SetWordValue(0,0xC000E028,0x00);SetWordValue(0,0xC000E02C,0x00);SetWordValue(0,0xC000E030,0x00);SetWordValue(0,0xC000E034,0x00);SetWordValue(0,0xC000E038,0x00);SetWordValue(0,0xC000E03C,0x00);SetWordValue(0,0xC000E040,0x00);SetWordValue(0,0xC000E044,0x00);SetWordValue(0,0xC000E048,0x00);SetWordValue(0,0xC000E04C,0x00);SetWordValue(0,0xC000E050,0x00);}
GroupsNumber = 21
Group_1_Name = Private Address Register Low (HDLC_PARL)
Group_1_Comment = "Private Address Register Low (HDLC_PARL).\n•Address Offset: 0004h.\n•Reset value: 0000h."
Group_1_ItemsNumber = 2
Group_1_CodingProc = SetString("0x"+GetWordValue(0,0xC000E004).toString(16));
Group_1_Item_1_Name = PAB0
Group_1_Item_1_Comment = "Bit 7:0 = PAB0[7:0]: Private Address Byte 0\nThird address byte after opening flag."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc =SetString("0x"+(GetWordValue(0,0xC000E004)&0x00FF).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xC000E004,(parseInt(GetString()))&~0x00FF);
Group_1_Item_2_Name = PAB1
Group_1_Item_2_Comment = "Bit 15:8 = PAB1[7:0]: Private Address Byte 1\nFourth address byte after opening flag."
Group_1_Item_2_Type = 0
Group_1_Item_2_CodingProc = SetString("0x"+((GetWordValue(0,0xC000E004)&0xFF00)>>8).toString(16));
Group_1_Item_2_DecodingProc = SetWordValue(0,0xC000E004,((parseInt(GetString()))<<8)|(GetWordValue(0,0xC000E004)&~0xFF00));
Group_2_Name = Private Address Register High (HDLC_PARH)
Group_2_Comment = "Private Address Register High (HDLC_PARH).\n•Address Offset: 0000h.\n•Reset value: 0000h."
Group_2_ItemsNumber = 2
Group_2_CodingProc = SetString("0x"+GetWordValue(0,0xC000E000).toString(16));
Group_2_Item_1_Name = PAB2
Group_2_Item_1_Comment = "Bit 7:0 = PAB2[7:0]: Private Address Byte 2\nThird address byte after opening flag."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000E000)&0x00FF).toString(16));
Group_2_Item_1_DecodingProc = SetWordValue(0,0xC000E000,(parseInt(GetString()))&~0x00FF);
Group_2_Item_2_Name = PAB3
Group_2_Item_2_Comment = "Bit 15:8 = PAB3[7:0]: Private Address Byte 3\nFourth address byte after opening flag."
Group_2_Item_2_Type = 0
Group_2_Item_2_CodingProc = SetString("0x"+((GetWordValue(0,0xC000E000)&0xFF00)>>8).toString(16));
Group_2_Item_2_DecodingProc = SetWordValue(0,0xC000E000,((parseInt(GetString()))<<8)|(GetWordValue(0,0xC000E000)&~0xFF00));
Group_3_Name = Private Address Mask Register Low (HDLC_PAML)
Group_3_Comment ="Private Address Mask Register Low (HDLC_PAML).\n•Address Offset: 000Ch.\n•Reset value: 0000h."
Group_3_ItemsNumber = 2
Group_3_CodingProc = SetString("0x"+GetWordValue(0,0xC000E00C).toString(16));
Group_3_Item_1_Name = PAMB0
Group_3_Item_1_Comment = "Bit 7:0 = PAMB0[7:0]: Private Address Byte 0\nIf PAMB0x bit is 0, comparison between PAB0x and its corresponding bit in the address field is ignored. Otherwise it won’t be ignored."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000E00C)&0x00FF).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xC000E00C,(parseInt(GetString()))&~0x00FF);
Group_3_Item_2_Name = PAMB1
Group_3_Item_2_Comment = "Bit 15:8 = PAMB1[7:0]: Private Address Byte 1\nIf PAMB1x bit is 0, comparison between PAB1x and its corresponding bit in the address field is ignored. Otherwise it won’t be ignored."
Group_3_Item_2_Type = 0
Group_3_Item_2_CodingProc = SetString("0x"+((GetWordValue(0,0xC000E00C)&0xFF00)>>8).toString(16));
Group_3_Item_2_DecodingProc = SetWordValue(0,0xC000E00C,((parseInt(GetString()))<<8)|(GetWordValue(0,0xC000E00C)&~0xFF00));
Group_4_Name = Private Address Mask Register High (HDLC_PAMH).
Group_4_Comment = " Private Address Mask Register High (HDLC_PAMH).\n•Address Offset: 0008h.\n•Reset value: 0000h."
Group_4_ItemsNumber = 2
Group_4_CodingProc = SetString("0x"+GetWordValue(0,0xC000E008).toString(16));
Group_4_Item_1_Name = PAMB2
Group_4_Item_1_Comment = "Bit 7:0 = PAMB2[7:0]: Private Address Mask Byte 2\nIf PAMB2x bit is 0, comparison between PAB2x and its corresponding bit in the address field is ignored. Otherwise it won’t be ignored."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000E008)&0x00FF).toString(16));
Group_4_Item_1_DecodingProc = SetWordValue(0,0xC000E008,(parseInt(GetString()))&~0x00FF);
Group_4_Item_2_Name = PAMB3
Group_4_Item_2_Comment = "Bit 15:8 = PAMB3[7:0]: Private Address Mask Byte 3\nIf PAMB3x bit is 0, comparison between PAB3x and its corresponding bit in the address field is ignored. Otherwise it won’t be ignored."
Group_4_Item_2_Type = 0
Group_4_Item_2_CodingProc = SetString("0x"+((GetWordValue(0,0xC000E008)&0xFF00)>>8).toString(16));
Group_4_Item_2_DecodingProc = SetWordValue(0,0xC000E008,((parseInt(GetString()))<<8)|(GetWordValue(0,0xC000E008)&~0xFF00));
Group_5_Name = Group Address Register 0 (HDLC_GA0)
Group_5_Comment = "Group Address Register 0 (HDLC_GA0).\n•Address Offset: 0014h.\n•Reset value: 0000h."
Group_5_ItemsNumber = 2
Group_5_CodingProc = SetString("0x"+GetWordValue(0,0xC000E014).toString(16));
Group_5_Item_1_Name = GA0
Group_5_Item_1_Comment = "Bit 7:0 = GA0[7:0]: Group Address 0.\nIf the functionality is enabled the first byte after the opening flag can be recognized as Group Address."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000E014)&0x00FF).toString(16));
Group_5_Item_1_DecodingProc = SetWordValue(0,0xC000E014,(parseInt(GetString()))&~0x00FF);
Group_5_Item_2_Name = GA1
Group_5_Item_2_Comment = "Bit 15:8 = GA1[7:0]: Group Address 1.\nIf the functionality is enabled the first byte after the opening flag can be recognized as Group Address."
Group_5_Item_2_Type = 0
Group_5_Item_2_CodingProc = SetString("0x"+((GetWordValue(0,0xC000E014)&0xFF00)>>8).toString(16));
Group_5_Item_2_DecodingProc = SetWordValue(0,0xC000E014,((parseInt(GetString()))<<8)|(GetWordValue(0,0xC000E014)&~0xFF00));
Group_6_Name = Group Address Register 1 (HDLC_GA1).
Group_6_Comment = "Group Address Register 1 (HDLC_GA1).\n•Address Offset: 0010h.\n•Reset value: 0000h."
Group_6_ItemsNumber = 2
Group_6_CodingProc = SetString("0x"+GetWordValue(0,0xC000E010).toString(16));
Group_6_Item_1_Name = GA2
Group_6_Item_1_Comment = "Bit 7:0 = GA2[7:0]: Group Address 2.\nIf the functionality is enabled the first byte after the opening flag can be recognized as Group Address."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000E010)&0x00FF).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xC000E010,(parseInt(GetString()))&~0x00FF);
Group_6_Item_2_Name = BA
Group_6_Item_2_Comment = "Bit 15:8 = BA[7:0]: Broadcast Address\nIf the functionality is enabled the first byte after the opening flag can be recognized as Broadcast Address."
Group_6_Item_2_Type = 0
Group_6_Item_2_CodingProc = SetString("0x"+((GetWordValue(0,0xC000E010)&0xFF00)>>8).toString(16));
Group_6_Item_2_DecodingProc = SetWordValue(0,0xC000E010,((parseInt(GetString()))<<8)|(GetWordValue(0,0xC000E010)&~0xFF00));
Group_7_Name = Group Address Mask Register 0 (HDLC_GAM0)
Group_7_Comment = "Group Address Mask Register 0 (HDLC_GAM0).\n•Address Offset: 001Ch.\n•Reset value: 0000h."
Group_7_ItemsNumber = 2
Group_7_CodingProc = SetString("0x"+GetWordValue(0,0xC000E01C).toString(16));
Group_7_Item_1_Name = GAM0
Group_7_Item_1_Comment = "Bit 7:0 = GAM0[7:0]: Group Address Mask 0\nIf GAMx bit is 0, comparison between GA0x and its corresponding bit in the address field is ignored. Otherwise it won’t be ignored."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000E01C)&0x00FF).toString(16));
Group_7_Item_1_DecodingProc = SetWordValue(0,0xC000E01C,(parseInt(GetString()))&~0x00FF);
Group_7_Item_2_Name = GAM1
Group_7_Item_2_Comment = "Bit 15:8 = GAM1[7:0]: Group Address Mask 1\nIf GAM1x bit is 0, comparison between GA1x and its corresponding bit in the address field is ignored. Otherwise it won’t be ignored."
Group_7_Item_2_Type = 0
Group_7_Item_2_CodingProc = SetString("0x"+((GetWordValue(0,0xC000E01C)&0xFF00)>>8).toString(16));
Group_7_Item_2_DecodingProc = SetWordValue(0,0xC000E01C,((parseInt(GetString()))<<8)|(GetWordValue(0,0xC000E01C)&~0xFF00));
Group_8_Name = Group Address Mask Register 1 (HDLC_GAM1).
Group_8_Comment = "Group Address Mask Register 1 (HDLC_GAM1).\n•Address Offset: 0018h.\n•Reset value: 0000h."
Group_8_ItemsNumber = 2
Group_8_CodingProc = SetString("0x"+GetWordValue(0,0xC000E018).toString(16));
Group_8_Item_1_Name = GAM2
Group_8_Item_1_Comment = "Bit 7:0 = GAM2[7:0]: Group Address Mask 2\nIf GAM2x bit is 0, comparison between GA2x and its corresponding bit in the address field is ignored. Otherwise it won’t be ignored."
Group_8_Item_1_Type = 0
Group_8_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000E018)&0x00FF).toString(16));
Group_8_Item_1_DecodingProc = SetWordValue(0,0xC000E018,(parseInt(GetString()))&~0x00FF);
Group_8_Item_2_Name = BAM
Group_8_Item_2_Comment = "Bit 15:8 = BAM[7:0]: Broadcast Address Mask\nIf BAMx bit is 0, comparison between BAx and its corresponding bit in the address field is ignored. Otherwise it won’t be ignored."
Group_8_Item_2_Type = 0
Group_8_Item_2_CodingProc = SetString("0x"+((GetWordValue(0,0xC000E018)&0xFF00)>>8).toString(16));
Group_8_Item_2_DecodingProc = SetWordValue(0,0xC000E018,((parseInt(GetString()))<<8)|(GetWordValue(0,0xC000E018)&~0xFF00));
Group_9_Name = Preamble Sequence Register (HDLC_PRES)
Group_9_Comment = "Preamble Sequence Register (HDLC_PRES).\n•Address Offset: 0020h.\n•Reset value: 0000h."
Group_9_ItemsNumber = 1
Group_9_CodingProc = SetString("0x"+GetWordValue(0,0xC000E020).toString(16));
Group_9_Item_1_Name = PRESEQ
Group_9_Item_1_Comment = "Bit 15:0 = PRESEQ[15:0]: Preamble Sequence\nUp to 16 bits can be transmitted before the opening flag starting from the least significant."
Group_9_Item_1_Type = 0
Group_9_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC000E020).toString(16));
Group_9_Item_1_DecodingProc = SetWordValue(0,0xC000E020,parseInt(GetString()));
Group_10_Name = Postamble Sequence Register (HDLC_POSS)
Group_10_Comment = "Postamble Sequence Register (HDLC_POSS).\n•Address Offset: 0024h.\n•Reset value: 0000h."
Group_10_ItemsNumber = 1
Group_10_CodingProc = SetString("0x"+GetWordValue(0,0xC000E024).toString(16));
Group_10_Item_1_Name = POSS
Group_10_Item_1_Comment = "Bit 15:0 = POSS[15:0]: Postamble Sequence\nUp to 16 bits can be transmitted after the closing flag starting from the least significant."
Group_10_Item_1_Type = 0
Group_10_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC000E024).toString(16));
Group_10_Item_1_DecodingProc = SetWordValue(0,0xC000E024,parseInt(GetString()));
Group_11_Name = Transmission Control Register (HDLC_TCTL)
Group_11_Comment = "Transmission Control Register (HDLC_TCTL)\n•Address Offset: 0028h.\n•Reset value: 0000h."
Group_11_ItemsNumber = 9
Group_11_CodingProc = SetString("0x"+GetWordValue(0,0xC000E028).toString(16));
Group_11_Item_1_Name = NPOSB
Group_11_Item_1_Comment = "Bit 3:0 = NPOSB[3:0]: Number of postamble sequence bit\nIf the functionality is enabled (POSE = 1), (NPOSB[3:0]+1) bit are transmitted after the closing flag."
Group_11_Item_1_Type = 0
Group_11_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000E028)&0x000F).toString(16));
Group_11_Item_1_DecodingProc = SetWordValue(0,0xC000E028,(parseInt(GetString()))&~0x000F);
Group_11_Item_2_Name = NPREB
Group_11_Item_2_Comment = "Bit 7:4 = NPREB[3:0]: Number of bit preamble sequence bit\nIf the functionality is enabled (PREE = 1), (NPREB[3:0]+1) bit are transmitted before the opening flag."
Group_11_Item_2_Type = 0
Group_11_Item_2_CodingProc = SetString("0x"+((GetWordValue(0,0xC000E028)&0x00F0)>>4).toString(16));
Group_11_Item_2_DecodingProc = SetWordValue(0,0xC000E028,((parseInt(GetString()))<<4)|(GetWordValue(0,0xC000E028)&~0x00F0));
Group_11_Item_3_Name = POSE
Group_11_Item_3_Comment = "Bit 8 = POSE: Postamble sequence enable.\n•When 0 no postamble sequence is transmitted.\n•When 1 the postamble sequence is transmitted."
Group_11_Item_3_Type = 1,not transmitted,transmitted
Group_11_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000E028)&0x0100)?1:0);
Group_11_Item_3_DecodingProc = SetWordValue(0,0xC000E028,(GetInt()?0x0100:0)|(GetWordValue(0,0xC000E028)&~0x0100));
Group_11_Item_4_Name = PREE
Group_11_Item_4_Comment = "Bit 9 = PREE: Preamble sequence enable.\n•When 0 no preamble sequence is transmitted.\n•When 1 the preamble sequence is transmitted."
Group_11_Item_4_Type = 1,not transmitted,transmitted
Group_11_Item_4_CodingProc = SetInt((GetWordValue(0,0xC000E028)&0x0200)?1:0);
Group_11_Item_4_DecodingProc = SetWordValue(0,0xC000E028,(GetInt()?0x0200:0)|(GetWordValue(0,0xC000E028)&~0x0200));
Group_11_Item_5_Name = TCOD
Group_11_Item_5_Comment = "Bit 11 :10 = TCOD[1:0]: Transmission Data encoding.\n•00:NRZ.\n•01:NRZI.\n•10:FM0.\n•11:MANCH."
Group_11_Item_5_Type = 1,NRZ,NRZI,FM0,MANCH
Group_11_Item_5_CodingProc = SetInt((GetWordValue(0,0xC000E028)&0x0C00)>>10);
Group_11_Item_5_DecodingProc = SetWordValue(0,0xC000E028,(GetInt()<<10)|(GetWordValue(0,0xC000E028)&0xF3FF));
Group_11_Item_6_Name = TCRCI
Group_11_Item_6_Comment = "Bit 12 = TCRCI: Transmission CRC inizialization.\n•When 0 the CRC is initialized with ‘0’.\n•When 1 the CRC is initialized with ‘1’."
Group_11_Item_6_Type = 1,initialized with 0,initialized with 1
Group_11_Item_6_CodingProc = SetInt((GetWordValue(0,0xC000E028)&0x1000)?1:0);
Group_11_Item_6_DecodingProc = SetWordValue(0,0xC000E028,(GetInt()?0x1000:0)|(GetWordValue(0,0xC000E028)&~0x1000));
Group_11_Item_7_Name = ITF
Group_11_Item_7_Comment = "Bit 13 = ITF: Interframe Time Fill\nIdle condition or Flags can be transmitted between two consecutive frames.\n•When ITF=1 Flags are transmitted.\n•When ITF = 0 Idle state is transmitted."
Group_11_Item_7_Type = 1,disabled,enabled
Group_11_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000E028)&0x2000)?1:0);
Group_11_Item_7_DecodingProc = SetWordValue(0,0xC000E028,(GetInt()?0x2000:0)|(GetWordValue(0,0xC000E028)&~0x2000));
Group_11_Item_8_Name = SOC
Group_11_Item_8_Comment = "Bit 14 = SOC: Serial Output Complemented.\n•When SOC = 1 the serial output frame is complemented bit by bit.\n•When SOC = 0 the serial output frame is transmitted as it is."
Group_11_Item_8_Type = 1,disabled,enabled
Group_11_Item_8_CodingProc = SetInt((GetWordValue(0,0xC000E028)&0x4000)?1:0);
Group_11_Item_8_DecodingProc = SetWordValue(0,0xC000E028,(GetInt()?0x4000:0)|(GetWordValue(0,0xC000E028)&~0x4000));
Group_11_Item_9_Name = HTEN
Group_11_Item_9_Comment = "Bit 15 = HTEN: Hardware Transmission Enable.\n•When 1,the TEN bit can be set by hardware and software.\n•When 0, the TEN bit can be set only by software."
Group_11_Item_9_Type = 1,disabled,enabled
Group_11_Item_9_CodingProc = SetInt((GetWordValue(0,0xC000E028)&0x8000)?1:0);
Group_11_Item_9_DecodingProc = SetWordValue(0,0xC000E028,(GetInt()?0x8000:0)|(GetWordValue(0,0xC000E028)&~0x8000));
Group_12_Name = Receive Control Register (HDLC_RCTL)
Group_12_Comment = "Receive Control Register (HDLC_RCTL).\n•Address Offset: 002Ch.\n•Reset value: 0000h."
Group_12_ItemsNumber = 12
Group_12_CodingProc = SetString("0x"+GetWordValue(0,0xC000E02C).toString(16));
Group_12_Item_1_Name = RCOD
Group_12_Item_1_Comment = "Bit 1:0 = RCOD[1:0]: Receive Data decoding.\n•00:NRZ.\n•01:NRZI.\n•10:FM0.\n•11:MANCH."
Group_12_Item_1_Type = 1,NRZ,NRZI,FM0,MANCH
Group_12_Item_1_CodingProc = SetInt(GetWordValue(0,0xC000E02C)&0x0003);
Group_12_Item_1_DecodingProc = SetWordValue(0,0xC000E02C,GetInt()|(GetWordValue(0,0xC000E02C)&0xFFFC));
Group_12_Item_2_Name = RCRCI
Group_12_Item_2_Comment = "Bit 2 = RCRCI: Receive CRC Initialization.\n•When 0 the CRC is initialized with ‘0’.\n•When 1 the CRC is initialized with ‘1’."
Group_12_Item_2_Type = 1,initialized with ‘0’,initialized with ‘1’
Group_12_Item_2_CodingProc = SetInt((GetWordValue(0,0xC000E02C)&0x0004)?1:0);
Group_12_Item_2_DecodingProc = SetWordValue(0,0xC000E02C,(GetInt()?0x0004:0)|(GetWordValue(0,0xC000E02C)&~0x0004));
Group_12_Item_3_Name = SIC
Group_12_Item_3_Comment = "Bit 3 = SIC: Serial Input Complemented.\n•When SIC = 1 the serial input frame is complemented bit by bit.\n•When SIC = 0 the serial input frame is transnferred as it is."
Group_12_Item_3_Type = 1,disabled,enabled
Group_12_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000E02C)&0x0008)?1:0);
Group_12_Item_3_DecodingProc = SetWordValue(0,0xC000E02C,(GetInt()?0x0008:0)|(GetWordValue(0,0xC000E02C)&~0x0008));
Group_12_Item_4_Name = LBEN
Group_12_Item_4_Comment = "Bit 4 = LBEN: Loopback Enable.\nWhen LBEN=1, the TX output HSDOUT is set to “1”, the RX input HSDIN is disconnected,and the output transmitter is looped back into the receiver input."
Group_12_Item_4_Type = 1,disabled,enabled
Group_12_Item_4_CodingProc = SetInt((GetWordValue(0,0xC000E02C)&0x0010)?1:0);
Group_12_Item_4_DecodingProc = SetWordValue(0,0xC000E02C,(GetInt()?0x0010:0)|(GetWordValue(0,0xC000E02C)&~0x0010));
Group_12_Item_5_Name = AEN
Group_12_Item_5_Comment = "Bit 5 = AEN: Autoecho Enable.\nWhen AEN=1, the transmitter is in auto echo mode: transmitter is disconnected from the TX data out HSDOUT.\nHSDOUT is driven directly by the RX data pin HSDIN. The receiver remains connected to HSDIN."
Group_12_Item_5_Type = 1,disabled,enabled
Group_12_Item_5_CodingProc = SetInt((GetWordValue(0,0xC000E02C)&0x0020)?1:0);
Group_12_Item_5_DecodingProc = SetWordValue(0,0xC000E02C,(GetInt()?0x0020:0)|(GetWordValue(0,0xC000E02C)&~0x0020));
Group_12_Item_6_Name = GA0E
Group_12_Item_6_Comment = "Bit 6 = GA0E: Group Address 0 Enable.\n•When 1 the Group Address 0 is recognized.\n•When 0 it is ignored."
Group_12_Item_6_Type = 1,ignored,the Private Address is recognized
Group_12_Item_6_CodingProc = SetInt((GetWordValue(0,0xC000E02C)&0x0040)?1:0);
Group_12_Item_6_DecodingProc = SetWordValue(0,0xC000E02C,(GetInt()?0x0040:0)|(GetWordValue(0,0xC000E02C)&~0x0040));
Group_12_Item_7_Name = GA1E
Group_12_Item_7_Comment = "Bit 7 = GA1E: Group Address 1 Enable.\n•When 1 the Group Address 1 is recognized.\n•When 0 it is ignored."
Group_12_Item_7_Type = 1,ignored,the Private Address is recognized
Group_12_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000E02C)&0x0080)?1:0);
Group_12_Item_7_DecodingProc = SetWordValue(0,0xC000E02C,(GetInt()?0x0080:0)|(GetWordValue(0,0xC000E02C)&~0x0080));
Group_12_Item_8_Name = GA2E
Group_12_Item_8_Comment = "Bit 8 = GA2E: Group Address 2 Enable.\n•When 1 the Group Address 2 is recognized.\n•When 0 it is ignored."
Group_12_Item_8_Type = 1,ignored,the Private Address is recognized
Group_12_Item_8_CodingProc = SetInt((GetWordValue(0,0xC000E02C)&0x0100)?1:0);
Group_12_Item_8_DecodingProc = SetWordValue(0,0xC000E02C,(GetInt()?0x0100:0)|(GetWordValue(0,0xC000E02C)&~0x0100));
Group_12_Item_9_Name = BAE
Group_12_Item_9_Comment = "Bit 9 = BAE: Broadcast Address Enable.\n•When 1 the Broadcast Address is recognized.\n•When 0 it is ignored."
Group_12_Item_9_Type = 1,ignored,the Private Address is recognized
Group_12_Item_9_CodingProc = SetInt((GetWordValue(0,0xC000E02C)&0x0200)?1:0);
Group_12_Item_9_DecodingProc = SetWordValue(0,0xC000E02C,(GetInt()?0x0200:0)|(GetWordValue(0,0xC000E02C)&~0x0200));
Group_12_Item_10_Name = PAE
Group_12_Item_10_Comment = "Bit 10 = PAE: Private Address Enable.\n•When 1 the Private Address is recognized.\n•When 0 it is ignored."
Group_12_Item_10_Type = 1,ignored,the Private Address is recognized
Group_12_Item_10_CodingProc = SetInt((GetWordValue(0,0xC000E02C)&0x0400)?1:0);
Group_12_Item_10_DecodingProc = SetWordValue(0,0xC000E02C,(GetInt()?0x0400:0)|(GetWordValue(0,0xC000E02C)&~0x0400));
Group_12_Item_11_Name = DPLLE
Group_12_Item_11_Comment = "Bit 11 = DPLLE: DPLL enable.\n•When 1 DPLLE is enabled.\n•When 0 disabled."
Group_12_Item_11_Type = 1,disabled,enabled
Group_12_Item_11_CodingProc = SetInt((GetWordValue(0,0xC000E02C)&0x0800)?1:0);
Group_12_Item_11_DecodingProc = SetWordValue(0,0xC000E02C,(GetInt()?0x0800:0)|(GetWordValue(0,0xC000E02C)&~0x0800));
Group_12_Item_12_Name = RMCE
Group_12_Item_12_Comment = "Bit 12 = RMCE: Receive Message Completed Enable.\n•When 1,the generation of the trigger output signal HRMC is enabled.\n•When 0. the generation of the trigger output signal HRMC is disabled"
Group_12_Item_12_Type = 1,disabled,enabled
Group_12_Item_12_CodingProc = SetInt((GetWordValue(0,0xC000E02C)&0x1000)?1:0);
Group_12_Item_12_DecodingProc = SetWordValue(0,0xC000E02C,(GetInt()?0x1000:0)|(GetWordValue(0,0xC000E02C)&~0x1000));
Group_13_Name = Baud Rate Register (HDLC_BRR)
Group_13_Comment = "Baud Rate Register (HDLC_BRR).\n•Address Offset: 0030h.\n•Reset value: 0000h."
Group_13_ItemsNumber = 2
Group_13_CodingProc = SetString("0x"+GetWordValue(0,0xC000E030).toString(16));
Group_13_Item_1_Name = BRG
Group_13_Item_1_Comment = "Bit 11:0 = BRG[11:0]: Transmission Baudrate.\nThe Transmission clock TCK is divided by BRG[11:0] + 1 when NRZ or NRZI encoding are enabled or by 2*(BRG[11:0] + 1) when FM0 or Manchester encoding are enabled."
Group_13_Item_1_Type = 0
Group_13_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000E030)&0x0FFF).toString(16));
Group_13_Item_1_DecodingProc = SetWordValue(0,0xC000E030,(parseInt(GetString()))&~0x0FFF);
Group_13_Item_2_Name = TCKS
Group_13_Item_2_Comment = "Bit 12 = TCKS: Transmission clock selection.\n•When 0 the System Clock CK is selected.\n•When 1 the external HTXCK is selected.\nWhen a new transmission clock source is selected the peripheral will be reset to avoid spurious pulse generation and so any previous stored data will be lost."
Group_13_Item_2_Type = 1,system clock CK,external HTXCK
Group_13_Item_2_CodingProc = SetInt((GetWordValue(0,0xC000E030)&0x1000)?1:0);
Group_13_Item_2_DecodingProc = SetWordValue(0,0xC000E030,(GetInt()?0x1000:0)|(GetWordValue(0,0xC000E030)&~0x1000));
Group_14_Name = Prescaler Register (HDLC_PRSR)
Group_14_Comment = "Prescaler Register (HDLC_PRSR).\n•Address Offset: 0034h.\n•Reset value: 0000h."
Group_14_ItemsNumber = 2
Group_14_CodingProc = SetString("0x"+GetWordValue(0,0xC000E034).toString(16));
Group_14_Item_1_Name = PRS
Group_14_Item_1_Comment = "Bit 7:0 = PRS[7:0]: Receive Prescaler.\nThe Receive Clock RCK is divided by PRS[7:0] + 1"
Group_14_Item_1_Type = 0
Group_14_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000E034)&0x00FF).toString(16));
Group_14_Item_1_DecodingProc = SetWordValue(0,0xC000E034,(parseInt(GetString()))&~0x00FF);
Group_14_Item_2_Name = RCKS
Group_14_Item_2_Comment = "Bit 9:8 = RCKS[1:0]: Receive clock selection.\n•00,CK.\n•01,HTXCK.\n•10,HRXCK.\n•11,-."
Group_14_Item_2_Type = 1,CK,HTXCK,HRXCK,-
Group_14_Item_2_CodingProc = SetInt((GetWordValue(0,0xC000E034)&0x0300)>>8);
Group_14_Item_2_DecodingProc = SetWordValue(0,0xC000E034,(GetInt()<<8)|(GetDWordValue(0,0xC000E034)&0xFCFF));
Group_15_Name = Peripheral Status Register (HDLC_PSR)
Group_15_Comment = "Peripheral Status Register (HDLC_PSR).\n•Address Offset: 0038h.\n•Reset value: 0000h."
Group_15_ItemsNumber = 3
Group_15_CodingProc = SetString("0x"+GetWordValue(0,0xC000E038).toString(16));
Group_15_Item_1_Name = RLS
Group_15_Item_1_Comment = "Bit 1:0 = RLS[1:0]: Receive Line Status.\n•00:Noise or abort.\n•01:Idle.\n•10:Interframe.\n•11:Frame."
Group_15_Item_1_Type = 1,Noise or abort,Idle,Interframe,Frame
Group_15_Item_1_CodingProc = SetInt(GetWordValue(0,0xC000E038)&0x0003);
Group_15_Item_1_DecodingProc = SetWordValue(0,0xC000E038,GetInt()|(GetWordValue(0,0xC000E038)&0xFFFC));
Group_15_Item_2_Name = TBR
Group_15_Item_2_Comment = "Bit 2 = TBR: Transmission half Buffer Ready.\n•When 0, the low half of the transmission buffer is empty.\n•When 1, the high half of the transmission buffer is empty."
Group_15_Item_2_Type = 1,low half empty,high half empty
Group_15_Item_2_CodingProc = SetInt((GetWordValue(0,0xC000E038)&0x0004)?1:0);
Group_15_Item_2_DecodingProc = SetWordValue(0,0xC000E038,(GetInt()?0x0004:0)|(GetWordValue(0,0xC000E038)&~0x0004));
Group_15_Item_3_Name = RBR
Group_15_Item_3_Comment = "Bit 3 = RBR: Receive half Bffer Ready.\n•When 0 , the low half of the receive buffer is full.\n•When 1, the high half of the receive buffer is full."
Group_15_Item_3_Type = 1,low half full,high half full
Group_15_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000E038)&0x0008)?1:0);
Group_15_Item_3_DecodingProc = SetWordValue(0,0xC000E038,(GetInt()?0x0008:0)|(GetWordValue(0,0xC000E038)&~0x0008));
Group_16_Name = Frame Status Byte Register (HDLC_FSBR)
Group_16_Comment = "Frame Status Byte Register (HDLC_FSBR).\n•Address Offset: 003Ch.\n•Reset value: 0000h."
Group_16_ItemsNumber = 4
Group_16_CodingProc = SetString("0x"+GetWordValue(0,0xC000E03C).toString(16));
Group_16_Item_1_Name = RAB
Group_16_Item_1_Comment = "Bit 4 = RAB: Received Abort.\nWhen 1, the received frame was aborted."
Group_16_Item_1_Type = 1,not aborted,aborted
Group_16_Item_1_CodingProc = SetInt((GetWordValue(0,0xC000E03C)&0x0010)?1:0);
Group_16_Item_2_Name = CRC
Group_16_Item_2_Comment = "Bit 5 = CRC: FCS Check.\nWhen 1, the received FCS bytes are wrong."
Group_16_Item_2_Type = 1,rignt,wrong
Group_16_Item_2_CodingProc = SetInt((GetWordValue(0,0xC000E03C)&0x0020)?1:0);
Group_16_Item_3_Name = PRS
Group_16_Item_3_Comment = "Bit 6 = RDO: Receive Data Overflow.\nWhen 1, at least a byte has been lost because an interrupt request has been issued and the previous one has not been aknowledge yet."
Group_16_Item_3_Type = 1,no byte lost,byte lost
Group_16_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000E03C)&0x0040)?1:0);
Group_16_Item_4_Name = RBC
Group_16_Item_4_Comment = "Bit 7 = RBC: Receive Byte Count.\nWhen 1, the length of a received frame is not n times 8 bit."
Group_16_Item_4_Type = 1,n times 8 bit,not n times 8 bit
Group_16_Item_4_CodingProc = SetInt((GetWordValue(0,0xC000E03C)&0x0080)?1:0);
Group_17_Name = Transmission Frame Byte Count Register (HDLC_TFBCR)
Group_17_Comment = "Transmission Frame Byte Count Register (HDLC_TFBCR).\n•Address Offset: 0040h.\n•Reset value: 0000h."
Group_17_ItemsNumber = 1
Group_17_CodingProc = SetString("0x"+GetWordValue(0,0xC000E040).toString(16));
Group_17_Item_1_Name = TFBC
Group_17_Item_1_Comment = "Bit 15:0 = TFBC[15:0]: Transmission Frame Byte Count\nThe number of bytes to be transmitted must be loaded by software in this register before starting the transmission.\nThe value TFBC is updated every transmitted byte and gives the remaining bytes to be transmitted."
Group_17_Item_1_Type = 0
Group_17_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC000E040).toString(16));
Group_17_Item_1_DecodingProc = SetWordValue(0,0xC000E040,parseInt(GetString()));
Group_18_Name = Receive Frame Byte Count Register (HDLC_RFBCR)
Group_18_Comment = "Receive Frame Byte Count Register (HDLC_RFBCR).\n•Address Offset: 0044h.\n•Reset value: 0000h."
Group_18_ItemsNumber = 1
Group_18_CodingProc = SetString("0x"+GetWordValue(0,0xC000E044).toString(16));
Group_18_Item_1_Name = RFBC
Group_18_Item_1_Comment = "Bit 15:0 = RFBC[15:0]: Receive Frame Byte Count\nThe value RFBC gives the number of data received."
Group_18_Item_1_Type = 0
Group_18_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC000E044).toString(16));
Group_19_Name = Peripheral Command Register (HDLC_PCR)
Group_19_Comment = "Peripheral Command Register (HDLC_PCR).\n•Address Offset: 0048h.\n•Reset value: 0000h."
Group_19_ItemsNumber = 2
Group_19_CodingProc = SetString("0x"+GetWordValue(0,0xC000E048).toString(16));
Group_19_Item_1_Name = REN
Group_19_Item_1_Comment = "Bit 0 = REN: Receive Enable.\n•When it is written to ‘1’, the Receiver is enabled and interrupt requests are generated if enabled and at the end of the reception it is reset by hardware.\n•When it is written to ‘0’, the Receiver goes in the reset state and no more interrupt requests are generated."
Group_19_Item_1_Type = 1,disabled,enabled
Group_19_Item_1_CodingProc = SetInt((GetWordValue(0,0xC000E048)&0x0001)?1:0);
Group_19_Item_1_DecodingProc = SetWordValue(0,0xC000E048,(GetInt()?0x0001:0)|(GetWordValue(0,0xC000E048)&~0x0001));
Group_19_Item_2_Name = TEN
Group_19_Item_2_Comment = "Bit 1 = TEN: Transmission Enable.\n•When it is written to ‘1’, the Transmitter is enabled and interrupt requests are generated if enabled and at the end of the transmission it is reset by hardware.\n•When it is written to ‘0’, the Transmitter goes in the reset state and no more interrupt requests are generated.\nIf this happens before the closing flag of the current frame an abort sequence will be generated.\nThis bit can be set by the trigger signal HTEN if the functionality is enabled (HTEN = 1)"
Group_19_Item_2_Type = 1,disabled,enabled
Group_19_Item_2_CodingProc = SetInt((GetWordValue(0,0xC000E048)&0x0002)?1:0);
Group_19_Item_2_DecodingProc = SetWordValue(0,0xC000E048,(GetInt()?0x0002:0)|(GetWordValue(0,0xC000E048)&~0x0002));
Group_20_Name = Interrupt Status Register (HDLC_ISR)
Group_20_Comment = "Interrupt Status Register (HDLC_ISR).\n•Address Offset: 004Ch.\n•Reset value: 0000h."
Group_20_ItemsNumber = 7
Group_20_CodingProc = SetString("0x"+GetWordValue(0,0xC000E04C).toString(16));
Group_20_Item_1_Name = RME
Group_20_Item_1_Comment = "Bit 0 = RME: Receive Message Error interrupt pending bit.\nWhen the end of the frame is detected and CRC check is fail or an abort is detected this pending bit is set, an interrupt request ,if it is enabled (RMEM = 1) is generated and the output trigger signal HRMC is actived if enabled (RMCE = 1)."
Group_20_Item_1_Type = 1,disabled,enabled
Group_20_Item_1_CodingProc = SetInt((GetWordValue(0,0xC000E04C)&0x0001)?1:0);
Group_20_Item_1_DecodingProc = SetWordValue(0,0xC000E04C,(GetInt()?0x0001:0)|(GetWordValue(0,0xC000E04C)&~0x0001));
Group_20_Item_2_Name = RMC
Group_20_Item_2_Comment = "Bit 1 = RMC: Receive Message Completed interrupt pending bit.\nWhen the end of the frame is detected and the CRC check is right this pending bit is set, an interrupt request ,if it is enabled (RMCM = 1) is generated and the output trigger signal HRMC is actived if enabled (RMCE = 1)"
Group_20_Item_2_Type = 1,disabled,enabled
Group_20_Item_2_CodingProc = SetInt((GetWordValue(0,0xC000E04C)&0x0002)?1:0);
Group_20_Item_2_DecodingProc = SetWordValue(0,0xC000E04C,(GetInt()?0x0002:0)|(GetWordValue(0,0xC000E04C)&~0x0002));
Group_20_Item_3_Name = RFO
Group_20_Item_3_Comment = "Bit 2 = RFO: Receive Frame Overflow interrupt pending bit\nWhen an overflow condition occurs, this pending bit is set and an interrupt request is generated if it is enabled (RFOM = 1)."
Group_20_Item_3_Type = 1,disabled,enabled
Group_20_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000E04C)&0x0004)?1:0);
Group_20_Item_3_DecodingProc = SetWordValue(0,0xC000E04C,(GetInt()?0x0004:0)|(GetWordValue(0,0xC000E04C)&~0x0004));
Group_20_Item_4_Name = RBF
Group_20_Item_4_Comment = "Bit 3 = RBF: Receive Buffer Full interrupt pending bit\nWhen the Receive Buffer is half full, this pending bit is set and if it is enabled (RBFM = 1) an interrupt is generated."
Group_20_Item_4_Type = 1,disabled,enabled
Group_20_Item_4_CodingProc = SetInt((GetWordValue(0,0xC000E04C)&0x0008)?1:0);
Group_20_Item_4_DecodingProc = SetWordValue(0,0xC000E04C,(GetInt()?0x0008:0)|(GetWordValue(0,0xC000E04C)&~0x0008));
Group_20_Item_5_Name = TDU
Group_20_Item_5_Comment = "Bit 4 = TDU: Transmission Data Underrun interrupt pending bit\nWhen an underrun condition occurs, this pending bit is set and an interrupt request is generated if it is enabled (TDUM = 1)."
Group_20_Item_5_Type = 1,disabled,enabled
Group_20_Item_5_CodingProc = SetInt((GetWordValue(0,0xC000E04C)&0x0010)?1:0);
Group_20_Item_5_DecodingProc = SetWordValue(0,0xC000E04C,(GetInt()?0x0010:0)|(GetWordValue(0,0xC000E04C)&~0x0010));
Group_20_Item_6_Name = TBE
Group_20_Item_6_Comment = "Bit 5 = TBE: Transmission Buffer Empty interrupt pending bit\nWhen the transmission buffer is half empty, this pending bit is set and if it is enabled (TBEM =1) an interrupt is generated."
Group_20_Item_6_Type = 1,disabled,enabled
Group_20_Item_6_CodingProc = SetInt((GetWordValue(0,0xC000E04C)&0x0020)?1:0);
Group_20_Item_6_DecodingProc = SetWordValue(0,0xC000E04C,(GetInt()?0x0020:0)|(GetWordValue(0,0xC000E04C)&~0x0020));
Group_20_Item_7_Name = TMC
Group_20_Item_7_Comment = "Bit 6 = TMC: Transmission Message Completed interrupt pending bit\nWhen the last bit of the closing flag or the postamble sequence if any has been transmitted this pending bit is set and an interrupt request ,if it is enabled (TMCM = 1) is generated the TEN bit in PCR is reset by hardware and the HRTS signal goes low."
Group_20_Item_7_Type = 1,disabled,enabled
Group_20_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000E04C)&0x0040)?1:0);
Group_20_Item_7_DecodingProc = SetWordValue(0,0xC000E04C,(GetInt()?0x0040:0)|(GetWordValue(0,0xC000E04C)&~0x0040));
Group_21_Name = Interrupt Mask Register (HDLC_IMR)
Group_21_Comment = "Interrupt Mask Register (HDLC_IMR).\n•Address Offset: 0050h.\n•Reset value: 0000h."
Group_21_ItemsNumber = 7
Group_21_CodingProc = SetString("0x"+GetWordValue(0,0xC000E050).toString(16));
Group_21_Item_1_Name = RMEM
Group_21_Item_1_Comment = "Bit 0 = RMEM: Receive Message Error interrupt mask bit.\n•When 0 the RME interrupt generation is disabled.\n•When 1 the RME interrupt generation is enabled."
Group_21_Item_1_Type = 1,disabled,enabled
Group_21_Item_1_CodingProc = SetInt((GetWordValue(0,0xC000E050)&0x0001)?1:0);
Group_21_Item_1_DecodingProc = SetWordValue(0,0xC000E050,(GetInt()?0x0001:0)|(GetWordValue(0,0xC000E050)&~0x0001));
Group_21_Item_2_Name = RMCM
Group_21_Item_2_Comment = "Bit 1 = RMCM: Receive Message Completed interrupt mask bit.\n•When 0 the RMC interrupt generation is disabled.\n•When 1 the RMC interrupt generation is enabled."
Group_21_Item_2_Type = 1,disabled,enabled
Group_21_Item_2_CodingProc = SetInt((GetWordValue(0,0xC000E050)&0x0002)?1:0);
Group_21_Item_2_DecodingProc = SetWordValue(0,0xC000E050,(GetInt()?0x0002:0)|(GetWordValue(0,0xC000E050)&~0x0002));
Group_21_Item_3_Name = RFOM
Group_21_Item_3_Comment = "Bit 2 = RFOM: Receive Frame Overflow interrupt mask bit.\n•When 0 the RFO interrupt generation is disabled.\n•When 1 the RFO interrupt generation is enabled."
Group_21_Item_3_Type = 1,disabled,enabled
Group_21_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000E050)&0x0004)?1:0);
Group_21_Item_3_DecodingProc = SetWordValue(0,0xC000E050,(GetInt()?0x0004:0)|(GetWordValue(0,0xC000E050)&~0x0004));
Group_21_Item_4_Name = RBFM
Group_21_Item_4_Comment = "Bit 3 = RBFM : Receive Buffer Full interrupt mask bit.\n•When 0 the RBF interrupt generation is disabled.\n•When 1 the RBF interrupt generation is enabled."
Group_21_Item_4_Type = 1,disabled,enabled
Group_21_Item_4_CodingProc = SetInt((GetWordValue(0,0xC000E050)&0x0008)?1:0);
Group_21_Item_4_DecodingProc = SetWordValue(0,0xC000E050,(GetInt()?0x0008:0)|(GetWordValue(0,0xC000E050)&~0x0008));
Group_21_Item_5_Name = TDUM
Group_21_Item_5_Comment = "Bit 4 = TDUM: Transmission Data Underrun interrupt mask bit.\n•When 0 the TDU interrupt generation is disabled.\n•When 1 the TDU interrupt generation is enabled."
Group_21_Item_5_Type = 1,disabled,enabled
Group_21_Item_5_CodingProc = SetInt((GetWordValue(0,0xC000E050)&0x0010)?1:0);
Group_21_Item_5_DecodingProc = SetWordValue(0,0xC000E050,(GetInt()?0x0010:0)|(GetWordValue(0,0xC000E050)&~0x0010));
Group_21_Item_6_Name = TBEM
Group_21_Item_6_Comment = "Bit 5 = TBEM: Transmission buffer empty interrupt mask bit.\n•When 0 the TBE interrupt generation is disabled.\n•When 1 the TBE interrupt generation is enabled."
Group_21_Item_6_Type = 1,disabled,enabled
Group_21_Item_6_CodingProc = SetInt((GetWordValue(0,0xC000E050)&0x0020)?1:0);
Group_21_Item_6_DecodingProc = SetWordValue(0,0xC000E050,(GetInt()?0x0020:0)|(GetWordValue(0,0xC000E050)&~0x0020));
Group_21_Item_7_Name = TMCM
Group_21_Item_7_Comment = "Bit 6 = TMCM: Transmission Message Completed interrupt mask bit.\n•When 0 the TMC interrupt generation is disabled.\n•When 1 the TMC interrupt generation is enabled."
Group_21_Item_7_Type = 1,disabled,enabled
Group_21_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000E050)&0x0040)?1:0);
Group_21_Item_7_DecodingProc = SetWordValue(0,0xC000E050,(GetInt()?0x0040:0)|(GetWordValue(0,0xC000E050)&~0x0040));
[SC]
SegmentsNumber = 1
Segment_1 = SC_SEG, 32, 0xC0005040, 0x54
SymbsNumber = 21
Symb_1 = SC_CLKVAL, 0, 0xC0005040
Symb_2 = SC_CLKCON, 0, 0xC0005044
ResetCode = {SetWordValue(0,0xC0005040,0x00);SetWordValue(0,0xC0005044,0x00);}
GroupsNumber = 2
Group_1_Name = SmartCard Clock Prescaler Value
Group_1_Comment = "The SC_CLKVAL register determines the SmartCard clock frequency. The value given in the register is multiplied by 2 to give the division factor of the input clock frequency."
Group_1_ItemsNumber = 1
Group_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0005040).toString(16));
Group_1_Item_1_Name = SCCLKVAL
Group_1_Item_1_Comment = "Bit 4:0 = SCCLKVAL [4:0].\nThese bits determine the source clock divider value. This value multiplied by 2 gives the clock.\ndivision factor:\nScClkVal4:0  Division\n•00000     Reserved - DO NOT PROGRAM THIS VALUE.\n•00001     divides the source clock frequency by 2.\n•00010     divides the source clock frequency by 4.\n"
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc =SetString("0x"+(GetWordValue(0,0xC0005040)&0x001F).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xC0005040,(parseInt(GetString()))&~0x001F);
Group_2_Name = SmartCard Clock Control Register
Group_2_Comment = "The SC_CLKCON register controls the source of the clock and determines whether the SmartCard clock output is enabled. The programmable divider and the output are reset when the enable bit is set to 0."
Group_2_ItemsNumber = 1
Group_2_CodingProc = SetString("0x"+GetWordValue(0,0xC0005044).toString(16));
Group_2_Item_1_Name = EN
Group_2_Item_1_Comment = "Bit 0 = EN.\nSmartCard clock generator enable bit.\n•0 stop clock, set output low and reset divider.\n•1 enable clock generator."
Group_2_Item_1_Type = 1,disabled,enabled
Group_2_Item_1_CodingProc = SetInt((GetWordValue(0,0xC0005044)&0x0001)?1:0);
Group_2_Item_1_DecodingProc = SetWordValue(0,0xC0005044,(GetInt()?0x0001:0)|(GetWordValue(0,0xC0005044)&~0x0001));
[UART0]
SegmentsNumber = 1
Segment_1 = UART_SEG, 32, 0xC0004000, 0x28
SymbsNumber = 10
Symb_1 = UART_BR, 0, 0xC0004000
Symb_2 = UART_TxBUFR, 0, 0xC0004004
Symb_3 = UART_RxBUFR, 0, 0xC0004008
Symb_4 = UART_CR, 0, 0xC000400C
Symb_5 = UART_IER, 0, 0xC0004010
Symb_6 = UART_SR, 0, 0xC0004014
Symb_7 = UART_GTR, 0, 0xC0004018
Symb_8 = UART_TOR, 0, 0xC000401C
Symb_9 = UART_TxRSTR, 0, 0xC0004020
Symb_10 = UART_RxRSTR, 0, 0xC0004024
ResetCode = {SetWordValue(0,0xC0004000,0x01);SetWordValue(0,0xC0004004,0x00);SetWordValue(0,0xC0004008,0x00);SetWordValue(0,0xC000400C,0x00);SetWordValue(0,0xC0004010,0x00);SetWordValue(0,0xC0004014,0x06);SetWordValue(0,0xC0004018,0x00);SetWordValue(0,0xC000401C,0x00);}
GroupsNumber = 9
Group_1_Name = UART BaudRate Register
Group_1_Comment = "The UARTn_BR register is the dual-function baud rate generator/reload register.\nA read from this register returns the content of the timer, writing to it updates the reload register."
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = BaudRate
Group_1_Item_1_Comment = "Bit 15:0 = BaudRate[15:0] UART Baudrate.\n•Write function: 16-bit reload value.\n•Read function: 16-bit count value."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0004000).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xC0004000,parseInt(GetString()));
Group_2_Name = UART TxBuffer Register
Group_2_Comment = "Writing to the transmit buffer register starts data transmission.\n•Bit 15:9 = Reserved, must be kept at reset value (0)."
Group_2_ItemsNumber = 3
Group_2_CodingProc = SetString("0x"+GetWordValue(0,0xC0004004).toString(16));
Group_2_Item_1_Name = TX[6:0]
Group_2_Item_1_Comment = "Bit 6:0 = TX[6:0]: Transmit buffer data D(6:0)"
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC0004004)&0x007F).toString(16));
Group_2_Item_1_DecodingProc = SetWordValue(0,0xC0004004,(parseInt(GetString()))&~0x007F);
Group_2_Item_2_Name = TX[7]
Group_2_Item_2_Comment = "Bit 7 = TX[7]: Transmit buffer data D7.\nTransmit buffer data D7 or parity bit - dependent on the operating mode (the setting of the Mode field in UARTn_CR register).\n•Note: If the Mode field selects a frame with parity bit, then the TX[7] bit will contain the parity bit (automatically generated by the UART). Writing ‘0’ or ‘1’ in this bit will have no effect on the transmitted frame."
Group_2_Item_2_Type = 1, Low, High
Group_2_Item_2_CodingProc = SetInt((GetWordValue(0,0xC0004004)&0x0080)?1:0);
Group_2_Item_2_DecodingProc = SetWordValue(0,0xC0004004,(GetInt()?0x0080:0)|(GetWordValue(0,0xC0004004)&~0x0080));
Group_2_Item_3_Name = TX[8]
Group_2_Item_3_Comment = "Bit 8 = TX[8]: Transmit buffer data D8.\nTransmit buffer data D8, or parity bit, or wake-up bit or undefined - dependent on the operating mode (the setting of the Mode field in UARTn_CR register).\n•Note: If the Mode field selects an 8 bit frame then this bit should be written as 0.•Note:If the Mode field selects a frame with parity bit, then the TX[8] bit will contain the parity bit (automatically generated by the UART). Writing ‘0’ or ‘1’ in this bit will have no effect on the transmitted frame."
Group_2_Item_3_Type = 1, Low, High
Group_2_Item_3_CodingProc = SetInt((GetWordValue(0,0xC0004004)&0x0100)?1:0);
Group_2_Item_3_DecodingProc = SetWordValue(0,0xC0004004,(GetInt()?0x0100:0)|(GetWordValue(0,0xC0004004)&~0x0100));
Group_3_Name = UART Control Register
Group_3_Comment = "This register controls the operating mode of the UART and contains control bits for mode and error check selection, and status flags for error identification.\n•Note: Programming the mode control field (Mode) to one of the reserved combinations may result in unpredictable behavior.\n•Note: Serial data transmission or reception is only possible when the baud rate generator run bit (Run) is set to 1. When the Run bit is set to 0, TXD will be 1. Setting the Run bit to 0 will immediately freeze the state of the transmitter and receiver. This should only be done when the UART is idle.\n•Bit 15:11= Reserved, always read as 0."
Group_3_ItemsNumber = 8
Group_3_CodingProc = SetString("0x"+GetWordValue(0,0xC000400C).toString(16));
Group_3_Item_1_Name = UART Mode control
Group_3_Item_1_Comment = "Bit 2:0 = Mode: UART Mode control.\n•000: reserved.\n•001: 8 bit data.\n•010: reserved.\n•011: 7 bit data + parity.\n•100: 9 bit data.\n•101: 8 bit data + wake up bit.\n•110: reserved.\n•111: 8 bit data + parity."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000400C)&0x0007).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xC000400C,(parseInt(GetString()))&~0x0007);
Group_3_Item_2_Name = Stop
Group_3_Item_2_Comment = "Bit 4:3 = Stop Bits: Number of stop bits selection.\nThese bits select the number of stop bits\n•00: 0.5 stop bits.\n•01: 1 stop bit.\n•10: 1.5 stop bits.\n•11: 2 stop bits."
Group_3_Item_2_Type = 0
Group_3_Item_2_CodingProc = SetString("0x"+(GetWordValue(0,0xC000400C)&0x0018).toString(16));
Group_3_Item_2_DecodingProc = SetWordValue(0,0xC000400C,(parseInt(GetString()))&~0x0018);
Group_3_Item_3_Name = ParityOdd
Group_3_Item_3_Comment = "Bit 5 = ParityOdd: Parity selection.\n•0: Even parity (parity bit set on odd number of ‘1’s in data).\n•1: Odd parity (parity bit set on even number of ‘1’s in data)."
Group_3_Item_3_Type = 1, Low, High
Group_3_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000400C)&0x0020)?1:0);
Group_3_Item_3_DecodingProc = SetWordValue(0,0xC000400C,(GetInt()?0x0020:0)|(GetWordValue(0,0xC000400C)&~0x0020));
Group_3_Item_4_Name = LoopBack
Group_3_Item_4_Comment = "Bit 6 = LoopBack: LoopBack mode enable.\n•0: Standard transmit/receive mode.\n•1: Loopback mode enabled.\n•Note: This bit may be modified only when the UART is inactive."
Group_3_Item_4_Type = 1, Low, High
Group_3_Item_4_CodingProc = SetInt((GetWordValue(0,0xC000400C)&0x0040)?1:0);
Group_3_Item_4_DecodingProc = SetWordValue(0,0xC000400C,(GetInt()?0x0040:0)|(GetWordValue(0,0xC000400C)&~0x0040));
Group_3_Item_5_Name = Run
Group_3_Item_5_Comment = "Bit 7 = Run: Baudrate generator Run bit.\n•0: Baud rate generator disabled (UART inactive).\n•1: Baud rate generator enabled."
Group_3_Item_5_Type = 1, Low, High
Group_3_Item_5_CodingProc = SetInt((GetWordValue(0,0xC000400C)&0x0080)?1:0);
Group_3_Item_5_DecodingProc = SetWordValue(0,0xC000400C,(GetInt()?0x0080:0)|(GetWordValue(0,0xC000400C)&~0x0080));
Group_3_Item_6_Name = RxEnable
Group_3_Item_6_Comment = "Bit 8 = RxEnable: Receiver Enable.\n•0: Receiver disabled.\n•1: Receiver enabled."
Group_3_Item_6_Type = 1, Low, High
Group_3_Item_6_CodingProc = SetInt((GetWordValue(0,0xC000400C)&0x0100)?1:0);
Group_3_Item_6_DecodingProc = SetWordValue(0,0xC000400C,(GetInt()?0x0100:0)|(GetWordValue(0,0xC000400C)&~0x0100));
Group_3_Item_7_Name = SCEnable
Group_3_Item_7_Comment = "Bit 9 = SCEnable - Reserved to SmartCard: Mode Enable.\n•0: SmartCard mode disabled.\n•1: SmartCard mode enabled.\nIf SmartCard mode is not used: Must be kept at 0."
Group_3_Item_7_Type = 1, Low, High
Group_3_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000400C)&0x0200)?1:0);
Group_3_Item_7_DecodingProc = SetWordValue(0,0xC000400C,(GetInt()?0x0200:0)|(GetWordValue(0,0xC000400C)&~0x0200));
Group_3_Item_8_Name = FifoEnable
Group_3_Item_8_Comment = "Bit 10 = FifoEnable: FIFO Enable.\n•0: FIFO mode disabled.\n•1: FIFO mode enabled."
Group_3_Item_8_Type = 1, Low, High
Group_3_Item_8_CodingProc = SetInt((GetWordValue(0,0xC000400C)&0x0400)?1:0);
Group_3_Item_8_DecodingProc = SetWordValue(0,0xC000400C,(GetInt()?0x0400:0)|(GetWordValue(0,0xC000400C)&~0x0400));
Group_4_Name = UART IntEnable Register
Group_4_Comment = "The UARTn_IE register enables the interrupt sources.\nInterrupts will occur when a status bit in the UARTn_SR register is 1, and the corresponding bit in the UARTn_IER register is 1.\n•Bit 15:9 = Reserved, always read as 0."
Group_4_ItemsNumber = 9
Group_4_CodingProc = SetString("0x"+GetWordValue(0,0xC0004010).toString(16));
Group_4_Item_1_Name = RxBufNotEmptyIE
Group_4_Item_1_Comment = "Bit 0 = RxBufNotEmptyIE: Receiver Buffer Not Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_1_Type = 1, Low, High
Group_4_Item_1_CodingProc = SetInt((GetWordValue(0,0xC0004010)&0x0001)?1:0);
Group_4_Item_1_DecodingProc = SetWordValue(0,0xC0004010,(GetInt()?0x0001:0)|(GetWordValue(0,0xC0004010)&~0x0001));
Group_4_Item_2_Name = TxEmptyIE
Group_4_Item_2_Comment = "Bit 1 = TxEmptyIE: Transmitter Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_2_Type = 1, Low, High
Group_4_Item_2_CodingProc = SetInt((GetWordValue(0,0xC0004010)&0x0002)?1:0);
Group_4_Item_2_DecodingProc = SetWordValue(0,0xC0004010,(GetInt()?0x0002:0)|(GetWordValue(0,0xC0004010)&~0x0002));
Group_4_Item_3_Name = TxHalfEmptyIE
Group_4_Item_3_Comment = "Bit 2 = TxHalfEmptyIE: Transmitter buffer Half Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_3_Type = 1, Low, High
Group_4_Item_3_CodingProc = SetInt((GetWordValue(0,0xC0004010)&0x0004)?1:0);
Group_4_Item_3_DecodingProc = SetWordValue(0,0xC0004010,(GetInt()?0x0004:0)|(GetWordValue(0,0xC0004010)&~0x0004));
Group_4_Item_4_Name = ParityErrorIE
Group_4_Item_4_Comment = "Bit 3 = ParityErrorIE: Parity Error Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_4_Type = 1, Low, High
Group_4_Item_4_CodingProc = SetInt((GetWordValue(0,0xC0004010)&0x0008)?1:0);
Group_4_Item_4_DecodingProc = SetWordValue(0,0xC0004010,(GetInt()?0x0008:0)|(GetWordValue(0,0xC0004010)&~0x0008));
Group_4_Item_5_Name = FrameErrorIE
Group_4_Item_5_Comment = "Bit 4 = FrameErrorIE: Framing Error Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_5_Type = 1, Low, High
Group_4_Item_5_CodingProc = SetInt((GetWordValue(0,0xC0004010)&0x0010)?1:0);
Group_4_Item_5_DecodingProc = SetWordValue(0,0xC0004010,(GetInt()?0x0010:0)|(GetWordValue(0,0xC0004010)&~0x0010));
Group_4_Item_6_Name = OverrunErrorIE
Group_4_Item_6_Comment = "Bit 5 = OverrunErrorIE: Overrun Error Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_6_Type = 1, Low, High
Group_4_Item_6_CodingProc = SetInt((GetWordValue(0,0xC0004010)&0x0020)?1:0);
Group_4_Item_6_DecodingProc = SetWordValue(0,0xC0004010,(GetInt()?0x0020:0)|(GetWordValue(0,0xC0004010)&~0x0020));
Group_4_Item_7_Name = TimeoutNotEmptyIE
Group_4_Item_7_Comment = "Bit 6 = TimeoutNotEmptyIE: Timeout Not Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_7_Type = 1, Low, High
Group_4_Item_7_CodingProc = SetInt((GetWordValue(0,0xC0004010)&0x0040)?1:0);
Group_4_Item_7_DecodingProc = SetWordValue(0,0xC0004010,(GetInt()?0x0040:0)|(GetWordValue(0,0xC0004010)&~0x0040));
Group_4_Item_8_Name = TimeoutIdleIE
Group_4_Item_8_Comment = "Bit 7 = TimeoutIdleIE: Timeout Idle Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_8_Type = 1, Low, High
Group_4_Item_8_CodingProc = SetInt((GetWordValue(0,0xC0004010)&0x0080)?1:0);
Group_4_Item_8_DecodingProc = SetWordValue(0,0xC0004010,(GetInt()?0x0080:0)|(GetWordValue(0,0xC0004010)&~0x0080));
Group_4_Item_9_Name = RxHalfFullIE
Group_4_Item_9_Comment = "Bit 8 = RxHalfFullIE: Receiver buffer Half Full Interrupt Enable.\n•0: interrupt disabled.\n•1: interrupt enabled."
Group_4_Item_9_Type = 1, Low, High
Group_4_Item_9_CodingProc = SetInt((GetWordValue(0,0xC0004010)&0x0100)?1:0);
Group_4_Item_9_DecodingProc = SetWordValue(0,0xC0004010,(GetInt()?0x0100:0)|(GetWordValue(0,0xC0004010)&~0x0100));
Group_5_Name = UART Status Register
Group_5_Comment = "The UARTn_SR register determines the cause of an interrupt.\n•Bit 15:10 = Reserved, always read as 0."
Group_5_ItemsNumber = 10
Group_5_CodingProc = SetString("0x"+GetWordValue(0,0xC0004014).toString(16));
Group_5_Item_1_Name = RxBufNotEmpty
Group_5_Item_1_Comment = "Bit 0 = RxBufNotEmpty: Rx Buffer not Empty.\nSet when RxFIFO not empty (RxFIFO contains at least one entry)."
Group_5_Item_1_Type = 1, Low, High
Group_5_Item_1_CodingProc = SetInt((GetWordValue(0,0xC0004014)&0x0001)?1:0);
Group_5_Item_2_Name = TxEmpty
Group_5_Item_2_Comment = "Bit 1 = TxEmpty: TxFIFO Empty.\nSet when transmit shift register is empty."
Group_5_Item_2_Type = 1, Low, High
Group_5_Item_2_CodingProc = SetInt((GetWordValue(0,0xC0004014)&0x0002)?1:0);
Group_5_Item_3_Name = TxHalfEmpty
Group_5_Item_3_Comment = "Bit 2 = TxHalfEmpty: TxFIFO Half Empty.\nSet when TxFIFO at least half empty."
Group_5_Item_3_Type = 1, Low, High
Group_5_Item_3_CodingProc = SetInt((GetWordValue(0,0xC0004014)&0x0004)?1:0);
Group_5_Item_4_Name = ParityError
Group_5_Item_4_Comment = "Bit 3 = ParityError: Parity Error.\nSet when the RxFIFO contains something received with a parity error"
Group_5_Item_4_Type = 1, Low, High
Group_5_Item_4_CodingProc = SetInt((GetWordValue(0,0xC0004014)&0x0008)?1:0);
Group_5_Item_5_Name = TimeoutIdleIE
Group_5_Item_5_Comment = "Bit 4 = FrameError: Frame Error.\nSet when the RxFIFO contains something received with a frame error."
Group_5_Item_5_Type = 1, Low, High
Group_5_Item_5_CodingProc = SetInt((GetWordValue(0,0xC0004014)&0x0010)?1:0);
Group_5_Item_6_Name = RxHalfFullIE
Group_5_Item_6_Comment = "Bit 5 = OverrunError: Overrun Error.\nSet when data is received and the RxFIFO is full."
Group_5_Item_6_Type = 1, Low, High
Group_5_Item_6_CodingProc = SetInt((GetWordValue(0,0xC0004014)&0x0020)?1:0);
Group_5_Item_7_Name = TimeoutNotEmptyIE
Group_5_Item_7_Comment = "Bit 6 = TimeoutNotEmpty: TimeoutNotEmpty.\nSet when there is a timeout and the RxFIFO is not empty."
Group_5_Item_7_Type = 1, Low, High
Group_5_Item_7_CodingProc = SetInt((GetWordValue(0,0xC0004014)&0x0040)?1:0);
Group_5_Item_8_Name = TimeoutIdle
Group_5_Item_8_Comment = "Bit 7 = TimeoutIdle: Timeout Idle.\nSet when there is a timeout and the RxFIFO is empty."
Group_5_Item_8_Type = 1, Low, High
Group_5_Item_8_CodingProc = SetInt((GetWordValue(0,0xC0004014)&0x0080)?1:0);
Group_5_Item_9_Name = RxHalfFullIE
Group_5_Item_9_Comment = "Bit 8 = RxHalfFull: RxFIFO Half Full.\nSet when the RxFIFO contains more than 8 characters."
Group_5_Item_9_Type = 1, Low, High
Group_5_Item_9_CodingProc = SetInt((GetWordValue(0,0xC0004014)&0x0100)?1:0);
Group_5_Item_10_Name = TxFull
Group_5_Item_10_Comment = "Bit 9 = TxFull: TxFIFO Full.\nSet when the TxFIFO contains 16 characters."
Group_5_Item_10_Type = 1, Low, High
Group_5_Item_10_CodingProc = SetInt((GetWordValue(0,0xC0004014)&0x0200)?1:0);
Group_6_Name = UART GuardTime Register
Group_6_Comment = "The UARTn_GTR register enables the user to define a programmable number of baud clocks to delay the assertion of TxEmpty.\n•Bit 15:8 = Reserved, always read as 0."
Group_6_ItemsNumber = 1
Group_6_CodingProc = SetString("0x"+GetWordValue(0,0xC0004018).toString(16));
Group_6_Item_1_Name = UART_GuardTime
Group_6_Item_1_Comment = "Bit 7:0 = UART_GuardTime.\nNumber of baud clocks to delay assertion of TxEmpty."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC0004018)&0x00FF).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xC0004018,(parseInt(GetString()))&~0x00FF);
Group_7_Name = UART Timeout Register
Group_7_Comment = "This register is to have a timeout system to be sure that not too much time pass between two successive received characters.\n•Bit 15:8 = Reserved, always read as 0."
Group_7_ItemsNumber = 1
Group_7_CodingProc = SetString("0x"+GetWordValue(0,0xC000401C).toString(16));
Group_7_Item_1_Name = UART_Timeout
Group_7_Item_1_Comment = "Bit 7:0 = UART_Timeout: Timeout.\nTimeout period in baud rate ticks."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000401C)&0x00FF).toString(16));
Group_7_Item_1_DecodingProc = SetWordValue(0,0xC000401C,(parseInt(GetString()))&~0x00FF);
Group_8_Name = UART TxReset Register
Group_8_Comment = "A write to this register empties the TxFIFO."
Group_8_ItemsNumber = 1
Group_8_Item_1_Name = UART TxReset Register
Group_8_Item_1_Comment = "UART TxReset Register.\n•Address Offset: 20h.\n•Reset value: Reserved."
Group_8_Item_1_Type = 0
Group_8_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0004020).toString(16));
Group_8_Item_1_DecodingProc = SetWordValue(0,0xC0004020,parseInt(GetString()));
Group_9_Name = UART RxReset Register
Group_9_Comment = "A write to this register empties the RxFIFO."
Group_9_ItemsNumber = 1
Group_9_Item_1_Name = UART RxReset Register
Group_9_Item_1_Comment = "UART RxReset Register.\n•Address Offset: 24h.\n•Reset Value: Reserved."
Group_9_Item_1_Type = 0
Group_9_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0004024).toString(16));
Group_9_Item_1_DecodingProc = SetWordValue(0,0xC0004024,parseInt(GetString()));
[UART1]
SegmentsNumber = 1
Segment_1 = UART_SEG, 32, 0xC0005000, 0x28
SymbsNumber = 10
Symb_1 = UART_BR, 0, 0xC0005000
Symb_2 = UART_TxBUFR, 0, 0xC0005004
Symb_3 = UART_RxBUFR, 0, 0xC0005008
Symb_4 = UART_CR, 0, 0xC000500C
Symb_5 = UART_IER, 0, 0xC0005010
Symb_6 = UART_SR, 0, 0xC0005014
Symb_7 = UART_GTR, 0, 0xC0005018
Symb_8 = UART_TOR, 0, 0xC000501C
Symb_9 = UART_TxRSTR, 0, 0xC0005020
Symb_10 = UART_RxRSTR, 0, 0xC0005024
ResetCode = {SetWordValue(0,0xC0005000,0x01);SetWordValue(0,0xC0005004,0x00);SetWordValue(0,0xC0005008,0x00);SetWordValue(0,0xC000500C,0x00);SetWordValue(0,0xC0005010,0x00);SetWordValue(0,0xC0005014,0x06);SetWordValue(0,0xC0005018,0x00);SetWordValue(0,0xC000501C,0x00);}
GroupsNumber = 9
Group_1_Name = UART BaudRate Register
Group_1_Comment = "The UARTn_BR register is the dual-function baud rate generator/reload register.\nA read from this register returns the content of the timer, writing to it updates the reload register."
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = BaudRate
Group_1_Item_1_Comment = "Bit 15:0 = BaudRate[15:0] UART Baudrate.\n•Write function: 16-bit reload value.\n•Read function: 16-bit count value."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0005000).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xC0005000,parseInt(GetString()));
Group_2_Name = UART TxBuffer Register
Group_2_Comment = "Writing to the transmit buffer register starts data transmission.\n•Bit 15:9 = Reserved, must be kept at reset value (0)."
Group_2_ItemsNumber = 3
Group_2_CodingProc = SetString("0x"+GetWordValue(0,0xC0005004).toString(16));
Group_2_Item_1_Name = TX[6:0]
Group_2_Item_1_Comment = "Bit 6:0 = TX[6:0]: Transmit buffer data D(6:0)"
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC0005004)&0x007F).toString(16));
Group_2_Item_1_DecodingProc = SetWordValue(0,0xC0005004,(parseInt(GetString()))&~0x007F);
Group_2_Item_2_Name = TX[7]
Group_2_Item_2_Comment = "Bit 7 = TX[7]: Transmit buffer data D7.\nTransmit buffer data D7 or parity bit - dependent on the operating mode (the setting of the Mode field in UARTn_CR register).\n•Note: If the Mode field selects a frame with parity bit, then the TX[7] bit will contain the parity bit (automatically generated by the UART). Writing ‘0’ or ‘1’ in this bit will have no effect on the transmitted frame."
Group_2_Item_2_Type = 1, Low, High
Group_2_Item_2_CodingProc = SetInt((GetWordValue(0,0xC0005004)&0x0080)?1:0);
Group_2_Item_2_DecodingProc = SetWordValue(0,0xC0005004,(GetInt()?0x0080:0)|(GetWordValue(0,0xC0005004)&~0x0080));
Group_2_Item_3_Name = TX[8]
Group_2_Item_3_Comment = "Bit 8 = TX[8]: Transmit buffer data D8.\nTransmit buffer data D8, or parity bit, or wake-up bit or undefined - dependent on the operating mode (the setting of the Mode field in UARTn_CR register).\n•Note: If the Mode field selects an 8 bit frame then this bit should be written as 0.•Note:If the Mode field selects a frame with parity bit, then the TX[8] bit will contain the parity bit (automatically generated by the UART). Writing ‘0’ or ‘1’ in this bit will have no effect on the transmitted frame."
Group_2_Item_3_Type = 1, Low, High
Group_2_Item_3_CodingProc = SetInt((GetWordValue(0,0xC0005004)&0x0100)?1:0);
Group_2_Item_3_DecodingProc = SetWordValue(0,0xC0005004,(GetInt()?0x0100:0)|(GetWordValue(0,0xC0005004)&~0x0100));
Group_3_Name = UART Control Register
Group_3_Comment = "This register controls the operating mode of the UART and contains control bits for mode and error check selection, and status flags for error identification.\n•Note: Programming the mode control field (Mode) to one of the reserved combinations may result in unpredictable behavior.\n•Note: Serial data transmission or reception is only possible when the baud rate generator run bit (Run) is set to 1. When the Run bit is set to 0, TXD will be 1. Setting the Run bit to 0 will immediately freeze the state of the transmitter and receiver. This should only be done when the UART is idle.\n•Bit 15:11= Reserved, always read as 0."
Group_3_ItemsNumber = 8
Group_3_CodingProc = SetString("0x"+GetWordValue(0,0xC000500C).toString(16));
Group_3_Item_1_Name = UART Mode control
Group_3_Item_1_Comment = "Bit 2:0 = Mode: UART Mode control.\n•000: reserved.\n•001: 8 bit data.\n•010: reserved.\n•011: 7 bit data + parity.\n•100: 9 bit data.\n•101: 8 bit data + wake up bit.\n•110: reserved.\n•111: 8 bit data + parity."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000500C)&0x0007).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xC000500C,(parseInt(GetString()))&~0x0007);
Group_3_Item_2_Name = Stop
Group_3_Item_2_Comment = "Bit 4:3 = Stop Bits: Number of stop bits selection.\nThese bits select the number of stop bits\n•00: 0.5 stop bits.\n•01: 1 stop bit.\n•10: 1.5 stop bits.\n•11: 2 stop bits."
Group_3_Item_2_Type = 0
Group_3_Item_2_CodingProc = SetString("0x"+(GetWordValue(0,0xC000500C)&0x0018).toString(16));
Group_3_Item_2_DecodingProc = SetWordValue(0,0xC000500C,(parseInt(GetString()))&~0x0018);
Group_3_Item_3_Name = ParityOdd
Group_3_Item_3_Comment = "Bit 5 = ParityOdd: Parity selection.\n•0: Even parity (parity bit set on odd number of ‘1’s in data).\n•1: Odd parity (parity bit set on even number of ‘1’s in data)."
Group_3_Item_3_Type = 1, Low, High
Group_3_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000500C)&0x0020)?1:0);
Group_3_Item_3_DecodingProc = SetWordValue(0,0xC000500C,(GetInt()?0x0020:0)|(GetWordValue(0,0xC000500C)&~0x0020));
Group_3_Item_4_Name = LoopBack
Group_3_Item_4_Comment = "Bit 6 = LoopBack: LoopBack mode enable.\n•0: Standard transmit/receive mode.\n•1: Loopback mode enabled.\n•Note: This bit may be modified only when the UART is inactive."
Group_3_Item_4_Type = 1, Low, High
Group_3_Item_4_CodingProc = SetInt((GetWordValue(0,0xC000500C)&0x0040)?1:0);
Group_3_Item_4_DecodingProc = SetWordValue(0,0xC000500C,(GetInt()?0x0040:0)|(GetWordValue(0,0xC000500C)&~0x0040));
Group_3_Item_5_Name = Run
Group_3_Item_5_Comment = "Bit 7 = Run: Baudrate generator Run bit.\n•0: Baud rate generator disabled (UART inactive).\n•1: Baud rate generator enabled."
Group_3_Item_5_Type = 1, Low, High
Group_3_Item_5_CodingProc = SetInt((GetWordValue(0,0xC000500C)&0x0080)?1:0);
Group_3_Item_5_DecodingProc = SetWordValue(0,0xC000500C,(GetInt()?0x0080:0)|(GetWordValue(0,0xC000500C)&~0x0080));
Group_3_Item_6_Name = RxEnable
Group_3_Item_6_Comment = "Bit 8 = RxEnable: Receiver Enable.\n•0: Receiver disabled.\n•1: Receiver enabled."
Group_3_Item_6_Type = 1, Low, High
Group_3_Item_6_CodingProc = SetInt((GetWordValue(0,0xC000500C)&0x0100)?1:0);
Group_3_Item_6_DecodingProc = SetWordValue(0,0xC000500C,(GetInt()?0x0100:0)|(GetWordValue(0,0xC000500C)&~0x0100));
Group_3_Item_7_Name = SCEnable
Group_3_Item_7_Comment = "Bit 9 = SCEnable - Reserved to SmartCard: Mode Enable.\n•0: SmartCard mode disabled.\n•1: SmartCard mode enabled.\nIf SmartCard mode is not used: Must be kept at 0."
Group_3_Item_7_Type = 1, Low, High
Group_3_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000500C)&0x0200)?1:0);
Group_3_Item_7_DecodingProc = SetWordValue(0,0xC000500C,(GetInt()?0x0200:0)|(GetWordValue(0,0xC000500C)&~0x0200));
Group_3_Item_8_Name = FifoEnable
Group_3_Item_8_Comment = "Bit 10 = FifoEnable: FIFO Enable.\n•0: FIFO mode disabled.\n•1: FIFO mode enabled."
Group_3_Item_8_Type = 1, Low, High
Group_3_Item_8_CodingProc = SetInt((GetWordValue(0,0xC000500C)&0x0400)?1:0);
Group_3_Item_8_DecodingProc = SetWordValue(0,0xC000500C,(GetInt()?0x0400:0)|(GetWordValue(0,0xC000500C)&~0x0400));
Group_4_Name = UART IntEnable Register
Group_4_Comment = "The UARTn_IE register enables the interrupt sources.\nInterrupts will occur when a status bit in the UARTn_SR register is 1, and the corresponding bit in the UARTn_IER register is 1.\n•Bit 15:9 = Reserved, always read as 0."
Group_4_ItemsNumber = 9
Group_4_CodingProc = SetString("0x"+GetWordValue(0,0xC0005010).toString(16));
Group_4_Item_1_Name = RxBufNotEmptyIE
Group_4_Item_1_Comment = "Bit 0 = RxBufNotEmptyIE: Receiver Buffer Not Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_1_Type = 1, Low, High
Group_4_Item_1_CodingProc = SetInt((GetWordValue(0,0xC0005010)&0x0001)?1:0);
Group_4_Item_1_DecodingProc = SetWordValue(0,0xC0005010,(GetInt()?0x0001:0)|(GetWordValue(0,0xC0005010)&~0x0001));
Group_4_Item_2_Name = TxEmptyIE
Group_4_Item_2_Comment = "Bit 1 = TxEmptyIE: Transmitter Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_2_Type = 1, Low, High
Group_4_Item_2_CodingProc = SetInt((GetWordValue(0,0xC0005010)&0x0002)?1:0);
Group_4_Item_2_DecodingProc = SetWordValue(0,0xC0005010,(GetInt()?0x0002:0)|(GetWordValue(0,0xC0005010)&~0x0002));
Group_4_Item_3_Name = TxHalfEmptyIE
Group_4_Item_3_Comment = "Bit 2 = TxHalfEmptyIE: Transmitter buffer Half Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_3_Type = 1, Low, High
Group_4_Item_3_CodingProc = SetInt((GetWordValue(0,0xC0005010)&0x0004)?1:0);
Group_4_Item_3_DecodingProc = SetWordValue(0,0xC0005010,(GetInt()?0x0004:0)|(GetWordValue(0,0xC0005010)&~0x0004));
Group_4_Item_4_Name = ParityErrorIE
Group_4_Item_4_Comment = "Bit 3 = ParityErrorIE: Parity Error Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_4_Type = 1, Low, High
Group_4_Item_4_CodingProc = SetInt((GetWordValue(0,0xC0005010)&0x0008)?1:0);
Group_4_Item_4_DecodingProc = SetWordValue(0,0xC0005010,(GetInt()?0x0008:0)|(GetWordValue(0,0xC0005010)&~0x0008));
Group_4_Item_5_Name = FrameErrorIE
Group_4_Item_5_Comment = "Bit 4 = FrameErrorIE: Framing Error Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_5_Type = 1, Low, High
Group_4_Item_5_CodingProc = SetInt((GetWordValue(0,0xC0005010)&0x0010)?1:0);
Group_4_Item_5_DecodingProc = SetWordValue(0,0xC0005010,(GetInt()?0x0010:0)|(GetWordValue(0,0xC0005010)&~0x0010));
Group_4_Item_6_Name = OverrunErrorIE
Group_4_Item_6_Comment = "Bit 5 = OverrunErrorIE: Overrun Error Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_6_Type = 1, Low, High
Group_4_Item_6_CodingProc = SetInt((GetWordValue(0,0xC0005010)&0x0020)?1:0);
Group_4_Item_6_DecodingProc = SetWordValue(0,0xC0005010,(GetInt()?0x0020:0)|(GetWordValue(0,0xC0005010)&~0x0020));
Group_4_Item_7_Name = TimeoutNotEmptyIE
Group_4_Item_7_Comment = "Bit 6 = TimeoutNotEmptyIE: Timeout Not Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_7_Type = 1, Low, High
Group_4_Item_7_CodingProc = SetInt((GetWordValue(0,0xC0005010)&0x0040)?1:0);
Group_4_Item_7_DecodingProc = SetWordValue(0,0xC0005010,(GetInt()?0x0040:0)|(GetWordValue(0,0xC0005010)&~0x0040));
Group_4_Item_8_Name = TimeoutIdleIE
Group_4_Item_8_Comment = "Bit 7 = TimeoutIdleIE: Timeout Idle Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_8_Type = 1, Low, High
Group_4_Item_8_CodingProc = SetInt((GetWordValue(0,0xC0005010)&0x0080)?1:0);
Group_4_Item_8_DecodingProc = SetWordValue(0,0xC0005010,(GetInt()?0x0080:0)|(GetWordValue(0,0xC0005010)&~0x0080));
Group_4_Item_9_Name = RxHalfFullIE
Group_4_Item_9_Comment = "Bit 8 = RxHalfFullIE: Receiver buffer Half Full Interrupt Enable.\n•0: interrupt disabled.\n•1: interrupt enabled."
Group_4_Item_9_Type = 1, Low, High
Group_4_Item_9_CodingProc = SetInt((GetWordValue(0,0xC0005010)&0x0100)?1:0);
Group_4_Item_9_DecodingProc = SetWordValue(0,0xC0005010,(GetInt()?0x0100:0)|(GetWordValue(0,0xC0005010)&~0x0100));
Group_5_Name = UART Status Register
Group_5_Comment = "The UARTn_SR register determines the cause of an interrupt.\n•Bit 15:10 = Reserved, always read as 0."
Group_5_ItemsNumber = 10
Group_5_CodingProc = SetString("0x"+GetWordValue(0,0xC0005014).toString(16));
Group_5_Item_1_Name = RxBufNotEmpty
Group_5_Item_1_Comment = "Bit 0 = RxBufNotEmpty: Rx Buffer not Empty.\nSet when RxFIFO not empty (RxFIFO contains at least one entry)."
Group_5_Item_1_Type = 1, Low, High
Group_5_Item_1_CodingProc = SetInt((GetWordValue(0,0xC0005014)&0x0001)?1:0);
Group_5_Item_2_Name = TxEmpty
Group_5_Item_2_Comment = "Bit 1 = TxEmpty: TxFIFO Empty.\nSet when transmit shift register is empty."
Group_5_Item_2_Type = 1, Low, High
Group_5_Item_2_CodingProc = SetInt((GetWordValue(0,0xC0005014)&0x0002)?1:0);
Group_5_Item_3_Name = TxHalfEmpty
Group_5_Item_3_Comment = "Bit 2 = TxHalfEmpty: TxFIFO Half Empty.\nSet when TxFIFO at least half empty."
Group_5_Item_3_Type = 1, Low, High
Group_5_Item_3_CodingProc = SetInt((GetWordValue(0,0xC0005014)&0x0004)?1:0);
Group_5_Item_4_Name = ParityError
Group_5_Item_4_Comment = "Bit 3 = ParityError: Parity Error.\nSet when the RxFIFO contains something received with a parity error"
Group_5_Item_4_Type = 1, Low, High
Group_5_Item_4_CodingProc = SetInt((GetWordValue(0,0xC0005014)&0x0008)?1:0);
Group_5_Item_5_Name = TimeoutIdleIE
Group_5_Item_5_Comment = "Bit 4 = FrameError: Frame Error.\nSet when the RxFIFO contains something received with a frame error."
Group_5_Item_5_Type = 1, Low, High
Group_5_Item_5_CodingProc = SetInt((GetWordValue(0,0xC0005014)&0x0010)?1:0);
Group_5_Item_6_Name = RxHalfFullIE
Group_5_Item_6_Comment = "Bit 5 = OverrunError: Overrun Error.\nSet when data is received and the RxFIFO is full."
Group_5_Item_6_Type = 1, Low, High
Group_5_Item_6_CodingProc = SetInt((GetWordValue(0,0xC0005014)&0x0020)?1:0);
Group_5_Item_7_Name = TimeoutNotEmptyIE
Group_5_Item_7_Comment = "Bit 6 = TimeoutNotEmpty: TimeoutNotEmpty.\nSet when there is a timeout and the RxFIFO is not empty."
Group_5_Item_7_Type = 1, Low, High
Group_5_Item_7_CodingProc = SetInt((GetWordValue(0,0xC0005014)&0x0040)?1:0);
Group_5_Item_8_Name = TimeoutIdle
Group_5_Item_8_Comment = "Bit 7 = TimeoutIdle: Timeout Idle.\nSet when there is a timeout and the RxFIFO is empty."
Group_5_Item_8_Type = 1, Low, High
Group_5_Item_8_CodingProc = SetInt((GetWordValue(0,0xC0005014)&0x0080)?1:0);
Group_5_Item_9_Name = RxHalfFullIE
Group_5_Item_9_Comment = "Bit 8 = RxHalfFull: RxFIFO Half Full.\nSet when the RxFIFO contains more than 8 characters."
Group_5_Item_9_Type = 1, Low, High
Group_5_Item_9_CodingProc = SetInt((GetWordValue(0,0xC0005014)&0x0100)?1:0);
Group_5_Item_10_Name = TxFull
Group_5_Item_10_Comment = "Bit 9 = TxFull: TxFIFO Full.\nSet when the TxFIFO contains 16 characters."
Group_5_Item_10_Type = 1, Low, High
Group_5_Item_10_CodingProc = SetInt((GetWordValue(0,0xC0005014)&0x0200)?1:0);
Group_6_Name = UART GuardTime Register
Group_6_Comment = "The UARTn_GTR register enables the user to define a programmable number of baud clocks to delay the assertion of TxEmpty.\n•Bit 15:8 = Reserved, always read as 0."
Group_6_ItemsNumber = 1
Group_6_CodingProc = SetString("0x"+GetWordValue(0,0xC0005018).toString(16));
Group_6_Item_1_Name = UART_GuardTime
Group_6_Item_1_Comment = "Bit 7:0 = UART_GuardTime.\nNumber of baud clocks to delay assertion of TxEmpty."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC0005018)&0x00FF).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xC0005018,(parseInt(GetString()))&~0x00FF);
Group_7_Name = UART Timeout Register
Group_7_Comment = "This register is to have a timeout system to be sure that not too much time pass between two successive received characters.\n•Bit 15:8 = Reserved, always read as 0."
Group_7_ItemsNumber = 1
Group_7_CodingProc = SetString("0x"+GetWordValue(0,0xC000501C).toString(16));
Group_7_Item_1_Name = UART_Timeout
Group_7_Item_1_Comment = "Bit 7:0 = UART_Timeout: Timeout.\nTimeout period in baud rate ticks."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000501C)&0x00FF).toString(16));
Group_7_Item_1_DecodingProc = SetWordValue(0,0xC000501C,(parseInt(GetString()))&~0x00FF);
Group_8_Name = UART TxReset Register
Group_8_Comment = "A write to this register empties the TxFIFO."
Group_8_ItemsNumber = 1
Group_8_Item_1_Name = UART TxReset Register
Group_8_Item_1_Comment = "UART TxReset Register.\n•Address Offset: 20h.\n•Reset value: Reserved."
Group_8_Item_1_Type = 0
Group_8_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0005020).toString(16));
Group_8_Item_1_DecodingProc = SetWordValue(0,0xC0005020,parseInt(GetString()));
Group_9_Name = UART RxReset Register
Group_9_Comment = "A write to this register empties the RxFIFO."
Group_9_ItemsNumber = 1
Group_9_Item_1_Name = UART RxReset Register
Group_9_Item_1_Comment = "UART RxReset Register.\n•Address Offset: 24h.\n•Reset Value: Reserved."
Group_9_Item_1_Type = 0
Group_9_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0005024).toString(16));
Group_9_Item_1_DecodingProc = SetWordValue(0,0xC0005024,parseInt(GetString()));
[UART2]
SegmentsNumber = 1
Segment_1 = UART_SEG, 32, 0xC0006000, 0x28
SymbsNumber = 10
Symb_1 = UART_BR, 0, 0xC0006000
Symb_2 = UART_TxBUFR, 0, 0xC0006004
Symb_3 = UART_RxBUFR, 0, 0xC0006008
Symb_4 = UART_CR, 0, 0xC000600C
Symb_5 = UART_IER, 0, 0xC0006010
Symb_6 = UART_SR, 0, 0xC0006014
Symb_7 = UART_GTR, 0, 0xC0006018
Symb_8 = UART_TOR, 0, 0xC000601C
Symb_9 = UART_TxRSTR, 0, 0xC0006020
Symb_10 = UART_RxRSTR, 0, 0xC0006024
ResetCode = {SetWordValue(0,0xC0006000,0x01);SetWordValue(0,0xC0006004,0x00);SetWordValue(0,0xC0006008,0x00);SetWordValue(0,0xC000600C,0x00);SetWordValue(0,0xC0006010,0x00);SetWordValue(0,0xC0006014,0x06);SetWordValue(0,0xC0006018,0x00);SetWordValue(0,0xC000601C,0x00);}
GroupsNumber = 9
Group_1_Name = UART BaudRate Register
Group_1_Comment = "The UARTn_BR register is the dual-function baud rate generator/reload register.\nA read from this register returns the content of the timer, writing to it updates the reload register."
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = BaudRate
Group_1_Item_1_Comment = "Bit 15:0 = BaudRate[15:0] UART Baudrate.\n•Write function: 16-bit reload value.\n•Read function: 16-bit count value."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0006000).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xC0006000,parseInt(GetString()));
Group_2_Name = UART TxBuffer Register
Group_2_Comment = "Writing to the transmit buffer register starts data transmission.\n•Bit 15:9 = Reserved, must be kept at reset value (0)."
Group_2_ItemsNumber = 3
Group_2_CodingProc = SetString("0x"+GetWordValue(0,0xC0006004).toString(16));
Group_2_Item_1_Name = TX[6:0]
Group_2_Item_1_Comment = "Bit 6:0 = TX[6:0]: Transmit buffer data D(6:0)"
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC0006004)&0x007F).toString(16));
Group_2_Item_1_DecodingProc = SetWordValue(0,0xC0006004,(parseInt(GetString()))&~0x007F);
Group_2_Item_2_Name = TX[7]
Group_2_Item_2_Comment = "Bit 7 = TX[7]: Transmit buffer data D7.\nTransmit buffer data D7 or parity bit - dependent on the operating mode (the setting of the Mode field in UARTn_CR register).\n•Note: If the Mode field selects a frame with parity bit, then the TX[7] bit will contain the parity bit (automatically generated by the UART). Writing ‘0’ or ‘1’ in this bit will have no effect on the transmitted frame."
Group_2_Item_2_Type = 1, Low, High
Group_2_Item_2_CodingProc = SetInt((GetWordValue(0,0xC0006004)&0x0080)?1:0);
Group_2_Item_2_DecodingProc = SetWordValue(0,0xC0006004,(GetInt()?0x0080:0)|(GetWordValue(0,0xC0006004)&~0x0080));
Group_2_Item_3_Name = TX[8]
Group_2_Item_3_Comment = "Bit 8 = TX[8]: Transmit buffer data D8.\nTransmit buffer data D8, or parity bit, or wake-up bit or undefined - dependent on the operating mode (the setting of the Mode field in UARTn_CR register).\n•Note: If the Mode field selects an 8 bit frame then this bit should be written as 0.•Note:If the Mode field selects a frame with parity bit, then the TX[8] bit will contain the parity bit (automatically generated by the UART). Writing ‘0’ or ‘1’ in this bit will have no effect on the transmitted frame."
Group_2_Item_3_Type = 1, Low, High
Group_2_Item_3_CodingProc = SetInt((GetWordValue(0,0xC0006004)&0x0100)?1:0);
Group_2_Item_3_DecodingProc = SetWordValue(0,0xC0006004,(GetInt()?0x0100:0)|(GetWordValue(0,0xC0006004)&~0x0100));
Group_3_Name = UART Control Register
Group_3_Comment = "This register controls the operating mode of the UART and contains control bits for mode and error check selection, and status flags for error identification.\n•Note: Programming the mode control field (Mode) to one of the reserved combinations may result in unpredictable behavior.\n•Note: Serial data transmission or reception is only possible when the baud rate generator run bit (Run) is set to 1. When the Run bit is set to 0, TXD will be 1. Setting the Run bit to 0 will immediately freeze the state of the transmitter and receiver. This should only be done when the UART is idle.\n•Bit 15:11= Reserved, always read as 0."
Group_3_ItemsNumber = 8
Group_3_CodingProc = SetString("0x"+GetWordValue(0,0xC000600C).toString(16));
Group_3_Item_1_Name = UART Mode control
Group_3_Item_1_Comment = "Bit 2:0 = Mode: UART Mode control.\n•000: reserved.\n•001: 8 bit data.\n•010: reserved.\n•011: 7 bit data + parity.\n•100: 9 bit data.\n•101: 8 bit data + wake up bit.\n•110: reserved.\n•111: 8 bit data + parity."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000600C)&0x0007).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xC000600C,(parseInt(GetString()))&~0x0007);
Group_3_Item_2_Name = Stop
Group_3_Item_2_Comment = "Bit 4:3 = Stop Bits: Number of stop bits selection.\nThese bits select the number of stop bits\n•00: 0.5 stop bits.\n•01: 1 stop bit.\n•10: 1.5 stop bits.\n•11: 2 stop bits."
Group_3_Item_2_Type = 0
Group_3_Item_2_CodingProc = SetString("0x"+(GetWordValue(0,0xC000600C)&0x0018).toString(16));
Group_3_Item_2_DecodingProc = SetWordValue(0,0xC000600C,(parseInt(GetString()))&~0x0018);
Group_3_Item_3_Name = ParityOdd
Group_3_Item_3_Comment = "Bit 5 = ParityOdd: Parity selection.\n•0: Even parity (parity bit set on odd number of ‘1’s in data).\n•1: Odd parity (parity bit set on even number of ‘1’s in data)."
Group_3_Item_3_Type = 1, Low, High
Group_3_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000600C)&0x0020)?1:0);
Group_3_Item_3_DecodingProc = SetWordValue(0,0xC000600C,(GetInt()?0x0020:0)|(GetWordValue(0,0xC000600C)&~0x0020));
Group_3_Item_4_Name = LoopBack
Group_3_Item_4_Comment = "Bit 6 = LoopBack: LoopBack mode enable.\n•0: Standard transmit/receive mode.\n•1: Loopback mode enabled.\n•Note: This bit may be modified only when the UART is inactive."
Group_3_Item_4_Type = 1, Low, High
Group_3_Item_4_CodingProc = SetInt((GetWordValue(0,0xC000600C)&0x0040)?1:0);
Group_3_Item_4_DecodingProc = SetWordValue(0,0xC000600C,(GetInt()?0x0040:0)|(GetWordValue(0,0xC000600C)&~0x0040));
Group_3_Item_5_Name = Run
Group_3_Item_5_Comment = "Bit 7 = Run: Baudrate generator Run bit.\n•0: Baud rate generator disabled (UART inactive).\n•1: Baud rate generator enabled."
Group_3_Item_5_Type = 1, Low, High
Group_3_Item_5_CodingProc = SetInt((GetWordValue(0,0xC000600C)&0x0080)?1:0);
Group_3_Item_5_DecodingProc = SetWordValue(0,0xC000600C,(GetInt()?0x0080:0)|(GetWordValue(0,0xC000600C)&~0x0080));
Group_3_Item_6_Name = RxEnable
Group_3_Item_6_Comment = "Bit 8 = RxEnable: Receiver Enable.\n•0: Receiver disabled.\n•1: Receiver enabled."
Group_3_Item_6_Type = 1, Low, High
Group_3_Item_6_CodingProc = SetInt((GetWordValue(0,0xC000600C)&0x0100)?1:0);
Group_3_Item_6_DecodingProc = SetWordValue(0,0xC000600C,(GetInt()?0x0100:0)|(GetWordValue(0,0xC000600C)&~0x0100));
Group_3_Item_7_Name = SCEnable
Group_3_Item_7_Comment = "Bit 9 = SCEnable - Reserved to SmartCard: Mode Enable.\n•0: SmartCard mode disabled.\n•1: SmartCard mode enabled.\nIf SmartCard mode is not used: Must be kept at 0."
Group_3_Item_7_Type = 1, Low, High
Group_3_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000600C)&0x0200)?1:0);
Group_3_Item_7_DecodingProc = SetWordValue(0,0xC000600C,(GetInt()?0x0200:0)|(GetWordValue(0,0xC000600C)&~0x0200));
Group_3_Item_8_Name = FifoEnable
Group_3_Item_8_Comment = "Bit 10 = FifoEnable: FIFO Enable.\n•0: FIFO mode disabled.\n•1: FIFO mode enabled."
Group_3_Item_8_Type = 1, Low, High
Group_3_Item_8_CodingProc = SetInt((GetWordValue(0,0xC000600C)&0x0400)?1:0);
Group_3_Item_8_DecodingProc = SetWordValue(0,0xC000600C,(GetInt()?0x0400:0)|(GetWordValue(0,0xC000600C)&~0x0400));
Group_4_Name = UART IntEnable Register
Group_4_Comment = "The UARTn_IE register enables the interrupt sources.\nInterrupts will occur when a status bit in the UARTn_SR register is 1, and the corresponding bit in the UARTn_IER register is 1.\n•Bit 15:9 = Reserved, always read as 0."
Group_4_ItemsNumber = 9
Group_4_CodingProc = SetString("0x"+GetWordValue(0,0xC0006010).toString(16));
Group_4_Item_1_Name = RxBufNotEmptyIE
Group_4_Item_1_Comment = "Bit 0 = RxBufNotEmptyIE: Receiver Buffer Not Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_1_Type = 1, Low, High
Group_4_Item_1_CodingProc = SetInt((GetWordValue(0,0xC0006010)&0x0001)?1:0);
Group_4_Item_1_DecodingProc = SetWordValue(0,0xC0006010,(GetInt()?0x0001:0)|(GetWordValue(0,0xC0006010)&~0x0001));
Group_4_Item_2_Name = TxEmptyIE
Group_4_Item_2_Comment = "Bit 1 = TxEmptyIE: Transmitter Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_2_Type = 1, Low, High
Group_4_Item_2_CodingProc = SetInt((GetWordValue(0,0xC0006010)&0x0002)?1:0);
Group_4_Item_2_DecodingProc = SetWordValue(0,0xC0006010,(GetInt()?0x0002:0)|(GetWordValue(0,0xC0006010)&~0x0002));
Group_4_Item_3_Name = TxHalfEmptyIE
Group_4_Item_3_Comment = "Bit 2 = TxHalfEmptyIE: Transmitter buffer Half Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_3_Type = 1, Low, High
Group_4_Item_3_CodingProc = SetInt((GetWordValue(0,0xC0006010)&0x0004)?1:0);
Group_4_Item_3_DecodingProc = SetWordValue(0,0xC0006010,(GetInt()?0x0004:0)|(GetWordValue(0,0xC0006010)&~0x0004));
Group_4_Item_4_Name = ParityErrorIE
Group_4_Item_4_Comment = "Bit 3 = ParityErrorIE: Parity Error Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_4_Type = 1, Low, High
Group_4_Item_4_CodingProc = SetInt((GetWordValue(0,0xC0006010)&0x0008)?1:0);
Group_4_Item_4_DecodingProc = SetWordValue(0,0xC0006010,(GetInt()?0x0008:0)|(GetWordValue(0,0xC0006010)&~0x0008));
Group_4_Item_5_Name = FrameErrorIE
Group_4_Item_5_Comment = "Bit 4 = FrameErrorIE: Framing Error Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_5_Type = 1, Low, High
Group_4_Item_5_CodingProc = SetInt((GetWordValue(0,0xC0006010)&0x0010)?1:0);
Group_4_Item_5_DecodingProc = SetWordValue(0,0xC0006010,(GetInt()?0x0010:0)|(GetWordValue(0,0xC0006010)&~0x0010));
Group_4_Item_6_Name = OverrunErrorIE
Group_4_Item_6_Comment = "Bit 5 = OverrunErrorIE: Overrun Error Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_6_Type = 1, Low, High
Group_4_Item_6_CodingProc = SetInt((GetWordValue(0,0xC0006010)&0x0020)?1:0);
Group_4_Item_6_DecodingProc = SetWordValue(0,0xC0006010,(GetInt()?0x0020:0)|(GetWordValue(0,0xC0006010)&~0x0020));
Group_4_Item_7_Name = TimeoutNotEmptyIE
Group_4_Item_7_Comment = "Bit 6 = TimeoutNotEmptyIE: Timeout Not Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_7_Type = 1, Low, High
Group_4_Item_7_CodingProc = SetInt((GetWordValue(0,0xC0006010)&0x0040)?1:0);
Group_4_Item_7_DecodingProc = SetWordValue(0,0xC0006010,(GetInt()?0x0040:0)|(GetWordValue(0,0xC0006010)&~0x0040));
Group_4_Item_8_Name = TimeoutIdleIE
Group_4_Item_8_Comment = "Bit 7 = TimeoutIdleIE: Timeout Idle Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_8_Type = 1, Low, High
Group_4_Item_8_CodingProc = SetInt((GetWordValue(0,0xC0006010)&0x0080)?1:0);
Group_4_Item_8_DecodingProc = SetWordValue(0,0xC0006010,(GetInt()?0x0080:0)|(GetWordValue(0,0xC0006010)&~0x0080));
Group_4_Item_9_Name = RxHalfFullIE
Group_4_Item_9_Comment = "Bit 8 = RxHalfFullIE: Receiver buffer Half Full Interrupt Enable.\n•0: interrupt disabled.\n•1: interrupt enabled."
Group_4_Item_9_Type = 1, Low, High
Group_4_Item_9_CodingProc = SetInt((GetWordValue(0,0xC0006010)&0x0100)?1:0);
Group_4_Item_9_DecodingProc = SetWordValue(0,0xC0006010,(GetInt()?0x0100:0)|(GetWordValue(0,0xC0006010)&~0x0100));
Group_5_Name = UART Status Register
Group_5_Comment = "The UARTn_SR register determines the cause of an interrupt.\n•Bit 15:10 = Reserved, always read as 0."
Group_5_ItemsNumber = 10
Group_5_CodingProc = SetString("0x"+GetWordValue(0,0xC0006014).toString(16));
Group_5_Item_1_Name = RxBufNotEmpty
Group_5_Item_1_Comment = "Bit 0 = RxBufNotEmpty: Rx Buffer not Empty.\nSet when RxFIFO not empty (RxFIFO contains at least one entry)."
Group_5_Item_1_Type = 1, Low, High
Group_5_Item_1_CodingProc = SetInt((GetWordValue(0,0xC0006014)&0x0001)?1:0);
Group_5_Item_2_Name = TxEmpty
Group_5_Item_2_Comment = "Bit 1 = TxEmpty: TxFIFO Empty.\nSet when transmit shift register is empty."
Group_5_Item_2_Type = 1, Low, High
Group_5_Item_2_CodingProc = SetInt((GetWordValue(0,0xC0006014)&0x0002)?1:0);
Group_5_Item_3_Name = TxHalfEmpty
Group_5_Item_3_Comment = "Bit 2 = TxHalfEmpty: TxFIFO Half Empty.\nSet when TxFIFO at least half empty."
Group_5_Item_3_Type = 1, Low, High
Group_5_Item_3_CodingProc = SetInt((GetWordValue(0,0xC0006014)&0x0004)?1:0);
Group_5_Item_4_Name = ParityError
Group_5_Item_4_Comment = "Bit 3 = ParityError: Parity Error.\nSet when the RxFIFO contains something received with a parity error"
Group_5_Item_4_Type = 1, Low, High
Group_5_Item_4_CodingProc = SetInt((GetWordValue(0,0xC0006014)&0x0008)?1:0);
Group_5_Item_5_Name = TimeoutIdleIE
Group_5_Item_5_Comment = "Bit 4 = FrameError: Frame Error.\nSet when the RxFIFO contains something received with a frame error."
Group_5_Item_5_Type = 1, Low, High
Group_5_Item_5_CodingProc = SetInt((GetWordValue(0,0xC0006014)&0x0010)?1:0);
Group_5_Item_6_Name = RxHalfFullIE
Group_5_Item_6_Comment = "Bit 5 = OverrunError: Overrun Error.\nSet when data is received and the RxFIFO is full."
Group_5_Item_6_Type = 1, Low, High
Group_5_Item_6_CodingProc = SetInt((GetWordValue(0,0xC0006014)&0x0020)?1:0);
Group_5_Item_7_Name = TimeoutNotEmptyIE
Group_5_Item_7_Comment = "Bit 6 = TimeoutNotEmpty: TimeoutNotEmpty.\nSet when there is a timeout and the RxFIFO is not empty."
Group_5_Item_7_Type = 1, Low, High
Group_5_Item_7_CodingProc = SetInt((GetWordValue(0,0xC0006014)&0x0040)?1:0);
Group_5_Item_8_Name = TimeoutIdle
Group_5_Item_8_Comment = "Bit 7 = TimeoutIdle: Timeout Idle.\nSet when there is a timeout and the RxFIFO is empty."
Group_5_Item_8_Type = 1, Low, High
Group_5_Item_8_CodingProc = SetInt((GetWordValue(0,0xC0006014)&0x0080)?1:0);
Group_5_Item_9_Name = RxHalfFullIE
Group_5_Item_9_Comment = "Bit 8 = RxHalfFull: RxFIFO Half Full.\nSet when the RxFIFO contains more than 8 characters."
Group_5_Item_9_Type = 1, Low, High
Group_5_Item_9_CodingProc = SetInt((GetWordValue(0,0xC0006014)&0x0100)?1:0);
Group_5_Item_10_Name = TxFull
Group_5_Item_10_Comment = "Bit 9 = TxFull: TxFIFO Full.\nSet when the TxFIFO contains 16 characters."
Group_5_Item_10_Type = 1, Low, High
Group_5_Item_10_CodingProc = SetInt((GetWordValue(0,0xC0006014)&0x0200)?1:0);
Group_6_Name = UART GuardTime Register
Group_6_Comment = "The UARTn_GTR register enables the user to define a programmable number of baud clocks to delay the assertion of TxEmpty.\n•Bit 15:8 = Reserved, always read as 0."
Group_6_ItemsNumber = 1
Group_6_CodingProc = SetString("0x"+GetWordValue(0,0xC0006018).toString(16));
Group_6_Item_1_Name = UART_GuardTime
Group_6_Item_1_Comment = "Bit 7:0 = UART_GuardTime.\nNumber of baud clocks to delay assertion of TxEmpty."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC0006018)&0x00FF).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xC0006018,(parseInt(GetString()))&~0x00FF);
Group_7_Name = UART Timeout Register
Group_7_Comment = "This register is to have a timeout system to be sure that not too much time pass between two successive received characters.\n•Bit 15:8 = Reserved, always read as 0."
Group_7_ItemsNumber = 1
Group_7_CodingProc = SetString("0x"+GetWordValue(0,0xC000601C).toString(16));
Group_7_Item_1_Name = UART_Timeout
Group_7_Item_1_Comment = "Bit 7:0 = UART_Timeout: Timeout.\nTimeout period in baud rate ticks."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000601C)&0x00FF).toString(16));
Group_7_Item_1_DecodingProc = SetWordValue(0,0xC000601C,(parseInt(GetString()))&~0x00FF);
Group_8_Name = UART TxReset Register
Group_8_Comment = "A write to this register empties the TxFIFO."
Group_8_ItemsNumber = 1
Group_8_Item_1_Name = UART TxReset Register
Group_8_Item_1_Comment = "UART TxReset Register.\n•Address Offset: 20h.\n•Reset value: Reserved."
Group_8_Item_1_Type = 0
Group_8_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0006020).toString(16));
Group_8_Item_1_DecodingProc = SetWordValue(0,0xC0006020,parseInt(GetString()));
Group_9_Name = UART RxReset Register
Group_9_Comment = "A write to this register empties the RxFIFO."
Group_9_ItemsNumber = 1
Group_9_Item_1_Name = UART RxReset Register
Group_9_Item_1_Comment = "UART RxReset Register.\n•Address Offset: 24h.\n•Reset Value: Reserved."
Group_9_Item_1_Type = 0
Group_9_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0006024).toString(16));
Group_9_Item_1_DecodingProc = SetWordValue(0,0xC0006024,parseInt(GetString()));
[UART3]
SegmentsNumber = 1
Segment_1 = UART_SEG, 32, 0xC0007000, 0x28
SymbsNumber = 10
Symb_1 = UART_BR, 0, 0xC0007000
Symb_2 = UART_TxBUFR, 0, 0xC0007004
Symb_3 = UART_RxBUFR, 0, 0xC0007008
Symb_4 = UART_CR, 0, 0xC000700C
Symb_5 = UART_IER, 0, 0xC0007010
Symb_6 = UART_SR, 0, 0xC0007014
Symb_7 = UART_GTR, 0, 0xC0007018
Symb_8 = UART_TOR, 0, 0xC000701C
Symb_9 = UART_TxRSTR, 0, 0xC0007020
Symb_10 = UART_RxRSTR, 0, 0xC0007024
ResetCode = {SetWordValue(0,0xC0007000,0x01);SetWordValue(0,0xC0007004,0x00);SetWordValue(0,0xC0007008,0x00);SetWordValue(0,0xC000700C,0x00);SetWordValue(0,0xC0007010,0x00);SetWordValue(0,0xC0007014,0x06);SetWordValue(0,0xC0007018,0x00);SetWordValue(0,0xC000701C,0x00);}
GroupsNumber = 9
Group_1_Name = UART BaudRate Register
Group_1_Comment = "The UARTn_BR register is the dual-function baud rate generator/reload register.\nA read from this register returns the content of the timer, writing to it updates the reload register."
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = BaudRate
Group_1_Item_1_Comment = "Bit 15:0 = BaudRate[15:0] UART Baudrate.\n•Write function: 16-bit reload value.\n•Read function: 16-bit count value."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0007000).toString(16));
Group_1_Item_1_DecodingProc = SetWordValue(0,0xC0007000,parseInt(GetString()));
Group_2_Name = UART TxBuffer Register
Group_2_Comment = "Writing to the transmit buffer register starts data transmission.\n•Bit 15:9 = Reserved, must be kept at reset value (0)."
Group_2_ItemsNumber = 3
Group_2_CodingProc = SetString("0x"+GetWordValue(0,0xC0007004).toString(16));
Group_2_Item_1_Name = TX[6:0]
Group_2_Item_1_Comment = "Bit 6:0 = TX[6:0]: Transmit buffer data D(6:0)"
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC0007004)&0x007F).toString(16));
Group_2_Item_1_DecodingProc = SetWordValue(0,0xC0007004,(parseInt(GetString()))&~0x007F);
Group_2_Item_2_Name = TX[7]
Group_2_Item_2_Comment = "Bit 7 = TX[7]: Transmit buffer data D7.\nTransmit buffer data D7 or parity bit - dependent on the operating mode (the setting of the Mode field in UARTn_CR register).\n•Note: If the Mode field selects a frame with parity bit, then the TX[7] bit will contain the parity bit (automatically generated by the UART). Writing ‘0’ or ‘1’ in this bit will have no effect on the transmitted frame."
Group_2_Item_2_Type = 1, Low, High
Group_2_Item_2_CodingProc = SetInt((GetWordValue(0,0xC0007004)&0x0080)?1:0);
Group_2_Item_2_DecodingProc = SetWordValue(0,0xC0007004,(GetInt()?0x0080:0)|(GetWordValue(0,0xC0007004)&~0x0080));
Group_2_Item_3_Name = TX[8]
Group_2_Item_3_Comment = "Bit 8 = TX[8]: Transmit buffer data D8.\nTransmit buffer data D8, or parity bit, or wake-up bit or undefined - dependent on the operating mode (the setting of the Mode field in UARTn_CR register).\n•Note: If the Mode field selects an 8 bit frame then this bit should be written as 0.•Note:If the Mode field selects a frame with parity bit, then the TX[8] bit will contain the parity bit (automatically generated by the UART). Writing ‘0’ or ‘1’ in this bit will have no effect on the transmitted frame."
Group_2_Item_3_Type = 1, Low, High
Group_2_Item_3_CodingProc = SetInt((GetWordValue(0,0xC0007004)&0x0100)?1:0);
Group_2_Item_3_DecodingProc = SetWordValue(0,0xC0007004,(GetInt()?0x0100:0)|(GetWordValue(0,0xC0007004)&~0x0100));
Group_3_Name = UART Control Register
Group_3_Comment = "This register controls the operating mode of the UART and contains control bits for mode and error check selection, and status flags for error identification.\n•Note: Programming the mode control field (Mode) to one of the reserved combinations may result in unpredictable behavior.\n•Note: Serial data transmission or reception is only possible when the baud rate generator run bit (Run) is set to 1. When the Run bit is set to 0, TXD will be 1. Setting the Run bit to 0 will immediately freeze the state of the transmitter and receiver. This should only be done when the UART is idle.\n•Bit 15:11= Reserved, always read as 0."
Group_3_ItemsNumber = 8
Group_3_CodingProc = SetString("0x"+GetWordValue(0,0xC000700C).toString(16));
Group_3_Item_1_Name = UART Mode control
Group_3_Item_1_Comment = "Bit 2:0 = Mode: UART Mode control.\n•000: reserved.\n•001: 8 bit data.\n•010: reserved.\n•011: 7 bit data + parity.\n•100: 9 bit data.\n•101: 8 bit data + wake up bit.\n•110: reserved.\n•111: 8 bit data + parity."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000700C)&0x0007).toString(16));
Group_3_Item_1_DecodingProc = SetWordValue(0,0xC000700C,(parseInt(GetString()))&~0x0007);
Group_3_Item_2_Name = Stop
Group_3_Item_2_Comment = "Bit 4:3 = Stop Bits: Number of stop bits selection.\nThese bits select the number of stop bits\n•00: 0.5 stop bits.\n•01: 1 stop bit.\n•10: 1.5 stop bits.\n•11: 2 stop bits."
Group_3_Item_2_Type = 0
Group_3_Item_2_CodingProc = SetString("0x"+(GetWordValue(0,0xC000700C)&0x0018).toString(16));
Group_3_Item_2_DecodingProc = SetWordValue(0,0xC000700C,(parseInt(GetString()))&~0x0018);
Group_3_Item_3_Name = ParityOdd
Group_3_Item_3_Comment = "Bit 5 = ParityOdd: Parity selection.\n•0: Even parity (parity bit set on odd number of ‘1’s in data).\n•1: Odd parity (parity bit set on even number of ‘1’s in data)."
Group_3_Item_3_Type = 1, Low, High
Group_3_Item_3_CodingProc = SetInt((GetWordValue(0,0xC000700C)&0x0020)?1:0);
Group_3_Item_3_DecodingProc = SetWordValue(0,0xC000700C,(GetInt()?0x0020:0)|(GetWordValue(0,0xC000700C)&~0x0020));
Group_3_Item_4_Name = LoopBack
Group_3_Item_4_Comment = "Bit 6 = LoopBack: LoopBack mode enable.\n•0: Standard transmit/receive mode.\n•1: Loopback mode enabled.\n•Note: This bit may be modified only when the UART is inactive."
Group_3_Item_4_Type = 1, Low, High
Group_3_Item_4_CodingProc = SetInt((GetWordValue(0,0xC000700C)&0x0040)?1:0);
Group_3_Item_4_DecodingProc = SetWordValue(0,0xC000700C,(GetInt()?0x0040:0)|(GetWordValue(0,0xC000700C)&~0x0040));
Group_3_Item_5_Name = Run
Group_3_Item_5_Comment = "Bit 7 = Run: Baudrate generator Run bit.\n•0: Baud rate generator disabled (UART inactive).\n•1: Baud rate generator enabled."
Group_3_Item_5_Type = 1, Low, High
Group_3_Item_5_CodingProc = SetInt((GetWordValue(0,0xC000700C)&0x0080)?1:0);
Group_3_Item_5_DecodingProc = SetWordValue(0,0xC000700C,(GetInt()?0x0080:0)|(GetWordValue(0,0xC000700C)&~0x0080));
Group_3_Item_6_Name = RxEnable
Group_3_Item_6_Comment = "Bit 8 = RxEnable: Receiver Enable.\n•0: Receiver disabled.\n•1: Receiver enabled."
Group_3_Item_6_Type = 1, Low, High
Group_3_Item_6_CodingProc = SetInt((GetWordValue(0,0xC000700C)&0x0100)?1:0);
Group_3_Item_6_DecodingProc = SetWordValue(0,0xC000700C,(GetInt()?0x0100:0)|(GetWordValue(0,0xC000700C)&~0x0100));
Group_3_Item_7_Name = SCEnable
Group_3_Item_7_Comment = "Bit 9 = SCEnable - Reserved to SmartCard: Mode Enable.\n•0: SmartCard mode disabled.\n•1: SmartCard mode enabled.\nIf SmartCard mode is not used: Must be kept at 0."
Group_3_Item_7_Type = 1, Low, High
Group_3_Item_7_CodingProc = SetInt((GetWordValue(0,0xC000700C)&0x0200)?1:0);
Group_3_Item_7_DecodingProc = SetWordValue(0,0xC000700C,(GetInt()?0x0200:0)|(GetWordValue(0,0xC000700C)&~0x0200));
Group_3_Item_8_Name = FifoEnable
Group_3_Item_8_Comment = "Bit 10 = FifoEnable: FIFO Enable.\n•0: FIFO mode disabled.\n•1: FIFO mode enabled."
Group_3_Item_8_Type = 1, Low, High
Group_3_Item_8_CodingProc = SetInt((GetWordValue(0,0xC000700C)&0x0400)?1:0);
Group_3_Item_8_DecodingProc = SetWordValue(0,0xC000700C,(GetInt()?0x0400:0)|(GetWordValue(0,0xC000700C)&~0x0400));
Group_4_Name = UART IntEnable Register
Group_4_Comment = "The UARTn_IE register enables the interrupt sources.\nInterrupts will occur when a status bit in the UARTn_SR register is 1, and the corresponding bit in the UARTn_IER register is 1.\n•Bit 15:9 = Reserved, always read as 0."
Group_4_ItemsNumber = 9
Group_4_CodingProc = SetString("0x"+GetWordValue(0,0xC0007010).toString(16));
Group_4_Item_1_Name = RxBufNotEmptyIE
Group_4_Item_1_Comment = "Bit 0 = RxBufNotEmptyIE: Receiver Buffer Not Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_1_Type = 1, Low, High
Group_4_Item_1_CodingProc = SetInt((GetWordValue(0,0xC0007010)&0x0001)?1:0);
Group_4_Item_1_DecodingProc = SetWordValue(0,0xC0007010,(GetInt()?0x0001:0)|(GetWordValue(0,0xC0007010)&~0x0001));
Group_4_Item_2_Name = TxEmptyIE
Group_4_Item_2_Comment = "Bit 1 = TxEmptyIE: Transmitter Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_2_Type = 1, Low, High
Group_4_Item_2_CodingProc = SetInt((GetWordValue(0,0xC0007010)&0x0002)?1:0);
Group_4_Item_2_DecodingProc = SetWordValue(0,0xC0007010,(GetInt()?0x0002:0)|(GetWordValue(0,0xC0007010)&~0x0002));
Group_4_Item_3_Name = TxHalfEmptyIE
Group_4_Item_3_Comment = "Bit 2 = TxHalfEmptyIE: Transmitter buffer Half Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_3_Type = 1, Low, High
Group_4_Item_3_CodingProc = SetInt((GetWordValue(0,0xC0007010)&0x0004)?1:0);
Group_4_Item_3_DecodingProc = SetWordValue(0,0xC0007010,(GetInt()?0x0004:0)|(GetWordValue(0,0xC0007010)&~0x0004));
Group_4_Item_4_Name = ParityErrorIE
Group_4_Item_4_Comment = "Bit 3 = ParityErrorIE: Parity Error Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_4_Type = 1, Low, High
Group_4_Item_4_CodingProc = SetInt((GetWordValue(0,0xC0007010)&0x0008)?1:0);
Group_4_Item_4_DecodingProc = SetWordValue(0,0xC0007010,(GetInt()?0x0008:0)|(GetWordValue(0,0xC0007010)&~0x0008));
Group_4_Item_5_Name = FrameErrorIE
Group_4_Item_5_Comment = "Bit 4 = FrameErrorIE: Framing Error Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_5_Type = 1, Low, High
Group_4_Item_5_CodingProc = SetInt((GetWordValue(0,0xC0007010)&0x0010)?1:0);
Group_4_Item_5_DecodingProc = SetWordValue(0,0xC0007010,(GetInt()?0x0010:0)|(GetWordValue(0,0xC0007010)&~0x0010));
Group_4_Item_6_Name = OverrunErrorIE
Group_4_Item_6_Comment = "Bit 5 = OverrunErrorIE: Overrun Error Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_6_Type = 1, Low, High
Group_4_Item_6_CodingProc = SetInt((GetWordValue(0,0xC0007010)&0x0020)?1:0);
Group_4_Item_6_DecodingProc = SetWordValue(0,0xC0007010,(GetInt()?0x0020:0)|(GetWordValue(0,0xC0007010)&~0x0020));
Group_4_Item_7_Name = TimeoutNotEmptyIE
Group_4_Item_7_Comment = "Bit 6 = TimeoutNotEmptyIE: Timeout Not Empty Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_7_Type = 1, Low, High
Group_4_Item_7_CodingProc = SetInt((GetWordValue(0,0xC0007010)&0x0040)?1:0);
Group_4_Item_7_DecodingProc = SetWordValue(0,0xC0007010,(GetInt()?0x0040:0)|(GetWordValue(0,0xC0007010)&~0x0040));
Group_4_Item_8_Name = TimeoutIdleIE
Group_4_Item_8_Comment = "Bit 7 = TimeoutIdleIE: Timeout Idle Interrupt Enable.\n•0: Interrupt disabled.\n•1: Interrupt enabled."
Group_4_Item_8_Type = 1, Low, High
Group_4_Item_8_CodingProc = SetInt((GetWordValue(0,0xC0007010)&0x0080)?1:0);
Group_4_Item_8_DecodingProc = SetWordValue(0,0xC0007010,(GetInt()?0x0080:0)|(GetWordValue(0,0xC0007010)&~0x0080));
Group_4_Item_9_Name = RxHalfFullIE
Group_4_Item_9_Comment = "Bit 8 = RxHalfFullIE: Receiver buffer Half Full Interrupt Enable.\n•0: interrupt disabled.\n•1: interrupt enabled."
Group_4_Item_9_Type = 1, Low, High
Group_4_Item_9_CodingProc = SetInt((GetWordValue(0,0xC0007010)&0x0100)?1:0);
Group_4_Item_9_DecodingProc = SetWordValue(0,0xC0007010,(GetInt()?0x0100:0)|(GetWordValue(0,0xC0007010)&~0x0100));
Group_5_Name = UART Status Register
Group_5_Comment = "The UARTn_SR register determines the cause of an interrupt.\n•Bit 15:10 = Reserved, always read as 0."
Group_5_ItemsNumber = 10
Group_5_CodingProc = SetString("0x"+GetWordValue(0,0xC0007014).toString(16));
Group_5_Item_1_Name = RxBufNotEmpty
Group_5_Item_1_Comment = "Bit 0 = RxBufNotEmpty: Rx Buffer not Empty.\nSet when RxFIFO not empty (RxFIFO contains at least one entry)."
Group_5_Item_1_Type = 1, Low, High
Group_5_Item_1_CodingProc = SetInt((GetWordValue(0,0xC0007014)&0x0001)?1:0);
Group_5_Item_2_Name = TxEmpty
Group_5_Item_2_Comment = "Bit 1 = TxEmpty: TxFIFO Empty.\nSet when transmit shift register is empty."
Group_5_Item_2_Type = 1, Low, High
Group_5_Item_2_CodingProc = SetInt((GetWordValue(0,0xC0007014)&0x0002)?1:0);
Group_5_Item_3_Name = TxHalfEmpty
Group_5_Item_3_Comment = "Bit 2 = TxHalfEmpty: TxFIFO Half Empty.\nSet when TxFIFO at least half empty."
Group_5_Item_3_Type = 1, Low, High
Group_5_Item_3_CodingProc = SetInt((GetWordValue(0,0xC0007014)&0x0004)?1:0);
Group_5_Item_4_Name = ParityError
Group_5_Item_4_Comment = "Bit 3 = ParityError: Parity Error.\nSet when the RxFIFO contains something received with a parity error"
Group_5_Item_4_Type = 1, Low, High
Group_5_Item_4_CodingProc = SetInt((GetWordValue(0,0xC0007014)&0x0008)?1:0);
Group_5_Item_5_Name = TimeoutIdleIE
Group_5_Item_5_Comment = "Bit 4 = FrameError: Frame Error.\nSet when the RxFIFO contains something received with a frame error."
Group_5_Item_5_Type = 1, Low, High
Group_5_Item_5_CodingProc = SetInt((GetWordValue(0,0xC0007014)&0x0010)?1:0);
Group_5_Item_6_Name = RxHalfFullIE
Group_5_Item_6_Comment = "Bit 5 = OverrunError: Overrun Error.\nSet when data is received and the RxFIFO is full."
Group_5_Item_6_Type = 1, Low, High
Group_5_Item_6_CodingProc = SetInt((GetWordValue(0,0xC0007014)&0x0020)?1:0);
Group_5_Item_7_Name = TimeoutNotEmptyIE
Group_5_Item_7_Comment = "Bit 6 = TimeoutNotEmpty: TimeoutNotEmpty.\nSet when there is a timeout and the RxFIFO is not empty."
Group_5_Item_7_Type = 1, Low, High
Group_5_Item_7_CodingProc = SetInt((GetWordValue(0,0xC0007014)&0x0040)?1:0);
Group_5_Item_8_Name = TimeoutIdle
Group_5_Item_8_Comment = "Bit 7 = TimeoutIdle: Timeout Idle.\nSet when there is a timeout and the RxFIFO is empty."
Group_5_Item_8_Type = 1, Low, High
Group_5_Item_8_CodingProc = SetInt((GetWordValue(0,0xC0007014)&0x0080)?1:0);
Group_5_Item_9_Name = RxHalfFullIE
Group_5_Item_9_Comment = "Bit 8 = RxHalfFull: RxFIFO Half Full.\nSet when the RxFIFO contains more than 8 characters."
Group_5_Item_9_Type = 1, Low, High
Group_5_Item_9_CodingProc = SetInt((GetWordValue(0,0xC0007014)&0x0100)?1:0);
Group_5_Item_10_Name = TxFull
Group_5_Item_10_Comment = "Bit 9 = TxFull: TxFIFO Full.\nSet when the TxFIFO contains 16 characters."
Group_5_Item_10_Type = 1, Low, High
Group_5_Item_10_CodingProc = SetInt((GetWordValue(0,0xC0007014)&0x0200)?1:0);
Group_6_Name = UART GuardTime Register
Group_6_Comment = "The UARTn_GTR register enables the user to define a programmable number of baud clocks to delay the assertion of TxEmpty.\n•Bit 15:8 = Reserved, always read as 0."
Group_6_ItemsNumber = 1
Group_6_CodingProc = SetString("0x"+GetWordValue(0,0xC0007018).toString(16));
Group_6_Item_1_Name = UART_GuardTime
Group_6_Item_1_Comment = "Bit 7:0 = UART_GuardTime.\nNumber of baud clocks to delay assertion of TxEmpty."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC0007018)&0x00FF).toString(16));
Group_6_Item_1_DecodingProc = SetWordValue(0,0xC0007018,(parseInt(GetString()))&~0x00FF);
Group_7_Name = UART Timeout Register
Group_7_Comment = "This register is to have a timeout system to be sure that not too much time pass between two successive received characters.\n•Bit 15:8 = Reserved, always read as 0."
Group_7_ItemsNumber = 1
Group_7_CodingProc = SetString("0x"+GetWordValue(0,0xC000701C).toString(16));
Group_7_Item_1_Name = UART_Timeout
Group_7_Item_1_Comment = "Bit 7:0 = UART_Timeout: Timeout.\nTimeout period in baud rate ticks."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+(GetWordValue(0,0xC000701C)&0x00FF).toString(16));
Group_7_Item_1_DecodingProc = SetWordValue(0,0xC000701C,(parseInt(GetString()))&~0x00FF);
Group_8_Name = UART TxReset Register
Group_8_Comment = "A write to this register empties the TxFIFO."
Group_8_ItemsNumber = 1
Group_8_Item_1_Name = UART TxReset Register
Group_8_Item_1_Comment = "UART TxReset Register.\n•Address Offset: 20h.\n•Reset value: Reserved."
Group_8_Item_1_Type = 0
Group_8_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0007020).toString(16));
Group_8_Item_1_DecodingProc = SetWordValue(0,0xC0007020,parseInt(GetString()));
Group_9_Name = UART RxReset Register
Group_9_Comment = "A write to this register empties the RxFIFO."
Group_9_ItemsNumber = 1
Group_9_Item_1_Name = UART RxReset Register
Group_9_Item_1_Comment = "UART RxReset Register.\n•Address Offset: 24h.\n•Reset Value: Reserved."
Group_9_Item_1_Type = 0
Group_9_Item_1_CodingProc = SetString("0x"+GetWordValue(0,0xC0007024).toString(16));
Group_9_Item_1_DecodingProc = SetWordValue(0,0xC0007024,parseInt(GetString()));
[APB0]
SegmentsNumber = 1
Segment_1 = APB_SEG, 32, 0xC0000000, 0x18
SymbsNumber = 2
Symb_1 = APB_CKDIS, 0, 0xC0000010
Symb_2 = APB_SWRES, 0, 0xC0000014
ResetCode = {SetWordValue(0,0xC0000000 +0x10,0x00);SetWordValue(0,0xC0000000 +0x14,0x00);}
GroupsNumber = 2
Group_1_Name = APB Clock Disable Register
Group_1_Comment = "Bit 31:16 = Reserved, must be kept at reset value (0)."
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = Peripheral Clock Disable
Group_1_Item_1_Comment = "Bit 14:0 = Peripheral Clock Disable (14:0).\nEach of these bits control the clock gating to the peripherals in the same order as in the bridge memory map. Bit 0 controls the peripheral in position 1 (I2C0 for APB1 or XTI for APB2) and so on.\n•0: Peripheral clock enabled.\n•1: Peripheral clock disabled."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC0000000 +0x10)&0x00007FFF).toString(16));
Group_1_Item_1_DecodingProc = SetDWordValue(0,0xC0000000 +0x10,(parseInt(GetString()))&~0x00007FFF);
Group_2_Name = APB Software Reset Register
Group_2_Comment = "Bit 31:15 = Reserved, must be kept at reset value (0)."
Group_2_ItemsNumber = 1
Group_2_Item_1_Name = Peripheral Reset
Group_2_Item_1_Comment = "Bit 14:0 = Peripheral Reset (14:0).\nEach of these bits controls the activation of the Reset to the peripherals in the same order as in the bridge memory map (see Table 2 and Table 3). Bit 0 controls the peripheral in position 1 (I2C0 for APB1 or XTI for APB2) and so on.\n•0: The peripheral is reset by the system-wide Reset\n•1: The peripheral is kept under reset independently from the System-wide Reset."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC0000000 +0x14)&0x00007FFF).toString(16));
Group_2_Item_1_DecodingProc = SetDWordValue(0,0xC0000000 +0x14,(parseInt(GetString()))&~0x00007FFF);
[APB1]
SegmentsNumber = 1
Segment_1 = APB_SEG, 32, 0xE0000000, 0x18
SymbsNumber = 2
Symb_1 = APB_CKDIS, 0, 0xE0000010
Symb_2 = APB_SWRES, 0, 0xE0000014
ResetCode = {SetWordValue(0,0xE0000000 +0x10,0x00);SetWordValue(0,0xE0000000 +0x14,0x00);}
GroupsNumber = 2
Group_1_Name = APB Clock Disable Register
Group_1_Comment = "Bit 31:16 = Reserved, must be kept at reset value (0)."
Group_1_ItemsNumber = 1
Group_1_Item_1_Name = Peripheral Clock Disable
Group_1_Item_1_Comment = "Bit 14:0 = Peripheral Clock Disable (14:0).\nEach of these bits control the clock gating to the peripherals in the same order as in the bridge memory map. Bit 0 controls the peripheral in position 1 (I2C0 for APB1 or XTI for APB2) and so on.\n•0: Peripheral clock enabled.\n•1: Peripheral clock disabled."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xE0000000 +0x10)&0x00007FFF).toString(16));
Group_1_Item_1_DecodingProc = SetDWordValue(0,0xE0000000 +0x10,(parseInt(GetString()))&~0x00007FFF);
Group_2_Name = APB Software Reset Register
Group_2_Comment = "Bit 31:15 = Reserved, must be kept at reset value (0)."
Group_2_ItemsNumber = 1
Group_2_Item_1_Name = Peripheral Reset
Group_2_Item_1_Comment = "Bit 14:0 = Peripheral Reset (14:0).\nEach of these bits controls the activation of the Reset to the peripherals in the same order as in the bridge memory map (see Table 2 and Table 3). Bit 0 controls the peripheral in position 1 (I2C0 for APB1 or XTI for APB2) and so on.\n•0: The peripheral is reset by the system-wide Reset\n•1: The peripheral is kept under reset independently from the System-wide Reset."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xE0000000 +0x14)&0x00007FFF).toString(16));
Group_2_Item_1_DecodingProc = SetDWordValue(0,0xE0000000 +0x14,(parseInt(GetString()))&~0x00007FFF);
[USB]
SegmentsNumber = 2
Segment_1 = USB_EPREGS, 32, 0xC0008000, 0x54
Segment_2 = USB_MEM , 32, USB_MemBase, USB_MemSize
SymbsNumber = 14
Symb_1 = USB_EP0REG, 0, 0xC0008000
Symb_2 = USB_EP1REG, 0, 0xC0008004
Symb_3 = USB_EP2REG, 0, 0xC0008008
Symb_4 = USB_EP3REG, 0, 0xC000800C
Symb_5 = USB_EP4REG, 0, 0xC0008010
Symb_6 = USB_EP5REG, 0, 0xC0008014
Symb_7 = USB_EP6REG, 0, 0xC0008018
Symb_8 = USB_EP7REG, 0, 0xC000801C
Symb_9 = USB_CNTR, 0, 0xC0008040
Symb_10 = USB_ISTR, 0, 0xC0008044
Symb_11 = USB_FNR, 0, 0xC0008048
Symb_12 = USB_DADDR, 0, 0xC000804C
Symb_13 = USB_BTABLE, 0, 0xC0008050
Symb_14 = USB_MEM, 0, PREFIXADM(080)
ResetCode = {SetDWordValue(0,0xC0008040,0x03);SetDWordValue(0,0xC0008044,0x00);SetDWordValue(0,0xC0008048,0xffffffff);SetDWordValue(0,0xC000804C,0x00);SetDWordValue(0,0xC0008050,0x00);}
GroupsNumber = 13
Group_1_Name = EPOR0 (EP0R)
Group_1_Comment = "USB Endpoint Register."
Group_1_ItemsNumber = 9
Group_1_CodingProc = SetString("0x"+GetDWordValue(0,0xC0008000).toString(16));
Group_1_Item_1_Name = EA
Group_1_Item_1_comment = "Bit 3:0 = Endpoint Address.\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint."
Group_1_Item_1_Type = 0
Group_1_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC0008000)&0x0F).toString(16));
Group_1_Item_1_DecodingProc = SetDWordValue(0,0xC0008000,parseInt(GetString())|((GetDWordValue(0,0xC0008000)&0x700)|0x8080));
Group_1_Item_2_Name = STAT_TX
Group_1_Item_2_comment = "Bit 5:4 = STAT_TX [1:0] Status bits, for transmission transfers.These bits contain the information about the endpoint status. These bits can be toggled by the software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. Hardware sets the STAT_TX bits to NAK, when a correct transfer has occurred (CTR_TX=1) corresponding to a IN or SETUP (control only) transaction addressed to this endpoint. It then waits for the software to prepare the next set of data to be transmitted.Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition.If the endpoint is defined as Isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the endpoint after a successful transaction."
Group_1_Item_2_Type = 1, disabled, stall, nak, valid
Group_1_Item_2_CodingProc = SetInt((GetDWordValue(0,0xC0008000)&0x30)>>4);
Group_1_Item_2_DecodingProc = SetDWordValue(0,0xC0008000,(GetInt()<<4)|((GetDWordValue(0,0xC0008000)&0x70F)|0x8080));
Group_1_Item_3_Name = DTOG_TX
Group_1_Item_3_comment = "Bit 6 = DTOG_TX: Data Toggle, for transmission transfers.This bit can also be toggled by the software to initialize its value(mandatory when the endpoint is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes ‘0’,the value of DTOG_TX remains unchanged, while writing ‘1’ makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
Group_1_Item_3_Type = 1, unchanged,toggle
Group_1_Item_3_CodingProc = SetInt((GetDWordValue(0,0xC0008000)&0x40)?1:0);
Group_1_Item_3_DecodingProc = SetDWordValue(0,0xC0008000,(GetInt()<<6)|((GetDWordValue(0,0xC0008000)&0x70F)|0x8080));
Group_1_Item_4_Name = CTR_TX
Group_1_Item_4_comment = "Bit 7 = CTR_TX: Correct Transfer for transmission This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nNote A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written."
Group_1_Item_4_Type = 1, Low, High
Group_1_Item_4_CodingProc = SetInt((GetDWordValue(0,0xC0008000)&0x80)?1:0);
Group_1_Item_4_DecodingProc = SetDWordValue(0,0xC0008000,(GetInt()<<7)|((GetDWordValue(0,0xC0008000)&0x70F)|0x8000));
Group_1_Item_5_Name = EP_TYPE (EP_KIND)
Group_1_Item_5_comment = "Endpoint 0 must always\nbe a control endpoint and each USB function must have at least one control endpoint which has address 0, but there may be other control endpoints if required. Only control endpoints handle SETUP transactions,which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint is defined as NAK,the USB Peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way,even if the endpoint is a control one.\nBulk and interrupt endpoints have very similar behaviour and they differ only in the special feature available using the EP_KIND configuration bit."
Group_1_Item_5_Type = 1, BULK (double buffering disabled), BULK (double buffering enabled), CONTROL (status out expected), CONTROL (no status out expected), ISO (not used), INTERRUPT (not used)
Group_1_Item_5_CodingProc = SetInt((GetDWordValue(0,0xC0008000)&0x400)?0x04+((GetDWordValue(0,0xC0008000)&0x200)>>9):(GetDWordValue(0,0xC0008000)&0x700)>>8);
Group_1_Item_5_DecodingProc = SetDWordValue(0,0xC0008000,(GetInt()<<8)|((GetDWordValue(0,0xC0008000)&0x70F)|0x8080));
Group_1_Item_6_Name = SETUP
Group_1_Item_6_comment = "Bit 11 = SETUP: Setup transaction completed This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (CTR_RX event), to determine the type of transaction occurred.To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while CTR_RX bit is at 1; its state changes when CTR_RX is at 0. This bit is read-only."
Group_1_Item_6_Type = 1, LOW, HIGH
Group_1_Item_6_CodingProc = SetInt((GetDWordValue(0,0xC0008000)&0x800)?1:0);
Group_1_Item_7_Name = STAT_RX
Group_1_Item_7_comment = "Bits 13:12 = STAT_RX [1:0] Status bits, for reception transfers These bits can be toggled by software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. "
Group_1_Item_7_Type = 1, Disabled, Stall, Nak, Valid
Group_1_Item_7_CodingProc = SetInt((GetDWordValue(0,0xC0008000)&0x3000)>>12);
Group_1_Item_7_DecodingProc = SetDWordValue(0,0xC0008000,(GetInt()<<12)|((GetDWordValue(0,0xC0008000)&0x70F)|0x8080));
Group_1_Item_8_Name = DTOG_RX
Group_1_Item_8_comment = "Bit 14 = DTOG_RX: Data Toggle, for reception transfers If the endpoint is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent to the USB host, following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID addressed to this endpoint."
Group_1_Item_8_Type = 1, LOW, HIGH
Group_1_Item_8_CodingProc = SetInt((GetDWordValue(0,0xC0008000)&0x4000)?1:0);
Group_1_Item_8_DecodingProc = SetDWordValue(0,0xC0008000,(GetInt()<<14)|((GetDWordValue(0,0xC0008000)&0x70F)|0x8080));
Group_1_Item_9_Name = CTR_RX
Group_1_Item_9_comment = "Bit 15 = CTR_RX: Correct Transfer for reception This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit,since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written, writing 1 has no effect."
Group_1_Item_9_Type = 1, LOW, HIGH
Group_1_Item_9_CodingProc = SetInt((GetDWordValue(0,0xC0008000)&0x8000)?1:0);
Group_1_Item_9_DecodingProc = SetDWordValue(0,0xC0008000,(GetInt()<<15)|((GetDWordValue(0,0xC0008000)&0x70F)|0x0080));
Group_2_Name = EPOR1 (EP0R)
Group_2_Comment = "USB Endpoint Register."
Group_2_ItemsNumber = 9
Group_2_CodingProc = SetString("0x"+GetDWordValue(0,0xC0008004).toString(16));
Group_2_Item_1_Name = EA
Group_2_Item_1_comment = "Bit 3:0 = Endpoint Address.\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint."
Group_2_Item_1_Type = 0
Group_2_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC0008004)&0x0F).toString(16));
Group_2_Item_1_DecodingProc = SetDWordValue(0,0xC0008004,parseInt(GetString())|((GetDWordValue(0,0xC0008004)&0x700)|0x8080));
Group_2_Item_2_Name = STAT_TX
Group_2_Item_2_comment = "Bit 5:4 = STAT_TX [1:0] Status bits, for transmission transfers.These bits contain the information about the endpoint status. These bits can be toggled by the software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. Hardware sets the STAT_TX bits to NAK, when a correct transfer has occurred (CTR_TX=1) corresponding to a IN or SETUP (control only) transaction addressed to this endpoint. It then waits for the software to prepare the next set of data to be transmitted.Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition.If the endpoint is defined as Isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the endpoint after a successful transaction."
Group_2_Item_2_Type = 1, disabled, stall, nak, valid
Group_2_Item_2_CodingProc = SetInt((GetDWordValue(0,0xC0008004)&0x30)>>4);
Group_2_Item_2_DecodingProc = SetDWordValue(0,0xC0008004,(GetInt()<<4)|((GetDWordValue(0,0xC0008004)&0x70F)|0x8080));
Group_2_Item_3_Name = DTOG_TX
Group_2_Item_3_comment = "Bit 6 = DTOG_TX: Data Toggle, for transmission transfers.This bit can also be toggled by the software to initialize its value(mandatory when the endpoint is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes ‘0’,the value of DTOG_TX remains unchanged, while writing ‘1’ makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
Group_2_Item_3_Type = 1, unchanged,toggle
Group_2_Item_3_CodingProc = SetInt((GetDWordValue(0,0xC0008004)&0x40)?1:0);
Group_2_Item_3_DecodingProc = SetDWordValue(0,0xC0008004,(GetInt()<<6)|((GetDWordValue(0,0xC0008004)&0x70F)|0x8080));
Group_2_Item_4_Name = CTR_TX
Group_2_Item_4_comment = "Bit 7 = CTR_TX: Correct Transfer for transmission This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nNote A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written."
Group_2_Item_4_Type = 1, Low, High
Group_2_Item_4_CodingProc = SetInt((GetDWordValue(0,0xC0008004)&0x80)?1:0);
Group_2_Item_4_DecodingProc = SetDWordValue(0,0xC0008004,(GetInt()<<7)|((GetDWordValue(0,0xC0008004)&0x70F)|0x8000));
Group_2_Item_5_Name = EP_TYPE (EP_KIND)
Group_2_Item_5_comment = "Endpoint 0 must always\nbe a control endpoint and each USB function must have at least one control endpoint which has address 0, but there may be other control endpoints if required. Only control endpoints handle SETUP transactions,which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint is defined as NAK,the USB Peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way,even if the endpoint is a control one.\nBulk and interrupt endpoints have very similar behaviour and they differ only in the special feature available using the EP_KIND configuration bit."
Group_2_Item_5_Type = 1, BULK (double buffering disabled), BULK (double buffering enabled), CONTROL (status out expected), CONTROL (no status out expected), ISO (not used), INTERRUPT (not used)
Group_2_Item_5_CodingProc = SetInt((GetDWordValue(0,0xC0008004)&0x400)?0x04+((GetDWordValue(0,0xC0008004)&0x200)>>9):(GetDWordValue(0,0xC0008004)&0x700)>>8);
Group_2_Item_5_DecodingProc = SetDWordValue(0,0xC0008004,(GetInt()<<8)|((GetDWordValue(0,0xC0008004)&0x70F)|0x8080));
Group_2_Item_6_Name = SETUP
Group_2_Item_6_comment = "Bit 11 = SETUP: Setup transaction completed This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (CTR_RX event), to determine the type of transaction occurred.To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while CTR_RX bit is at 1; its state changes when CTR_RX is at 0. This bit is read-only."
Group_2_Item_6_Type = 1, LOW, HIGH
Group_2_Item_6_CodingProc = SetInt((GetDWordValue(0,0xC0008004)&0x800)?1:0);
Group_2_Item_7_Name = STAT_RX
Group_2_Item_7_comment = "Bits 13:12 = STAT_RX [1:0] Status bits, for reception transfers These bits can be toggled by software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. "
Group_2_Item_7_Type = 1, Disabled, Stall, Nak, Valid
Group_2_Item_7_CodingProc = SetInt((GetDWordValue(0,0xC0008004)&0x3000)>>12);
Group_2_Item_7_DecodingProc = SetDWordValue(0,0xC0008004,(GetInt()<<12)|((GetDWordValue(0,0xC0008004)&0x70F)|0x8080));
Group_2_Item_8_Name = DTOG_RX
Group_2_Item_8_comment = "Bit 14 = DTOG_RX: Data Toggle, for reception transfers If the endpoint is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent to the USB host, following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID addressed to this endpoint."
Group_2_Item_8_Type = 1, LOW, HIGH
Group_2_Item_8_CodingProc = SetInt((GetDWordValue(0,0xC0008004)&0x4000)?1:0);
Group_2_Item_8_DecodingProc = SetDWordValue(0,0xC0008004,(GetInt()<<14)|((GetDWordValue(0,0xC0008004)&0x70F)|0x8080));
Group_2_Item_9_Name = CTR_RX
Group_2_Item_9_comment = "Bit 15 = CTR_RX: Correct Transfer for reception This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit,since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written, writing 1 has no effect."
Group_2_Item_9_Type = 1, LOW, HIGH
Group_2_Item_9_CodingProc = SetInt((GetDWordValue(0,0xC0008004)&0x8000)?1:0);
Group_2_Item_9_DecodingProc = SetDWordValue(0,0xC0008004,(GetInt()<<15)|((GetDWordValue(0,0xC0008004)&0x70F)|0x0080));
Group_3_Name = EPOR2 (EP0R)
Group_3_Comment = "USB Endpoint Register."
Group_3_ItemsNumber = 9
Group_3_CodingProc = SetString("0x"+GetDWordValue(0,0xC0008008).toString(16));
Group_3_Item_1_Name = EA
Group_3_Item_1_comment = "Bit 3:0 = Endpoint Address.\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint."
Group_3_Item_1_Type = 0
Group_3_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC0008008)&0x0F).toString(16));
Group_3_Item_1_DecodingProc = SetDWordValue(0,0xC0008008,parseInt(GetString())|((GetDWordValue(0,0xC0008008)&0x700)|0x8080));
Group_3_Item_2_Name = STAT_TX
Group_3_Item_2_comment = "Bit 5:4 = STAT_TX [1:0] Status bits, for transmission transfers.These bits contain the information about the endpoint status. These bits can be toggled by the software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. Hardware sets the STAT_TX bits to NAK, when a correct transfer has occurred (CTR_TX=1) corresponding to a IN or SETUP (control only) transaction addressed to this endpoint. It then waits for the software to prepare the next set of data to be transmitted.Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition.If the endpoint is defined as Isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the endpoint after a successful transaction."
Group_3_Item_2_Type = 1, disabled, stall, nak, valid
Group_3_Item_2_CodingProc = SetInt((GetDWordValue(0,0xC0008008)&0x30)>>4);
Group_3_Item_2_DecodingProc = SetDWordValue(0,0xC0008008,(GetInt()<<4)|((GetDWordValue(0,0xC0008008)&0x70F)|0x8080));
Group_3_Item_3_Name = DTOG_TX
Group_3_Item_3_comment = "Bit 6 = DTOG_TX: Data Toggle, for transmission transfers.This bit can also be toggled by the software to initialize its value(mandatory when the endpoint is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes ‘0’,the value of DTOG_TX remains unchanged, while writing ‘1’ makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
Group_3_Item_3_Type = 1, unchanged,toggle
Group_3_Item_3_CodingProc = SetInt((GetDWordValue(0,0xC0008008)&0x40)?1:0);
Group_3_Item_3_DecodingProc = SetDWordValue(0,0xC0008008,(GetInt()<<6)|((GetDWordValue(0,0xC0008008)&0x70F)|0x8080));
Group_3_Item_4_Name = CTR_TX
Group_3_Item_4_comment = "Bit 7 = CTR_TX: Correct Transfer for transmission This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nNote A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written."
Group_3_Item_4_Type = 1, Low, High
Group_3_Item_4_CodingProc = SetInt((GetDWordValue(0,0xC0008008)&0x80)?1:0);
Group_3_Item_4_DecodingProc = SetDWordValue(0,0xC0008008,(GetInt()<<7)|((GetDWordValue(0,0xC0008008)&0x70F)|0x8000));
Group_3_Item_5_Name = EP_TYPE (EP_KIND)
Group_3_Item_5_comment = "Endpoint 0 must always\nbe a control endpoint and each USB function must have at least one control endpoint which has address 0, but there may be other control endpoints if required. Only control endpoints handle SETUP transactions,which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint is defined as NAK,the USB Peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way,even if the endpoint is a control one.\nBulk and interrupt endpoints have very similar behaviour and they differ only in the special feature available using the EP_KIND configuration bit."
Group_3_Item_5_Type = 1, BULK (double buffering disabled), BULK (double buffering enabled), CONTROL (status out expected), CONTROL (no status out expected), ISO (not used), INTERRUPT (not used)
Group_3_Item_5_CodingProc = SetInt((GetDWordValue(0,0xC0008008)&0x400)?0x04+((GetDWordValue(0,0xC0008008)&0x200)>>9):(GetDWordValue(0,0xC0008008)&0x700)>>8);
Group_3_Item_5_DecodingProc = SetDWordValue(0,0xC0008008,(GetInt()<<8)|((GetDWordValue(0,0xC0008008)&0x70F)|0x8080));
Group_3_Item_6_Name = SETUP
Group_3_Item_6_comment = "Bit 11 = SETUP: Setup transaction completed This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (CTR_RX event), to determine the type of transaction occurred.To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while CTR_RX bit is at 1; its state changes when CTR_RX is at 0. This bit is read-only."
Group_3_Item_6_Type = 1, LOW, HIGH
Group_3_Item_6_CodingProc = SetInt((GetDWordValue(0,0xC0008008)&0x800)?1:0);
Group_3_Item_7_Name = STAT_RX
Group_3_Item_7_comment = "Bits 13:12 = STAT_RX [1:0] Status bits, for reception transfers These bits can be toggled by software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. "
Group_3_Item_7_Type = 1, Disabled, Stall, Nak, Valid
Group_3_Item_7_CodingProc = SetInt((GetDWordValue(0,0xC0008008)&0x3000)>>12);
Group_3_Item_7_DecodingProc = SetDWordValue(0,0xC0008008,(GetInt()<<12)|((GetDWordValue(0,0xC0008008)&0x70F)|0x8080));
Group_3_Item_8_Name = DTOG_RX
Group_3_Item_8_comment = "Bit 14 = DTOG_RX: Data Toggle, for reception transfers If the endpoint is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent to the USB host, following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID addressed to this endpoint."
Group_3_Item_8_Type = 1, LOW, HIGH
Group_3_Item_8_CodingProc = SetInt((GetDWordValue(0,0xC0008008)&0x4000)?1:0);
Group_3_Item_8_DecodingProc = SetDWordValue(0,0xC0008008,(GetInt()<<14)|((GetDWordValue(0,0xC0008008)&0x70F)|0x8080));
Group_3_Item_9_Name = CTR_RX
Group_3_Item_9_comment = "Bit 15 = CTR_RX: Correct Transfer for reception This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit,since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written, writing 1 has no effect."
Group_3_Item_9_Type = 1, LOW, HIGH
Group_3_Item_9_CodingProc = SetInt((GetDWordValue(0,0xC0008008)&0x8000)?1:0);
Group_3_Item_9_DecodingProc = SetDWordValue(0,0xC0008008,(GetInt()<<15)|((GetDWordValue(0,0xC0008008)&0x70F)|0x0080));
Group_4_Name = EPOR3 (EP0R)
Group_4_Comment = "USB Endpoint Register."
Group_4_ItemsNumber = 9
Group_4_CodingProc = SetString("0x"+GetDWordValue(0,0xC000800C).toString(16));
Group_4_Item_1_Name = EA
Group_4_Item_1_comment = "Bit 3:0 = Endpoint Address.\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint."
Group_4_Item_1_Type = 0
Group_4_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC000800C)&0x0F).toString(16));
Group_4_Item_1_DecodingProc = SetDWordValue(0,0xC000800C,parseInt(GetString())|((GetDWordValue(0,0xC000800C)&0x700)|0x8080));
Group_4_Item_2_Name = STAT_TX
Group_4_Item_2_comment = "Bit 5:4 = STAT_TX [1:0] Status bits, for transmission transfers.These bits contain the information about the endpoint status. These bits can be toggled by the software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. Hardware sets the STAT_TX bits to NAK, when a correct transfer has occurred (CTR_TX=1) corresponding to a IN or SETUP (control only) transaction addressed to this endpoint. It then waits for the software to prepare the next set of data to be transmitted.Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition.If the endpoint is defined as Isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the endpoint after a successful transaction."
Group_4_Item_2_Type = 1, disabled, stall, nak, valid
Group_4_Item_2_CodingProc = SetInt((GetDWordValue(0,0xC000800C)&0x30)>>4);
Group_4_Item_2_DecodingProc = SetDWordValue(0,0xC000800C,(GetInt()<<4)|((GetDWordValue(0,0xC000800C)&0x70F)|0x8080));
Group_4_Item_3_Name = DTOG_TX
Group_4_Item_3_comment = "Bit 6 = DTOG_TX: Data Toggle, for transmission transfers.This bit can also be toggled by the software to initialize its value(mandatory when the endpoint is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes ‘0’,the value of DTOG_TX remains unchanged, while writing ‘1’ makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
Group_4_Item_3_Type = 1, unchanged,toggle
Group_4_Item_3_CodingProc = SetInt((GetDWordValue(0,0xC000800C)&0x40)?1:0);
Group_4_Item_3_DecodingProc = SetDWordValue(0,0xC000800C,(GetInt()<<6)|((GetDWordValue(0,0xC000800C)&0x70F)|0x8080));
Group_4_Item_4_Name = CTR_TX
Group_4_Item_4_comment = "Bit 7 = CTR_TX: Correct Transfer for transmission This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nNote A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written."
Group_4_Item_4_Type = 1, Low, High
Group_4_Item_4_CodingProc = SetInt((GetDWordValue(0,0xC000800C)&0x80)?1:0);
Group_4_Item_4_DecodingProc = SetDWordValue(0,0xC000800C,(GetInt()<<7)|((GetDWordValue(0,0xC000800C)&0x70F)|0x8000));
Group_4_Item_5_Name = EP_TYPE (EP_KIND)
Group_4_Item_5_comment = "Endpoint 0 must always\nbe a control endpoint and each USB function must have at least one control endpoint which has address 0, but there may be other control endpoints if required. Only control endpoints handle SETUP transactions,which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint is defined as NAK,the USB Peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way,even if the endpoint is a control one.\nBulk and interrupt endpoints have very similar behaviour and they differ only in the special feature available using the EP_KIND configuration bit."
Group_4_Item_5_Type = 1, BULK (double buffering disabled), BULK (double buffering enabled), CONTROL (status out expected), CONTROL (no status out expected), ISO (not used), INTERRUPT (not used)
Group_4_Item_5_CodingProc = SetInt((GetDWordValue(0,0xC000800C)&0x400)?0x04+((GetDWordValue(0,0xC000800C)&0x200)>>9):(GetDWordValue(0,0xC000800C)&0x700)>>8);
Group_4_Item_5_DecodingProc = SetDWordValue(0,0xC000800C,(GetInt()<<8)|((GetDWordValue(0,0xC000800C)&0x70F)|0x8080));
Group_4_Item_6_Name = SETUP
Group_4_Item_6_comment = "Bit 11 = SETUP: Setup transaction completed This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (CTR_RX event), to determine the type of transaction occurred.To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while CTR_RX bit is at 1; its state changes when CTR_RX is at 0. This bit is read-only."
Group_4_Item_6_Type = 1, LOW, HIGH
Group_4_Item_6_CodingProc = SetInt((GetDWordValue(0,0xC000800C)&0x800)?1:0);
Group_4_Item_7_Name = STAT_RX
Group_4_Item_7_comment = "Bits 13:12 = STAT_RX [1:0] Status bits, for reception transfers These bits can be toggled by software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. "
Group_4_Item_7_Type = 1, Disabled, Stall, Nak, Valid
Group_4_Item_7_CodingProc = SetInt((GetDWordValue(0,0xC000800C)&0x3000)>>12);
Group_4_Item_7_DecodingProc = SetDWordValue(0,0xC000800C,(GetInt()<<12)|((GetDWordValue(0,0xC000800C)&0x70F)|0x8080));
Group_4_Item_8_Name = DTOG_RX
Group_4_Item_8_comment = "Bit 14 = DTOG_RX: Data Toggle, for reception transfers If the endpoint is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent to the USB host, following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID addressed to this endpoint."
Group_4_Item_8_Type = 1, LOW, HIGH
Group_4_Item_8_CodingProc = SetInt((GetDWordValue(0,0xC000800C)&0x4000)?1:0);
Group_4_Item_8_DecodingProc = SetDWordValue(0,0xC000800C,(GetInt()<<14)|((GetDWordValue(0,0xC000800C)&0x70F)|0x8080));
Group_4_Item_9_Name = CTR_RX
Group_4_Item_9_comment = "Bit 15 = CTR_RX: Correct Transfer for reception This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit,since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written, writing 1 has no effect."
Group_4_Item_9_Type = 1, LOW, HIGH
Group_4_Item_9_CodingProc = SetInt((GetDWordValue(0,0xC000800C)&0x8000)?1:0);
Group_4_Item_9_DecodingProc = SetDWordValue(0,0xC000800C,(GetInt()<<15)|((GetDWordValue(0,0xC000800C)&0x70F)|0x0080));
Group_5_Name = EPOR4 (EP0R)
Group_5_Comment = "USB Endpoint Register."
Group_5_ItemsNumber = 9
Group_5_CodingProc = SetString("0x"+GetDWordValue(0,0xC0008010).toString(16));
Group_5_Item_1_Name = EA
Group_5_Item_1_comment = "Bit 3:0 = Endpoint Address.\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint."
Group_5_Item_1_Type = 0
Group_5_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC0008010)&0x0F).toString(16));
Group_5_Item_1_DecodingProc = SetDWordValue(0,0xC0008010,parseInt(GetString())|((GetDWordValue(0,0xC0008010)&0x700)|0x8080));
Group_5_Item_2_Name = STAT_TX
Group_5_Item_2_comment = "Bit 5:4 = STAT_TX [1:0] Status bits, for transmission transfers.These bits contain the information about the endpoint status. These bits can be toggled by the software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. Hardware sets the STAT_TX bits to NAK, when a correct transfer has occurred (CTR_TX=1) corresponding to a IN or SETUP (control only) transaction addressed to this endpoint. It then waits for the software to prepare the next set of data to be transmitted.Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition.If the endpoint is defined as Isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the endpoint after a successful transaction."
Group_5_Item_2_Type = 1, disabled, stall, nak, valid
Group_5_Item_2_CodingProc = SetInt((GetDWordValue(0,0xC0008010)&0x30)>>4);
Group_5_Item_2_DecodingProc = SetDWordValue(0,0xC0008010,(GetInt()<<4)|((GetDWordValue(0,0xC0008010)&0x70F)|0x8080));
Group_5_Item_3_Name = DTOG_TX
Group_5_Item_3_comment = "Bit 6 = DTOG_TX: Data Toggle, for transmission transfers.This bit can also be toggled by the software to initialize its value(mandatory when the endpoint is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes ‘0’,the value of DTOG_TX remains unchanged, while writing ‘1’ makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
Group_5_Item_3_Type = 1, unchanged,toggle
Group_5_Item_3_CodingProc = SetInt((GetDWordValue(0,0xC0008010)&0x40)?1:0);
Group_5_Item_3_DecodingProc = SetDWordValue(0,0xC0008010,(GetInt()<<6)|((GetDWordValue(0,0xC0008010)&0x70F)|0x8080));
Group_5_Item_4_Name = CTR_TX
Group_5_Item_4_comment = "Bit 7 = CTR_TX: Correct Transfer for transmission This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nNote A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written."
Group_5_Item_4_Type = 1, Low, High
Group_5_Item_4_CodingProc = SetInt((GetDWordValue(0,0xC0008010)&0x80)?1:0);
Group_5_Item_4_DecodingProc = SetDWordValue(0,0xC0008010,(GetInt()<<7)|((GetDWordValue(0,0xC0008010)&0x70F)|0x8000));
Group_5_Item_5_Name = EP_TYPE (EP_KIND)
Group_5_Item_5_comment = "Endpoint 0 must always\nbe a control endpoint and each USB function must have at least one control endpoint which has address 0, but there may be other control endpoints if required. Only control endpoints handle SETUP transactions,which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint is defined as NAK,the USB Peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way,even if the endpoint is a control one.\nBulk and interrupt endpoints have very similar behaviour and they differ only in the special feature available using the EP_KIND configuration bit."
Group_5_Item_5_Type = 1, BULK (double buffering disabled), BULK (double buffering enabled), CONTROL (status out expected), CONTROL (no status out expected), ISO (not used), INTERRUPT (not used)
Group_5_Item_5_CodingProc = SetInt((GetDWordValue(0,0xC0008010)&0x400)?0x04+((GetDWordValue(0,0xC0008010)&0x200)>>9):(GetDWordValue(0,0xC0008010)&0x700)>>8);
Group_5_Item_5_DecodingProc = SetDWordValue(0,0xC0008010,(GetInt()<<8)|((GetDWordValue(0,0xC0008010)&0x70F)|0x8080));
Group_5_Item_6_Name = SETUP
Group_5_Item_6_comment = "Bit 11 = SETUP: Setup transaction completed This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (CTR_RX event), to determine the type of transaction occurred.To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while CTR_RX bit is at 1; its state changes when CTR_RX is at 0. This bit is read-only."
Group_5_Item_6_Type = 1, LOW, HIGH
Group_5_Item_6_CodingProc = SetInt((GetDWordValue(0,0xC0008010)&0x800)?1:0);
Group_5_Item_7_Name = STAT_RX
Group_5_Item_7_comment = "Bits 13:12 = STAT_RX [1:0] Status bits, for reception transfers These bits can be toggled by software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. "
Group_5_Item_7_Type = 1, Disabled, Stall, Nak, Valid
Group_5_Item_7_CodingProc = SetInt((GetDWordValue(0,0xC0008010)&0x3000)>>12);
Group_5_Item_7_DecodingProc = SetDWordValue(0,0xC0008010,(GetInt()<<12)|((GetDWordValue(0,0xC0008010)&0x70F)|0x8080));
Group_5_Item_8_Name = DTOG_RX
Group_5_Item_8_comment = "Bit 14 = DTOG_RX: Data Toggle, for reception transfers If the endpoint is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent to the USB host, following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID addressed to this endpoint."
Group_5_Item_8_Type = 1, LOW, HIGH
Group_5_Item_8_CodingProc = SetInt((GetDWordValue(0,0xC0008010)&0x4000)?1:0);
Group_5_Item_8_DecodingProc = SetDWordValue(0,0xC0008010,(GetInt()<<14)|((GetDWordValue(0,0xC0008010)&0x70F)|0x8080));
Group_5_Item_9_Name = CTR_RX
Group_5_Item_9_comment = "Bit 15 = CTR_RX: Correct Transfer for reception This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit,since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written, writing 1 has no effect."
Group_5_Item_9_Type = 1, LOW, HIGH
Group_5_Item_9_CodingProc = SetInt((GetDWordValue(0,0xC0008010)&0x8000)?1:0);
Group_5_Item_9_DecodingProc = SetDWordValue(0,0xC0008010,(GetInt()<<15)|((GetDWordValue(0,0xC0008010)&0x70F)|0x0080));
Group_6_Name = EPOR5 (EP0R)
Group_6_Comment = "USB Endpoint Register."
Group_6_ItemsNumber = 9
Group_6_CodingProc = SetString("0x"+GetDWordValue(0,0xC0008014).toString(16));
Group_6_Item_1_Name = EA
Group_6_Item_1_comment = "Bit 3:0 = Endpoint Address.\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint."
Group_6_Item_1_Type = 0
Group_6_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC0008014)&0x0F).toString(16));
Group_6_Item_1_DecodingProc = SetDWordValue(0,0xC0008014,parseInt(GetString())|((GetDWordValue(0,0xC0008014)&0x700)|0x8080));
Group_6_Item_2_Name = STAT_TX
Group_6_Item_2_comment = "Bit 5:4 = STAT_TX [1:0] Status bits, for transmission transfers.These bits contain the information about the endpoint status. These bits can be toggled by the software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. Hardware sets the STAT_TX bits to NAK, when a correct transfer has occurred (CTR_TX=1) corresponding to a IN or SETUP (control only) transaction addressed to this endpoint. It then waits for the software to prepare the next set of data to be transmitted.Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition.If the endpoint is defined as Isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the endpoint after a successful transaction."
Group_6_Item_2_Type = 1, disabled, stall, nak, valid
Group_6_Item_2_CodingProc = SetInt((GetDWordValue(0,0xC0008014)&0x30)>>4);
Group_6_Item_2_DecodingProc = SetDWordValue(0,0xC0008014,(GetInt()<<4)|((GetDWordValue(0,0xC0008014)&0x70F)|0x8080));
Group_6_Item_3_Name = DTOG_TX
Group_6_Item_3_comment = "Bit 6 = DTOG_TX: Data Toggle, for transmission transfers.This bit can also be toggled by the software to initialize its value(mandatory when the endpoint is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes ‘0’,the value of DTOG_TX remains unchanged, while writing ‘1’ makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
Group_6_Item_3_Type = 1, unchanged,toggle
Group_6_Item_3_CodingProc = SetInt((GetDWordValue(0,0xC0008014)&0x40)?1:0);
Group_6_Item_3_DecodingProc = SetDWordValue(0,0xC0008014,(GetInt()<<6)|((GetDWordValue(0,0xC0008014)&0x70F)|0x8080));
Group_6_Item_4_Name = CTR_TX
Group_6_Item_4_comment = "Bit 7 = CTR_TX: Correct Transfer for transmission This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nNote A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written."
Group_6_Item_4_Type = 1, Low, High
Group_6_Item_4_CodingProc = SetInt((GetDWordValue(0,0xC0008014)&0x80)?1:0);
Group_6_Item_4_DecodingProc = SetDWordValue(0,0xC0008014,(GetInt()<<7)|((GetDWordValue(0,0xC0008014)&0x70F)|0x8000));
Group_6_Item_5_Name = EP_TYPE (EP_KIND)
Group_6_Item_5_comment = "Endpoint 0 must always\nbe a control endpoint and each USB function must have at least one control endpoint which has address 0, but there may be other control endpoints if required. Only control endpoints handle SETUP transactions,which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint is defined as NAK,the USB Peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way,even if the endpoint is a control one.\nBulk and interrupt endpoints have very similar behaviour and they differ only in the special feature available using the EP_KIND configuration bit."
Group_6_Item_5_Type = 1, BULK (double buffering disabled), BULK (double buffering enabled), CONTROL (status out expected), CONTROL (no status out expected), ISO (not used), INTERRUPT (not used)
Group_6_Item_5_CodingProc = SetInt((GetDWordValue(0,0xC0008014)&0x400)?0x04+((GetDWordValue(0,0xC0008014)&0x200)>>9):(GetDWordValue(0,0xC0008014)&0x700)>>8);
Group_6_Item_5_DecodingProc = SetDWordValue(0,0xC0008014,(GetInt()<<8)|((GetDWordValue(0,0xC0008014)&0x70F)|0x8080));
Group_6_Item_6_Name = SETUP
Group_6_Item_6_comment = "Bit 11 = SETUP: Setup transaction completed This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (CTR_RX event), to determine the type of transaction occurred.To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while CTR_RX bit is at 1; its state changes when CTR_RX is at 0. This bit is read-only."
Group_6_Item_6_Type = 1, LOW, HIGH
Group_6_Item_6_CodingProc = SetInt((GetDWordValue(0,0xC0008014)&0x800)?1:0);
Group_6_Item_7_Name = STAT_RX
Group_6_Item_7_comment = "Bits 13:12 = STAT_RX [1:0] Status bits, for reception transfers These bits can be toggled by software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. "
Group_6_Item_7_Type = 1, Disabled, Stall, Nak, Valid
Group_6_Item_7_CodingProc = SetInt((GetDWordValue(0,0xC0008014)&0x3000)>>12);
Group_6_Item_7_DecodingProc = SetDWordValue(0,0xC0008014,(GetInt()<<12)|((GetDWordValue(0,0xC0008014)&0x70F)|0x8080));
Group_6_Item_8_Name = DTOG_RX
Group_6_Item_8_comment = "Bit 14 = DTOG_RX: Data Toggle, for reception transfers If the endpoint is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent to the USB host, following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID addressed to this endpoint."
Group_6_Item_8_Type = 1, LOW, HIGH
Group_6_Item_8_CodingProc = SetInt((GetDWordValue(0,0xC0008014)&0x4000)?1:0);
Group_6_Item_8_DecodingProc = SetDWordValue(0,0xC0008014,(GetInt()<<14)|((GetDWordValue(0,0xC0008014)&0x70F)|0x8080));
Group_6_Item_9_Name = CTR_RX
Group_6_Item_9_comment = "Bit 15 = CTR_RX: Correct Transfer for reception This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit,since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written, writing 1 has no effect."
Group_6_Item_9_Type = 1, LOW, HIGH
Group_6_Item_9_CodingProc = SetInt((GetDWordValue(0,0xC0008014)&0x8000)?1:0);
Group_6_Item_9_DecodingProc = SetDWordValue(0,0xC0008014,(GetInt()<<15)|((GetDWordValue(0,0xC0008014)&0x70F)|0x0080));
Group_7_Name = EPOR6 (EP0R)
Group_7_Comment = "USB Endpoint Register."
Group_7_ItemsNumber = 9
Group_7_CodingProc = SetString("0x"+GetDWordValue(0,0xC0008018).toString(16));
Group_7_Item_1_Name = EA
Group_7_Item_1_comment = "Bit 3:0 = Endpoint Address.\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint."
Group_7_Item_1_Type = 0
Group_7_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC0008018)&0x0F).toString(16));
Group_7_Item_1_DecodingProc = SetDWordValue(0,0xC0008018,parseInt(GetString())|((GetDWordValue(0,0xC0008018)&0x700)|0x8080));
Group_7_Item_2_Name = STAT_TX
Group_7_Item_2_comment = "Bit 5:4 = STAT_TX [1:0] Status bits, for transmission transfers.These bits contain the information about the endpoint status. These bits can be toggled by the software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. Hardware sets the STAT_TX bits to NAK, when a correct transfer has occurred (CTR_TX=1) corresponding to a IN or SETUP (control only) transaction addressed to this endpoint. It then waits for the software to prepare the next set of data to be transmitted.Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition.If the endpoint is defined as Isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the endpoint after a successful transaction."
Group_7_Item_2_Type = 1, disabled, stall, nak, valid
Group_7_Item_2_CodingProc = SetInt((GetDWordValue(0,0xC0008018)&0x30)>>4);
Group_7_Item_2_DecodingProc = SetDWordValue(0,0xC0008018,(GetInt()<<4)|((GetDWordValue(0,0xC0008018)&0x70F)|0x8080));
Group_7_Item_3_Name = DTOG_TX
Group_7_Item_3_comment = "Bit 6 = DTOG_TX: Data Toggle, for transmission transfers.This bit can also be toggled by the software to initialize its value(mandatory when the endpoint is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes ‘0’,the value of DTOG_TX remains unchanged, while writing ‘1’ makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
Group_7_Item_3_Type = 1, unchanged,toggle
Group_7_Item_3_CodingProc = SetInt((GetDWordValue(0,0xC0008018)&0x40)?1:0);
Group_7_Item_3_DecodingProc = SetDWordValue(0,0xC0008018,(GetInt()<<6)|((GetDWordValue(0,0xC0008018)&0x70F)|0x8080));
Group_7_Item_4_Name = CTR_TX
Group_7_Item_4_comment = "Bit 7 = CTR_TX: Correct Transfer for transmission This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nNote A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written."
Group_7_Item_4_Type = 1, Low, High
Group_7_Item_4_CodingProc = SetInt((GetDWordValue(0,0xC0008018)&0x80)?1:0);
Group_7_Item_4_DecodingProc = SetDWordValue(0,0xC0008018,(GetInt()<<7)|((GetDWordValue(0,0xC0008018)&0x70F)|0x8000));
Group_7_Item_5_Name = EP_TYPE (EP_KIND)
Group_7_Item_5_comment = "Endpoint 0 must always\nbe a control endpoint and each USB function must have at least one control endpoint which has address 0, but there may be other control endpoints if required. Only control endpoints handle SETUP transactions,which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint is defined as NAK,the USB Peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way,even if the endpoint is a control one.\nBulk and interrupt endpoints have very similar behaviour and they differ only in the special feature available using the EP_KIND configuration bit."
Group_7_Item_5_Type = 1, BULK (double buffering disabled), BULK (double buffering enabled), CONTROL (status out expected), CONTROL (no status out expected), ISO (not used), INTERRUPT (not used)
Group_7_Item_5_CodingProc = SetInt((GetDWordValue(0,0xC0008018)&0x400)?0x04+((GetDWordValue(0,0xC0008018)&0x200)>>9):(GetDWordValue(0,0xC0008018)&0x700)>>8);
Group_7_Item_5_DecodingProc = SetDWordValue(0,0xC0008018,(GetInt()<<8)|((GetDWordValue(0,0xC0008018)&0x70F)|0x8080));
Group_7_Item_6_Name = SETUP
Group_7_Item_6_comment = "Bit 11 = SETUP: Setup transaction completed This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (CTR_RX event), to determine the type of transaction occurred.To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while CTR_RX bit is at 1; its state changes when CTR_RX is at 0. This bit is read-only."
Group_7_Item_6_Type = 1, LOW, HIGH
Group_7_Item_6_CodingProc = SetInt((GetDWordValue(0,0xC0008018)&0x800)?1:0);
Group_7_Item_7_Name = STAT_RX
Group_7_Item_7_comment = "Bits 13:12 = STAT_RX [1:0] Status bits, for reception transfers These bits can be toggled by software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. "
Group_7_Item_7_Type = 1, Disabled, Stall, Nak, Valid
Group_7_Item_7_CodingProc = SetInt((GetDWordValue(0,0xC0008018)&0x3000)>>12);
Group_7_Item_7_DecodingProc = SetDWordValue(0,0xC0008018,(GetInt()<<12)|((GetDWordValue(0,0xC0008018)&0x70F)|0x8080));
Group_7_Item_8_Name = DTOG_RX
Group_7_Item_8_comment = "Bit 14 = DTOG_RX: Data Toggle, for reception transfers If the endpoint is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent to the USB host, following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID addressed to this endpoint."
Group_7_Item_8_Type = 1, LOW, HIGH
Group_7_Item_8_CodingProc = SetInt((GetDWordValue(0,0xC0008018)&0x4000)?1:0);
Group_7_Item_8_DecodingProc = SetDWordValue(0,0xC0008018,(GetInt()<<14)|((GetDWordValue(0,0xC0008018)&0x70F)|0x8080));
Group_7_Item_9_Name = CTR_RX
Group_7_Item_9_comment = "Bit 15 = CTR_RX: Correct Transfer for reception This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit,since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written, writing 1 has no effect."
Group_7_Item_9_Type = 1, LOW, HIGH
Group_7_Item_9_CodingProc = SetInt((GetDWordValue(0,0xC0008018)&0x8000)?1:0);
Group_7_Item_9_DecodingProc = SetDWordValue(0,0xC0008018,(GetInt()<<15)|((GetDWordValue(0,0xC0008018)&0x70F)|0x0080));
Group_8_Name = EPOR7 (EP0R)
Group_8_Comment = "USB Endpoint Register."
Group_8_ItemsNumber = 9
Group_8_CodingProc = SetString("0x"+GetDWordValue(0,0xC000801C).toString(16));
Group_8_Item_1_Name = EA
Group_8_Item_1_comment = "Bit 3:0 = Endpoint Address.\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint."
Group_8_Item_1_Type = 0
Group_8_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC000801C)&0x0F).toString(16));
Group_8_Item_1_DecodingProc = SetDWordValue(0,0xC000801C,parseInt(GetString())|((GetDWordValue(0,0xC000801C)&0x700)|0x8080));
Group_8_Item_2_Name = STAT_TX
Group_8_Item_2_comment = "Bit 5:4 = STAT_TX [1:0] Status bits, for transmission transfers.These bits contain the information about the endpoint status. These bits can be toggled by the software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. Hardware sets the STAT_TX bits to NAK, when a correct transfer has occurred (CTR_TX=1) corresponding to a IN or SETUP (control only) transaction addressed to this endpoint. It then waits for the software to prepare the next set of data to be transmitted.Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition.If the endpoint is defined as Isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the endpoint after a successful transaction."
Group_8_Item_2_Type = 1, disabled, stall, nak, valid
Group_8_Item_2_CodingProc = SetInt((GetDWordValue(0,0xC000801C)&0x30)>>4);
Group_8_Item_2_DecodingProc = SetDWordValue(0,0xC000801C,(GetInt()<<4)|((GetDWordValue(0,0xC000801C)&0x70F)|0x8080));
Group_8_Item_3_Name = DTOG_TX
Group_8_Item_3_comment = "Bit 6 = DTOG_TX: Data Toggle, for transmission transfers.This bit can also be toggled by the software to initialize its value(mandatory when the endpoint is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes ‘0’,the value of DTOG_TX remains unchanged, while writing ‘1’ makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
Group_8_Item_3_Type = 1, unchanged,toggle
Group_8_Item_3_CodingProc = SetInt((GetDWordValue(0,0xC000801C)&0x40)?1:0);
Group_8_Item_3_DecodingProc = SetDWordValue(0,0xC000801C,(GetInt()<<6)|((GetDWordValue(0,0xC000801C)&0x70F)|0x8080));
Group_8_Item_4_Name = CTR_TX
Group_8_Item_4_comment = "Bit 7 = CTR_TX: Correct Transfer for transmission This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nNote A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written."
Group_8_Item_4_Type = 1, Low, High
Group_8_Item_4_CodingProc = SetInt((GetDWordValue(0,0xC000801C)&0x80)?1:0);
Group_8_Item_4_DecodingProc = SetDWordValue(0,0xC000801C,(GetInt()<<7)|((GetDWordValue(0,0xC000801C)&0x70F)|0x8000));
Group_8_Item_5_Name = EP_TYPE (EP_KIND)
Group_8_Item_5_comment = "Endpoint 0 must always\nbe a control endpoint and each USB function must have at least one control endpoint which has address 0, but there may be other control endpoints if required. Only control endpoints handle SETUP transactions,which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint is defined as NAK,the USB Peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way,even if the endpoint is a control one.\nBulk and interrupt endpoints have very similar behaviour and they differ only in the special feature available using the EP_KIND configuration bit."
Group_8_Item_5_Type = 1, BULK (double buffering disabled), BULK (double buffering enabled), CONTROL (status out expected), CONTROL (no status out expected), ISO (not used), INTERRUPT (not used)
Group_8_Item_5_CodingProc = SetInt((GetDWordValue(0,0xC000801C)&0x400)?0x04+((GetDWordValue(0,0xC000801C)&0x200)>>9):(GetDWordValue(0,0xC000801C)&0x700)>>8);
Group_8_Item_5_DecodingProc = SetDWordValue(0,0xC000801C,(GetInt()<<8)|((GetDWordValue(0,0xC000801C)&0x70F)|0x8080));
Group_8_Item_6_Name = SETUP
Group_8_Item_6_comment = "Bit 11 = SETUP: Setup transaction completed This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (CTR_RX event), to determine the type of transaction occurred.To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while CTR_RX bit is at 1; its state changes when CTR_RX is at 0. This bit is read-only."
Group_8_Item_6_Type = 1, LOW, HIGH
Group_8_Item_6_CodingProc = SetInt((GetDWordValue(0,0xC000801C)&0x800)?1:0);
Group_8_Item_7_Name = STAT_RX
Group_8_Item_7_comment = "Bits 13:12 = STAT_RX [1:0] Status bits, for reception transfers These bits can be toggled by software to initialize their value. When the application software writes ‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. "
Group_8_Item_7_Type = 1, Disabled, Stall, Nak, Valid
Group_8_Item_7_CodingProc = SetInt((GetDWordValue(0,0xC000801C)&0x3000)>>12);
Group_8_Item_7_DecodingProc = SetDWordValue(0,0xC000801C,(GetInt()<<12)|((GetDWordValue(0,0xC000801C)&0x70F)|0x8080));
Group_8_Item_8_Name = DTOG_RX
Group_8_Item_8_comment = "Bit 14 = DTOG_RX: Data Toggle, for reception transfers If the endpoint is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent to the USB host, following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID addressed to this endpoint."
Group_8_Item_8_Type = 1, LOW, HIGH
Group_8_Item_8_CodingProc = SetInt((GetDWordValue(0,0xC000801C)&0x4000)?1:0);
Group_8_Item_8_DecodingProc = SetDWordValue(0,0xC000801C,(GetInt()<<14)|((GetDWordValue(0,0xC000801C)&0x70F)|0x8080));
Group_8_Item_9_Name = CTR_RX
Group_8_Item_9_comment = "Bit 15 = CTR_RX: Correct Transfer for reception This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit,since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written, writing 1 has no effect."
Group_8_Item_9_Type = 1, LOW, HIGH
Group_8_Item_9_CodingProc = SetInt((GetDWordValue(0,0xC000801C)&0x8000)?1:0);
Group_8_Item_9_DecodingProc = SetDWordValue(0,0xC000801C,(GetInt()<<15)|((GetDWordValue(0,0xC000801C)&0x70F)|0x0080));
Group_9_Name = Control Register (CNTR)
Group_9_Comment = "USB Control Register (USB_CNTR).\n•Address Offset: 40h.\n•Reset Value: 0000 0000 0000 0011 (0003h)."
Group_9_ItemsNumber = 13
Group_9_CodingProc = SetString("0x"+GetDWordValue(0,0xC0008040).toString(16));
Group_9_Item_1_Name = FRES
Group_9_Item_1_Comment = "Bit 0 = FRES: Force USB Reset\n•0: Clear USB reset.\n•1: Force a reset of the USB Peripheral, exactly like a RESET signalling on the USB. The USB Peripheral is held in RESET state until software clears this bit. A “USB-RESET” interrupt is generated, if enabled."
Group_9_Item_1_Type = 1, normal, force reset
Group_9_Item_1_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&1)?1:0);
Group_9_Item_1_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?1:0)|(GetDWordValue(0,0xC0008040)&~1));
Group_9_Item_2_Name = PDWN
Group_9_Item_2_Comment = "Bit 1 = PDWN: Power down\nThis bit is used to completely switch off all USB-related analog parts if it is required to completely disable the USB Peripheral for any reason. When this bit is set, the USB Peripheral is disconnected from the transceivers and it cannot be used.\n•0: Exit Power Down.\n•1: Enter Power down mode."
Group_9_Item_2_Type = 1, normal, enter power down
Group_9_Item_2_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&2)?1:0);
Group_9_Item_2_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?2:0)|(GetDWordValue(0,0xC0008040)&~2));
Group_9_Item_3_Name = LP_MODE
Group_9_Item_3_Comment = "Bit 2 = LP_MODE: Low-power mode This mode is used when the suspend-mode power constraints require that all static power dissipation is avoided, except the one required to supply the external pull-up resistor. This condition should be entered when the application is ready to stop all system clocks, or reduce their frequency in order to meet the power consumption requirements of the USB suspend condition. The USB activity during the suspend mode (WKUP event) asynchronously resets this bit (it can also be reset by software).\n"
0: No Low Power Mode.\n1: Enter Low Power mode.
Group_9_Item_3_Type = 1, normal, low power mode
Group_9_Item_3_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&0x04)?1:0);
Group_9_Item_3_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?0x04:0)|(GetDWordValue(0,0xC0008040)&~0x04));
Group_9_Item_4_Name = FSUSP
Group_9_Item_4_Comment = "Bit 3 = FSUSP: Force suspend\nSoftware must set this bit when the SUSP interrupt is received, which is issued when no traffic is received by the USB Peripheral for 3 mS.\n•0: No effect.\n•1: Enter suspend mode. Clocks and static power dissipation in the analog transceiver are left unaffected. If suspend power consumption is a requirement (bus-powered device), the application software should set the LP_MODE bit after FSUSP as explained below."
Group_9_Item_4_Type = 1, normal, suspend mode
Group_9_Item_4_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&0x08)?1:0);
Group_9_Item_4_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?0x08:0)|(GetDWordValue(0,0xC0008040)&~0x08));
Group_9_Item_5_Name = RESUME
Group_9_Item_5_Comment = "Bit 4 = RESUME: Resume request The microcontroller can set this bit to send a Resume signal to the host. It must be activated, according to USB specifications, for no less than 1mS and no more than 15mS after which the Host PC is ready to drive the resume sequence up to its end."
Group_9_Item_5_Type = 1, no request, request
Group_9_Item_5_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&0x010)?1:0);
Group_9_Item_5_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?0x010:0)|(GetDWordValue(0,0xC0008040)&~0x010));
Group_9_Item_6_Name = ESOFM
Group_9_Item_6_Comment = "Bit 8 = ESOFM: Expected Start Of Frame Interrupt Mask\n•0: Expected Start of Frame (ESOF) Interrupt disabled.\n•1: ESOF Interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set."
Group_9_Item_6_Type = 1, disable interrupt, enable interrupt
Group_9_Item_6_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&0x0100)?1:0);
Group_9_Item_6_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?0x0100:0)|(GetDWordValue(0,0xC0008040)&~0x0100));
Group_9_Item_7_Name = SOFM
Group_9_Item_7_Comment = "Bit 9 = SOFM: Start Of Frame Interrupt Mask\n•0: SOF Interrupt disabled\n•1: SOF Interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set."
Group_9_Item_7_Type = 1, disable interrupt, enable interrupt
Group_9_Item_7_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&0x0200)?1:0);
Group_9_Item_7_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?0x0200:0)|(GetDWordValue(0,0xC0008040)&~0x0200));
Group_9_Item_8_Name = RESETM
Group_9_Item_8_Comment = "Bit 10 = RESETM: USB Reset Interrupt Mask\n•0: RESET Interrupt disabled.\n•1: RESET Interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set."
Group_9_Item_8_Type = 1, disable interrupt, enable interrupt
Group_9_Item_8_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&0x0400)?1:0);
Group_9_Item_8_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?0x0400:0)|(GetDWordValue(0,0xC0008040)&~0x0400));
Group_9_Item_9_Name = SUSPM
Group_9_Item_9_Comment = "Bit 11 = SUSPM: Suspend mode Interrupt Mask\n•0: Suspend Mode Request (SUSP) Interrupt disabled.\n•1: SUSP Interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set."
Group_9_Item_9_Type = 1, disable interrupt, enable interrupt
Group_9_Item_9_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&0x0800)?1:0);
Group_9_Item_9_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?0x0800:0)|(GetDWordValue(0,0xC0008040)&~0x0800));
Group_9_Item_10_Name = WKUPM
Group_9_Item_10_Comment = "Bit 12 = WKUPM: Wake-up Interrupt Mask\n•0: WKUP Interrupt disabled.\n•1: WKUP Interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set."
Group_9_Item_10_Type = 1, disable interrupt, enable interrupt
Group_9_Item_10_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&0x1000)?1:0);
Group_9_Item_10_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?0x1000:0)|(GetDWordValue(0,0xC0008040)&~0x1000));
Group_9_Item_11_Name = ERRM
Group_9_Item_11_Comment = "Bit 13 = ERRM: Error Interrupt Mask\n•0: ERR Interrupt disabled.\n•1: ERR Interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set."
Group_9_Item_11_Type = 1, disable interrupt, enable interrupt
Group_9_Item_11_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&0x2000)?1:0);
Group_9_Item_11_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?0x2000:0)|(GetDWordValue(0,0xC0008040)&~0x2000));
Group_9_Item_12_Name = DOVRM
Group_9_Item_12_Comment = "Bit 14 = DOVRM: DMA over / underrun Interrupt Mask\n•0: DOVR Interrupt disabled.\n•1: DOVR Interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set."
Group_9_Item_12_Type = 1, disable interrupt, enable interrupt
Group_9_Item_12_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&0x4000)?1:0);
Group_9_Item_12_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?0x4000:0)|(GetDWordValue(0,0xC0008040)&~0x4000));
Group_9_Item_13_Name = CTRM
Group_9_Item_13_Comment = "Bit 15 = CTRM: Correct Transfer Interrupt Mask.\n•0: Correct Transfer (CTR) Interrupt disabled.\n•1: CTR Interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set."
Group_9_Item_13_Type = 1, disable interrupt, enable interrupt
Group_9_Item_13_CodingProc = SetInt((GetDWordValue(0,0xC0008040)&0x8000)?1:0);
Group_9_Item_13_DecodingProc = SetDWordValue(0,0xC0008040,(GetInt()?0x8000:0)|(GetDWordValue(0,0xC0008040)&~0x8000));
Group_10_Name = Interrupt Status Register (ISTR)
Group_10_Comment = "USB Interrupt Status Register (USB_ISTR).\n•Address Offset: 44h.\n•Reset Value: 0000 0000 0000 0000 (0000h)."
Group_10_ItemsNumber = 10
Group_10_CodingProc = SetString("0x"+GetDWordValue(0,0xC0008044).toString(16));
Group_10_Item_1_Name = EP_ID
Group_10_Item_1_Comment = "Bits 3:0 = EP_ID[3:0]: Endpoint Identifier.\nThese bits are written by the hardware according to the endpoint number, which generated the interrupt request. If several endpoint transactions are pending, the hardware writes the endpoint identifier related to the endpoint having the highest priority defined in the following way: Two endpoint sets are defined, in order of priority: Isochronous and double-buffered bulk endpoints are considered first and then the other endpoints are examined. If more than one endpoint from the same set is requesting an interrupt, the EP_ID bits in USB_ISTR register are assigned according to the lowest requesting endpoint register, EP0R having the highest priority followed by EP1R and so on. The application software can assign a register to each endpoint according to this priority scheme, so as to order the concurring endpoint requests in a suitable way. These bits are read only."
Group_10_Item_1_Type = 0
Group_10_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC0008044)&0x0F).toString(16));
Group_10_Item_2_Name = DIR
Group_10_Item_2_Comment = "Bit 4 = DIR: Direction of transaction.\nThis bit is written by the hardware according to the direction of the successful transaction, which generated the interrupt request.\nIf DIR bit=0, CTR_TX bit is set in the USB_EPnR register related to the interrupting endpoint. The interrupting transaction is of IN type (data transmitted by the USB Peripheral to the host PC).\nIf DIR bit=1, CTR_RX bit or both CTR_TX/CTR_RX are set in the USB_EPnR register related to the interrupting endpoint. The interrupting transaction is of OUT type (data received by the USB Peripheral from the host PC) or two pending transactions are waiting to be processed.\nThis information can be used by the application software to access the USB_EPnR bits related to the triggering transaction since it represents the direction having the interrupt pending. This bit is read-only."
Group_10_Item_2_Type = 1, IN, OUT or two pending transactions
Group_10_Item_2_CodingProc = SetInt((GetDWordValue(0,0xC0008044)&0x08)?1:0);
Group_10_Item_3_Name = ESOF
Group_10_Item_3_Comment = "Bit 8 = ESOF: Expected Start Of Frame\nThis bit is set by the hardware when an SOF packet is expected but not received.\nThe host sends an SOF packet each mS, but if the hub does not receive it properly, the Suspend Timer issues this interrupt. If three consecutive ESOF interrupts are generated (i.e. three SOF packets are lost) without any traffic occurring in between, a SUSP interrupt is generated. This bit is set even when the missing SOF packets occur while the Suspend Timer is not yet locked. This bit is read/write but only ‘0’ can be written and writing ‘1’ has no effect."
Group_10_Item_3_Type = 1, LOW, HIGH (expected start of frame)
Group_10_Item_3_CodingProc = SetInt((GetDWordValue(0,0xC0008044)&0x0100)?1:0);
Group_10_Item_3_DecodingProc = SetDWordValue(0,0xC0008044,GetInt()?(GetDWordValue(0,0xC0008044)):(GetDWordValue(0,0xC0008044)&~0x0100));
Group_10_Item_4_Name = SOF
Group_10_Item_4_Comment = "Bit 9 = SOF: Start Of Frame\nThis bit signals the beginning of a new USB frame and it is set when a SOF packet arrives through the USB bus. The interrupt service routine may monitor the SOF events to have a 1mS synchronization event to the USB host and to safely read the USB_FNR register which is updated at the SOF packet reception (this could be useful for isochronous applications). This bit is read/write but only ‘0’ can be written and writing ‘1’ has no effect."
Group_10_Item_4_Type = 1, LOW, HIGH (start of frame)
Group_10_Item_4_CodingProc = SetInt((GetDWordValue(0,0xC0008044)&0x0200)?1:0);
Group_10_Item_4_DecodingProc = SetDWordValue(0,0xC0008044,GetInt()?(GetDWordValue(0,0xC0008044)):(GetDWordValue(0,0xC0008044)&~0x0200));
Group_10_Item_5_Name = RESET
Group_10_Item_5_Comment = "Bit 10 = RESET: USB RESET request\nSet when the USB Peripheral detects an active USB RESET signal at its inputs.\nThe USB Peripheral, in response to a RESET, just resets its internal protocol state machine, generating an interrupt if RESETM enable bit in the USB_CNTR register is set. Reception and transmission are disabled until the RESET bit is cleared. All configuration registers do not reset: the microcontroller must explicitly clear these registers (this is to ensure that the RESET interrupt can be safely delivered, and any transaction immediately followed by a RESET can be completed). The function address and endpoint registers are reset by an USB reset event.\nThis bit is read/write but only ‘0’ can be written and writing ‘1’ has no effect."
Group_10_Item_5_Type = 1, LOW, HIGH (USB reset request)
Group_10_Item_5_CodingProc = SetInt((GetDWordValue(0,0xC0008044)&0x0400)?1:0);
Group_10_Item_5_DecodingProc = SetDWordValue(0,0xC0008044,GetInt()?(GetDWordValue(0,0xC0008044)):(GetDWordValue(0,0xC0008044)&~0x0400));
Group_10_Item_6_Name = SUSP
Group_10_Item_6_Comment = "Bit 11 = SUSP Suspend mode request\nThis bit is set by the hardware when no traffic has been received for 3mS,indicating a suspend mode request from the USB bus. The suspend condition check is enabled immediately after any USB reset and it is disabled by the hardware when the suspend mode is active (FSUSP=1) until the end of resume sequence. This bit is read/write but only ‘0’ can be written and writing ‘1’ has no effect."
Group_10_Item_6_Type = 1, LOW, HIGH (suspend mode request)
Group_10_Item_6_CodingProc = SetInt((GetDWordValue(0,0xC0008044)&0x0800)?1:0);
Group_10_Item_6_DecodingProc = SetDWordValue(0,0xC0008044,GetInt()?(GetDWordValue(0,0xC0008044)):(GetDWordValue(0,0xC0008044)&~0x0800));
Group_10_Item_7_Name = WKUP
Group_10_Item_7_Comment = "Bit 12 = WKUP: Wake up\nThis bit is set to 1 by the hardware when, during suspend mode, activity is detected that wakes up the USB Peripheral. This event asynchronously clears the LP_MODE bit in the CTLR register and activates the USB_WAKEUP line, which can be used to notify the rest of the device (e.g. wake-up unit) about the start of the resume process. This bit is read/write but only ‘0’ can be written and writing ‘1’has no effect."
Group_10_Item_7_Type = 1, LOW, HIGH (wake up)
Group_10_Item_7_CodingProc = SetInt((GetDWordValue(0,0xC0008044)&0x1000)?1:0);
Group_10_Item_7_DecodingProc = SetDWordValue(0,0xC0008044,GetInt()?(GetDWordValue(0,0xC0008044)):(GetDWordValue(0,0xC0008044)&~0x1000));
Group_10_Item_8_Name = ERR
Group_10_Item_8_Comment = "Bit 13 = ERR: Error\nThis flag is set whenever one of the errors listed below has occurred:\nNANS: No ANSwer. The timeout for a host response has expired.\nCRC: Cyclic Redundancy Check error. One of the received CRCs, either in the token or in the data, was wrong.\nBST: Bit Stuffing error. A bit stuffing error was detected anywhere in the PID, data,and/or CRC.\nFVIO: Framing format Violation. A non-standard frame was received (EOP not in the right place, wrong token sequence, etc.).\nThe USB software can usually ignore errors, since the USB Peripheral and the PC host manage retransmission in case of errors in a fully transparent way. This interrupt can be useful during the software development phase, or to monitor the quality of transmission over the USB bus, to flag possible problems to the user (e.g. loose connector, too noisy environment, broken conductor in the USB cable and so on). This bit is read/write but only ‘0’ can be written and writing ‘1’ has no effect."
Group_10_Item_8_Type = 1, LOW, HIGH (error)
Group_10_Item_8_CodingProc = SetInt((GetDWordValue(0,0xC0008044)&0x2000)?1:0);
Group_10_Item_8_DecodingProc = SetDWordValue(0,0xC0008044,GetInt()?(GetDWordValue(0,0xC0008044)):(GetDWordValue(0,0xC0008044)&~0x2000));
Group_10_Item_9_Name = DOVR
Group_10_Item_9_Comment = "Bit 14 = DOVR: DMA over / underrun\nThis bit is set if the microcontroller has not been able to respond in time to an USB memory request. The USB Peripheral handles this event in the following way: During reception an ACK handshake packet is not sent, during transmission a bit-stuff error is forced on the transmitted stream; in both cases the host will retry the transaction. The DOVR interrupt should never occur during normal operations. Since the failed transaction is retried by the host, the application software has the chance to speed-up device operations during this interrupt handling, to be ready for the next transaction retry; however this does not happen during Isochronous transfers (no isochronous transaction is anyway retried)leading to a loss of data in this case. This bit is read/write but only ‘0’ can be written and writing ‘1’ has no effect."
Group_10_Item_9_Type = 1, LOW, HIGH (DMA over/underrun)
Group_10_Item_9_CodingProc = SetInt((GetDWordValue(0,0xC0008044)&0x4000)?1:0);
Group_10_Item_9_DecodingProc = SetDWordValue(0,0xC0008044,GetInt()?(GetDWordValue(0,0xC0008044)):(GetDWordValue(0,0xC0008044)&~0x4000));
Group_10_Item_10_Name = CTR
Group_10_Item_10_Comment = "Bit 15 = CTR: Correct Transfer\nThis bit is set by the hardware to indicate that an endpoint has successfully completed a transaction; using DIR and EP_ID bits software can determine which endpoint requested the interrupt. This bit is read-only."
Group_10_Item_10_Type = 1, LOW, HIGH (correct transfer)
Group_10_Item_10_CodingProc = SetInt((GetDWordValue(0,0xC0008044)&0x8000)?1:0);
Group_11_Name = Frame Number Register (FNR)
Group_11_Comment = "USB Frame Number Register (USB_FNR).\n•Address Offset: 48h.\n•Reset Value: 0000 0xxx xxxx xxxx (0xxxh)."
Group_11_ItemsNumber = 5
Group_11_CodingProc = SetString("0x"+GetDWordValue(0,0xC0008048).toString(16));
Group_11_Item_1_Name = FN
Group_11_Item_1_Comment = "Bits 10:0 = FN[10:0]: Frame Number\nThis bit field contains the 11-bits frame number contained in the last received SOF packet. The frame number is incremented for every frame sent by the host and it is useful for Isochronous transfers. This bit field is updated on the generation of an SOF interrupt."
Group_11_Item_1_Type = 0
Group_11_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC0008048)&0x07FF).toString(16));
Group_11_Item_2_Name = LSOF
Group_11_Item_2_Comment = "Bits12:11 = LSOF[1:0]: Lost SOF\nThese bits are written by the hardware when an ESOF interrupt is generated, counting the number of consecutive SOF packets lost. At the reception of an SOF packet, these bits are cleared."
Group_11_Item_2_Type = 0
Group_11_Item_2_CodingProc = SetString((GetDWordValue(0,0xC0008048)&0x1800).toString(10));
Group_11_Item_3_Name = LCK
Group_11_Item_3_Comment = "Bit 13 = LCK: Locked\nThis bit is set by the hardware when at least two consecutive SOF packets have been received after the end of an USB reset condition or after the end of an USB resume sequence. Once locked, the frame timer remains in this state until an USB reset or USB suspend event occurs."
Group_11_Item_3_Type = 1, not locked, locked
Group_11_Item_3_CodingProc = SetInt((GetDWordValue(0,0xC0008048)&0x2000)?1:0);
Group_11_Item_4_Name = RXDM
Group_11_Item_4_Comment = "Bit 14 = RXDM. Receive Data - Line Status\nThis bit can be used to observe the status of received data minus upstream port data line. It can be used during end-of-suspend routines to help determining the wake-up event."
Group_11_Item_4_Type = 1, LOW, HIGH
Group_11_Item_4_CodingProc = SetInt((GetDWordValue(0,0xC0008048)&0x4000)?1:0);
Group_11_Item_5_Name = RXDP
Group_11_Item_5_Comment = "Bit 15 = RXDP Receive Data + Line Status\nThis bit can be used to observe the status of received data plus upstream port data line. It can be used during end-of-suspend routines to help determining the wake-up event."
Group_11_Item_5_Type = 1, LOW, HIGH
Group_11_Item_5_CodingProc = SetInt((GetDWordValue(0,0xC0008048)&0x4000)?1:0);
Group_12_Name = Device Address (DADDR)
Group_12_Comment = "USB Device Address (USB_DADDR)\n•Address Offset: 4Ch.\n•Reset Value: 0000 0000 0000 0000 (0000h)."
Group_12_ItemsNumber = 2
Group_12_CodingProc = SetString("0x"+GetDWordValue(0,0xC000804C).toString(16));
Group_12_Item_1_Name = DADDR
Group_12_Item_1_Comment = "Bits 6:0 = ADD[6:0]: Device Address\nThese bits contain the USB function address assigned by the host PC during the enumeration process. Both this field and the Endpoint Address (EA) field in the associated USB_EPnR register must match with the information contained in a USB token in order to handle a transaction to the required endpoint."
Group_12_Item_1_Type = 0
Group_12_Item_1_CodingProc = SetString("0x"+(GetDWordValue(0,0xC000804C)&0x7F).toString(16));
Group_12_Item_1_DecodingProc = SetDWordValue(0,0xC000804C,parseInt(GetString()));
Group_12_Item_2_Name = EF
Group_12_Item_2_Comment = "Bit 7 = EF: Enable Function\nThis bit is set by the software to enable the USB device. The address of this device is contained in the following ADD[6:0] bits. If this bit is at ‘0’ no transactions are handled, irrespective of the settings of USB_EPnR registers."
Group_12_Item_2_Type = 1, disable USB, enable USB
Group_12_Item_2_CodingProc = SetInt((GetDWordValue(0,0xC000804C)&0x80)?1:0);
Group_12_Item_2_DecodingProc = SetDWordValue(0,0xC000804C,(GetInt()?0x80:0)|(GetDWordValue(0,0xC000804C)&~0x802));
Group_13_Name = Buffer Table Address (BTABLE)
Group_13_Comment = "Buffer Table Address (USB_BTABLE).\n•Address Offset: 50h.\n•Reset Value: 0000 0000 0000 0000 (0000h)."
Group_13_ItemsNumber = 1
Group_13_Item_1_Name = BTABLE
Group_13_Item_1_Comment = "•Bits 15:3 = BTABLE[15:3]: Buffer Table.\nThese bits contain the start address of the buffer allocation table inside the dedicated packet memory. This table describes each endpoint buffer location and size and it must be aligned to an 8 byte boundary (the 3 least significant bits are always ‘0’). At the beginning of every transaction addressed to this device, the USP peripheral reads the element of this table related to the addressed endpoint, to get its buffer start location and the buffer size (Refer to Section “Structure and Usage of Packet Buffers”).\n•Bits 2:0 Reserved.\nThese are reserved bits. These bits are always read as ‘0’ and must always be written with ‘0’."
Group_13_Item_1_Type = 0
Group_13_Item_1_CodingProc = SetString("0x"+GetDWordValue(0,0xC0008050).toString(16));
Group_13_Item_1_DecodingProc = SetDWordValue(0,0xC0008050,parseInt(GetString()));
